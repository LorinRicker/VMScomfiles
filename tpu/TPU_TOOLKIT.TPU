! Source Filename:  TPU_TOOLKIT.TPU (TTK)
!     Released as:  KED.TPU$SECTION
!         Authors:  Lorin Ricker & Richard Evans
!         Version:  see global constant `K$version'
!
!        Facility:  Text Processing Utility (VAXTPU), version 2.x
!        Abstract:  VAXTPU source program for an original text editor
!                   based on the concepts of a TPU Toolkit.
!
!     Environment:  OpenVMS v5, v6 & v7 (...)

!     This program is the confidential and proprietary product of
!     LockWorks LLC.  Any unauthorized use, reproduction or transfer
!     of this program is strictly prohibited.
!
!     Copyright © 2002-2005 by LockWorks LLC.  All rights reserved.
!     Copyright © 1990-2002 by Evans & Ricker, Inc.  All rights reserved.


! === IDENTIFICATION === !

CONSTANT
  K$version := 'TPU_TOOLKIT v.3016 (4-FEB-2013 11:45)'
             + " - Copyright © 1990-2013, Lorin Ricker";

! === INITIALIZATION === !

CONSTANT
  NULL := "",  !null string

  ! OpCodes for CALL_USER:             ! Related arguments for CALL_USER:
  K$OpCode_EchoCheck     := 0,
  K$OpCode_Define_LNM    := 1,         KED$ExitLNM := "KED$EXIT_INFO",
  K$OpCode_Delete_LNM    := 2,
  K$OpCode_Check_ifQue   := 3,
  K$OpCode_Que_File      := 4,
  K$OpCode_Translate_LNM := 5,
  K$OpCode_Set_Symbol    := 6,
  K$OpCode_Get_Symbol    := 7,

  LIB$K_CLI_LOCAL_SYM    := 1,
  LIB$K_CLI_GLOBAL_SYM   := 2,

  ! Menu KeyMap names:
  KML$MENU := "KED_MENU_LIST",
  KM$MENU  := "KED_MENU",

  ! "VT" (default KED) KeyMap names:
  KML$KED  := "KED_LIST",
  KM$KED   := "KED_MAP",
  KM$KED0  := KM$KED + "0",    KM$KED1 := KM$KED + "1",
  KM$KED2  := KM$KED + "2",    KM$KED3 := KM$KED + "3",

  ! "PC" KeyMap names:
  KML$PC   := "PC_LIST",
  KM$PC    := "PC_MAP",
  KM$PC0   := KM$PC + "0",     KM$PC1  := KM$PC + "1",
  KM$PC2   := KM$PC + "2",     KM$PC3  := KM$PC + "3",

  ! Function codes for P$Bye:
  K$Exit := 0,  K$NoFiles := 1,
  K$Quit := 2,  K$Attach  := 3,

  ! Character constants:
  K$tab := ASCII(  9 ),  K$spc       := ASCII(  32 ),
  K$lf  := ASCII( 10 ),  K$dquote    := ASCII(  34 ),  !double quote "
  K$vt  := ASCII( 11 ),  K$squote    := ASCII(  39 ),  !single quote '
  K$ff  := ASCII( 12 ),  K$comma     := ASCII(  44 ),
  K$cr  := ASCII( 13 ),  K$period    := ASCII(  46 ),
  K$so  := ASCII( 14 ),  K$semicolon := ASCII(  59 ),
  K$si  := ASCII( 15 ),  K$csi       := ASCII( 155 ),
  K$esc := ASCII( 27 ),  K$ss3       := ASCII( 143 ),
                         K$pilcrow   := ASCII( 182 ),  !"¶"

  K$spc_tab    := K$spc + K$tab,
  K$chevrons   := ASCII( 171 ) + ASCII( 187 ),  !«chevrons»
  K$spaces     := K$spc * 128,
  K$WHITESPACE := K$spc + K$tab + K$lf + K$vt + K$ff + K$cr,
  K$UPLETTERS  := "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  K$LOLETTERS  := "abcdefghijklmnopqrstuvwxyz",
  K$LETTERS    := K$UPLETTERS + K$LOLETTERS,
  K$DIGITS     := "0123456789",
  K$IDENTCHARS := K$LETTERS + K$DIGITS + "$_",     !programming identifiers
  K$SPECIAL7   := "~!@#$%^&*()[]{}-_=+;:\|,./?",   !7-bit punctuation
  K$SPECIAL8   := "«©¢¥£±¹²³°µ§¨·¶ªº½¼»¡¿",        !8-bit punctuation

  K$maxRuler   := 960,   !maximum ruler length = maximum TPU line length

  ! DEC/ANSI priters:          ! HP/PCL printers:
  K$ANSI_Str_BOLD  := "[1m",  K$PCL_Str_BOLD  := "(s3B",
  K$ANSI_Rend      := "[0m",  K$PCL_End_BOLD  := "(s0B",
  K$ANSI_Str_UNDER := "[4m",  K$PCL_Str_UNDER := "&d0D",
                               K$PCL_End_UNDER := "&d@",

  K$MaxFiles := 100,

  ! KED-system buffer names:
  K$DCL    := "$ ",        K$DCLbuf := "$$DCL",     K$Lisbuf := "$$LIST",
  K$LSEbuf := "$$LSE",     K$Legbuf := "$$LEGEND",  K$Pstbuf := "$$PASTE",
  K$Scrbuf := "$$SCRATCH", K$Delbuf := "$$DELETE",

  K$nostat  := ".TPU$X_MESSAGE.TPU$X_SHOW.$LOCAL$INI$"  !TPU-special
             + ".$$KEYPAD." + K$LSEbuf + K$period       !KED-specific
             + K$Scrbuf + K$period,
  K$noshow  := K$nostat + K$DCLbuf + K$period + K$Lisbuf
             + K$period + K$Pstbuf + K$Delbuf + K$period,


  ! Message text/templates:
  K$BJf_msg := "Failed to open Buffer Journal",
  K$CAN_msg := "!AS canceled",
  K$CTRL_Rp := "Ctrl/R to End Learn Sequence",
  K$CTRL_Zp := "Ctrl/Z to resume editing",
  K$CTRL_Zq := "Press Ctrl/Z to quit",
  K$dfspec  := "sys$disk:[];",
  K$Jnf_msg := "Buffer journal !AS`!AS' not found",
  K$Jun_msg := "`!AS' unsafe for journaling...",
  K$Jsv_msg := "[1mSave your work![0m",
  K$LC1_msg := "Key !AS (<CTRL/Z>=quit)? ",
  K$LC2_msg := "Key is already defined, select another key",
  K$LC3_msg := "Do not use a typing key for !AS",
  K$LC4_msg := "Key recursively used in !AS",
  K$NKM_msg := "No Key Mapping exists for `!AS'",
  K$NLB_msg := "No last buffer",
  K$NMA_msg := "No menu action",
  K$Nre_msg := "Cannot finish recovery of `!AS'",
  K$NSA_msg := "No select active (!AS)",
  K$NYS_msg := "`!AS' not saved... [1mSave it soon!![0m",  !FAO "!!"
  K$Pr1_msg := "Temp-file `!AS'",
  K$Pr2_msg := "    printing!AS on que !AS",
  K$Out_msg := "File `!AS' saved!AS",
  K$VNE_msg := "KED/TPU variable `[1m!AS[0m' does not exist",
  K$xNF_msg := "!AS `!AS' not found",
  K$Cp1_msg := "Checkpoint done; !SL buffer!%S written",
  K$Cp2_msg := "Checkpoint: no modified buffers to write"   ;


PROCEDURE TPU$INIT_PROCEDURE
LOCAL wild, opt, exists, inf, fspc, outf, lnm, iomo, c0, DefJou;
ON_ERROR  !RMS file errors (file/dir not found)
ENDON_ERROR
  GV$_debug := FALSE;
  GV$_trace := FALSE;

  SET ( LINE_NUMBER, ON );

  K$EUROLETTERS := F$IStr( 176, 254 );     !European (ümlauts, etc.)

  GV$_BufName  := CREATE_ARRAY;   !all dynamic, no static part
  GV$_LastMark := CREATE_ARRAY;   !...ditto

  G$KML  := KML$KED;    G$Map := "KED";  !default key mappings
  G$Base := KM$KED0;
  G$Gold := KM$KED1;
  G$Buff := KM$KED2;
  G$Stat := KM$KED3;

  GV$_Lbuf   := 0;    !TPU$INIT_PROCEDURE Gate: first an INTEGER...
  GV$_MBuf   := 0;    !"Main buffer" is initially undefined

  GV$UserSLData := NULL; !permits user-data on Status Line (template files)

  GV$_SelectRngStart := 0;  GV$_SelectRng := 0;        GV$_SearchRng := 0;
  GV$_flipR    := 0;        GV$_RngA      := 0;        GV$_RngB      := 0;
  GV$_shftc    := 0;        GV$_Lmenu     := 0;        GV$_Hmenu     := 0;
  GV$_Lmargin  := 0;        GV$_Rmargin   := 0;        GV$_srchflip  := 1;
  GV$_ruPos    := 1;        GV$_ruRngA    := 0;        GV$_ruRngB    := 0;
  GV$_dir      := 0;        GV$_mode      := 0;        GV$_mdfy      := 0;
  GV$_Bvar     := 0;        GV$_B         := 0;        GV$_MWin      := 0;

  GV$_Cmenu    := NULL;     GV$_delchar   := NULL;     GV$_delword  := NULL;
  GV$_delline  := NULL;     GV$_delstr    := NULL;
  GV$_srchtar  := NULL;     GV$_srchtext  := NULL;
  GV$_Xstr     := NULL;     GV$_marks     := NULL;     GV$_TPU_cmd  := NULL;
  GV$_genpatrn := NULL;     GV$_DCLpid    := NULL;

  GV$_LSEp     := NULL;     GV$_LSErng    := 0;        GV$_LSEexec  := "@";
  G$LSEloaded  := NULL;

  GV$_srchbeg  := TRUE;     GV$_wildmode  := TRUE;     GV$_realtabs := FALSE;
  GV$_delcrlf  := FALSE;    GV$_appline   := FALSE;
  GV$_learning := FALSE;    GV$_autotab   := FALSE;    GV$_QuitPend := FALSE;
  GV$_lmode    := EXACT;    GV$_ccase     := INVERT;   GV$_srchcase := NO_EXACT;
  GV$_insovr   := "I";      GV$_statdisp  := "C";      GV$_compdflt := "CV";

  ! Default list of files for which to inhibit paragraph ¶-filling:
  GV$_InhibitFill := "C.COM.DEF.MAK.PAS.PERL.PRL.RDO.RPA.SCN.SPA.SQL.TPU";

  GV$_ruler := "L2345678T 123456T89 1234T6789 12T456789 "
             + "T2345678T 123456T89 1234T6789 12T456789 ";
  LOOP
    EXITIF ( LENGTH( GV$_ruler ) >= K$maxRuler );
    GV$_ruler := GV$_ruler + "123456789 123456789 123456789 123456789 ";
    ENDLOOP;
  GV$_guide := "";
  LOOP
    EXITIF ( LENGTH( GV$_guide ) >= K$maxRuler );
    GV$_guide := GV$_guide + "123456789 123456789 123456789 123456789 ";
    ENDLOOP;

  GV$_word   := NULL;  P$WordDelims( GV$_word );
  GV$_wordel := NULL;  P$WordDelims( GV$_wordel, ".," );
  GV$_Ldelims  := "([{`" + K$dquote;      !matching pairs
  GV$_Rdelims  := ")]}'" + K$dquote;
  GV$_CmplErr  := LINE_BEGIN + MATCH( "-E-" ) + MATCH( "," );
  GV$_wildpat  := ( SPAN( K$LETTERS )  | SPAN( K$DIGITS )
                    | SPAN( K$EUROLETTERS )
                    | SPAN( K$SPECIAL7 ) | SPAN( K$SPECIAL8 ) );

  ! OpenVMS file specification
  GV$_filespec := ( SPAN( K$IDENTCHARS ) + "::" | NULL )            ! node::
                & ( SPAN( K$IDENTCHARS ) + ":"  | NULL )            ! dev:
                & ( "[" + SPAN( K$IDENTCHARS + "." ) + "]" | NULL ) ! [dir.sub]
                & ( SPAN( K$IDENTCHARS ) | NULL )                   ! filename
                & "." & ( SPAN( K$IDENTCHARS ) | NULL )             ! .type
                & ( ( ";" & SPAN( K$DIGITS ) ) | ";" | NULL );      ! ;version

  GV$_MBD_mark := 0;  GV$_MBU_mark := 0;

  GV$_screen := GET_INFO( SCREEN, "VISIBLE_LENGTH" );

  $$KEYPAD_WINDOW := 0;  !created only when needed
  $$DCL_BUFFER    := 0;
  $$LIST_BUFFER   := 0;
  $$LSE_BUFFER    := 0;
  $$LEGEND_WINDOW := 0;
  $$LEGEND_BUFFER := 0;

  !TPU-required:
  $$MESSAGE_WINDOW := CREATE_WINDOW( GV$_screen - 1, 2, OFF );
  GV$_LastWin := $$MESSAGE_WINDOW;
  SET( TEXT, $$MESSAGE_WINDOW, NO_TRANSLATE );
  TPU$X_MESSAGE_BUFFER := F$CreateBuf( "OPRSW", "TPU$X_MESSAGE",
                                       $$MESSAGE_WINDOW, , , "100;;" );
  TPU$X_SHOW_WINDOW := CREATE_WINDOW( 1, GV$_screen - 2, ON );
  SET( PAD, TPU$X_SHOW_WINDOW, OFF );
  SET( STATUS_LINE, TPU$X_SHOW_WINDOW, REVERSE, K$CTRL_Zp );
  TPU$X_SHOW_BUFFER := F$CreateBuf( "IRPS", "TPU$X_SHOW", TPU$X_SHOW_WINDOW );

  !KED utility buffers:
  $$DELETE_BUFFER  := F$CreateBuf( "IRPS", K$Delbuf );  !never mapped
  $$PASTE_BUFFER   := F$CreateBuf( "IRPS", K$Pstbuf );  !never mapped
  $$SCRATCH_BUFFER := F$CreateBuf( "IRPS", K$Scrbuf );  !never mapped

  SET( SUCCESS, OFF);
  SET( MESSAGE_FLAGS, 15 );
  SET( FACILITY_NAME, "KED" );
  SET( PROMPT_AREA, GV$_screen - 1, 1, UNDERLINE );
  SET( BELL, BROADCAST, ON );

  $$1_WINDOW := CREATE_WINDOW( 1, GV$_screen - 2, ON );    !KED user windows
  SET( SCROLLING, $$1_WINDOW, ON, 3, 4, 0 );
  P$Setstat( GV$_statdisp, $$1_WINDOW );
  GV$_CurWin := $$1_WINDOW;

  !Application ---
  ! Logical names KED$RAPT can be undefined or
  ! "KED" for standard editing session, or
  ! "RAPT" for memo-field editing within a RAPT application.
  GV$Application := EDIT( F$TranslateLNM("ked$rapt", "KED"), NOT_IN_PLACE, UPPER );

  !Keypad ---
  ! Logical names KED$KEYBOARD or RMG$KEYBOARD can be undefined or
  ! "PC" (default) for standard PC keyboard remapping, or
  ! "VT" for VT-style keyboards, or
  ! "PCDECW" for DECwindows-style PC keyboard remapping (eXcursion).
  ! Logical names KED$INSERT_MODE or RMG$INSERT_MODE can be undefined or
  ! starting with "OVER" or "INSE" to specify Overstrike or Insert mode
  ! for all subsequent buffer creations (F$CreateBuf).
  IF ( GV$Application = "RAPT" ) THEN
    lnm := F$TranslateLNM( "rmg$keyboard", "PC" );
    iomo := F$TranslateLNM( "rmg$insert_mode", "OVER" );
    IF ( SUBSTR( iomo, 1, 4 ) = "OVER" ) THEN  !Overstrike is default for RAPT
      GV$_insovr := "O";
    ENDIF;
  ELSE lnm := F$TranslateLNM( "ked$keyboard", "PC" );
    iomo := F$TranslateLNM( "ked$insert_mode", "INSERT" );
    IF ( SUBSTR( iomo, 1, 4 ) = "OVER" ) THEN  !Insert is default for KED
      GV$_insovr := "O";
    ENDIF;
  ENDIF;

  GV$Keyboard := EDIT( lnm, NOT_IN_PLACE, UPPER );
  CASE GV$Keyboard FROM "PC" TO "PCDECW"
    ["PC"]: !PC (101-key) keyboard
      P$Keymap( "PC" );
      P$Dmatch( KM$pc0 );
    ["PCDECW"]: !PC, but with DECwindows (eXcursion) variant:
      P$Keymap( "PC" );
      P$Dmatch( KM$pc0 );
      P$eXcursion;
    [OTHERWISE]: ! VT (default, including the old LK250 PC keyboard)
      P$Keymap( "KED" );
      P$Dmatch( KM$ked0 );
    ENDCASE;

  !Journaling Method ---
  ! Logical name KED$JOURNAL can be undefined or
  !   starting with "B" for Buffer Journaling, or
  !   starting with "K" for Keystroke Journaling.
  DefJou := "K";          !Default journalling method
  GV$_JouMeth := SUBSTR( F$TranslateLNM( "ked$journal", DefJou ), 1, 1 );
  GV$_JouFile := NULL;
  GV$_JouRate := 2;   !Buffer journaling rate:
    !  1 = journal-write after ~ 10 keystrokes ...
    ! 10 = journal-write after ~125 keystrokes
 
  inf    := GET_INFO( COMMAND_LINE, "FILE_NAME" );
  outf   := GET_INFO( COMMAND_LINE, "OUTPUT_FILE" );
  exists := F$Exists( inf, fspc );
  wild   := ( INDEX( inf, "*" ) > 0 ) OR ( INDEX( inf, "%" ) > 0 );
  opt    := "EJW" + GV$_insovr; !But not "P": don't make user buffers Permanent!
  IF ( GET_INFO( COMMAND_LINE, "READ_ONLY" ) ) THEN opt := opt + "R"; ENDIF;
  IF ( outf <> NULL ) THEN opt := opt + "M";
  ELSE F$Exists( inf, outf, K$dfspec, "O" );
  ENDIF;
  IF ( NOT exists ) THEN
    MESSAGE( K$xNF_msg, 0, "Input file", inf );
    fspc := inf + K$semicolon;
  ENDIF;

  IF ( GET_INFO( COMMAND_LINE, "RECOVER" ) )
  AND ( GV$_JouMeth = "B" ) THEN
    P$Recover( outf, $$1_WINDOW );  !/RECOVER file (KED P1) from Buffer Journal
  ELSE  !Create "main" buffer for existing or new file
    IF ( wild ) THEN P$Wildfiles( inf, $$1_WINDOW );  !first loaded is "main"
      IF ( GV$_Mbuf <> 0 ) THEN  !"Main buffer" loads LSE
        outf := GET_INFO( F$FindBuf( GV$_Mbuf, "X" ), "FILE_NAME" );
        IF ( GET_INFO( outf, "TYPE" ) <> STRING ) THEN outf := NULL; ENDIF;
      ELSE !no "*.*" files selected for input, so just quit:
        P$Bye( K$NoFiles );
      ENDIF;
    ELSE inf := FILE_SEARCH( NULL );  !reset context
        IF ( exists ) THEN F$CreateBuf( opt, , $$1_WINDOW, fspc, outf );
        ELSE F$CreateBuf( opt, , $$1_WINDOW, NULL, outf );
        ENDIF;
    ENDIF;
  ENDIF;

  IF ( NOT GV$_QuitPend ) THEN
    lnm := FILE_SEARCH( "ked$template" );  !try to use the logical name...
    IF ( lnm = NULL ) THEN                 !else construct "ked$<filetype>"
      lnm := "ked$" + SUBSTR( FILE_PARSE( outf, NULL, NULL, TYPE ),
                               2, LENGTH( outf ) - 1 );
    ENDIF;
    F$LSE_Init( lnm, FALSE );
    POSITION( GET_INFO( COMMAND_LINE, "START_RECORD" ) );
    c0 := GET_INFO( COMMAND_LINE, "START_CHARACTER" );
    IF ( c0 > 1 ) THEN MOVE_HORIZONTAL( c0 - 1 ); ENDIF;
    GV$_LastMark{"«LGM»"} := MARK( NONE );  !1st time set: Last Global Mark
    GV$_LastMark{CURRENT_BUFFER} := MARK( NONE );  !...and Last Buffer Mark
    GV$_marks := " «LGM» «LBM»"
  ENDIF;

  !Application ---
  IF ( GV$Application = "RAPT" ) THEN  !establish RAPT for Rdb Seg-Strings
    P$RAPTsetup;  !Construct special key definitions & legend
  ENDIF;

  !This assignment must be last in TPU$INIT_PROCEDURE...
  !  GV$_Lbuf is a gate (now a STRING):
  GV$_Lbuf := GET_INFO( CURRENT_BUFFER, "NAME" );
  MESSAGE( K$version );
ENDPROCEDURE  !TPU$INIT_PROCEDURE


! === DEFINE KEYS === !

! Ctrl/-key assignments & use:
!    Available for
!    ad-hoc macros:        D     G             N
!      Used by KED:  A B     E F   H I J K L M     P   R     U V W X   Z
!  VMS (precluded):      C         H I       M   O   Q   S T U       Y

PROCEDURE P$Define
LOCAL MenuKM, MenuKML;

! Menu KeyMap, for both default KED and PC mappings:
MenuKM  := CREATE_KEY_MAP( KM$menu );
MenuKML := CREATE_KEY_MAP_LIST( KML$menu, MenuKM );
SET( SELF_INSERT, MenuKML, OFF );
SET( UNDEFINED_KEY, MenuKML, "P$Null" );
SET( SHIFT_KEY, KEY_NAME( PF1, SHIFT_KEY ), MenuKML ); !undefine default
DEFINE_KEY( 'P$Menu', DO, "", MenuKM );
DEFINE_KEY( 'P$Menu', ENTER, "", MenuKM );
DEFINE_KEY( 'P$Menu', RET_KEY, "", MenuKM );
DEFINE_KEY( 'P$Setdir(FORWARD,CURRENT_BUFFER)', KP4, "", MenuKM );
DEFINE_KEY( 'P$Setdir(REVERSE,CURRENT_BUFFER)', KP5, "", MenuKM );
DEFINE_KEY( 'P$MoveW(CURRENT_DIRECTION)', KP1, "", MenuKM );
DEFINE_KEY( 'MOVE_HORIZONTAL(-1)', LEFT, "", MenuKM );
DEFINE_KEY( 'MOVE_HORIZONTAL(1)', RIGHT, "", MenuKM );
DEFINE_KEY( 'P$Rubout', DEL_KEY, "", MenuKM );
DEFINE_KEY( 'COPY_TEXT(" ")', KEY_NAME(" "), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("L")', KEY_NAME("L"), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("L")', KEY_NAME("l"), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("R")', KEY_NAME("R"), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("R")', KEY_NAME("r"), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("T")', KEY_NAME("T"), "", MenuKM );
DEFINE_KEY( 'COPY_TEXT("T")', KEY_NAME("t"), "", MenuKM );


! "PC" KeyMaps:

G$Base := CREATE_KEY_MAP( KM$pc0 );
G$Gold := CREATE_KEY_MAP( KM$pc1 );
G$Buff := CREATE_KEY_MAP( KM$pc2 );
G$Stat := CREATE_KEY_MAP( KM$pc3 );
G$KML  := CREATE_KEY_MAP_LIST( KML$pc, G$Base, G$Gold, G$Buff, G$Stat );
SET( UNDEFINED_KEY, KML$pc, "P$UndKey" );
SET( PRE_KEY_PROCEDURE,  KML$pc, 'P$PreKey' );
SET( POST_KEY_PROCEDURE, KML$pc, 'P$PostKey' );
SET( SHIFT_KEY, KEY_NAME( PF1, SHIFT_KEY ), KML$pc ); !undefine default

! "PC" Mouse support (non-DECwindows) --
! Restricted to industry-standard 2-button mouses:
DEFINE_KEY( 'P$MouseGoto',                      M1DOWN,   "", G$Base );
DEFINE_KEY( 'P$Null',                           M2DOWN,   "", G$Base );
DEFINE_KEY( 'P$MouseSelect',                    M1UP,     "", G$Base );
DEFINE_KEY( 'P$Null',                           M2UP,     "", G$Base );
DEFINE_KEY( 'P$MouseSelect',                    M1DRAG,   "", G$Base );
DEFINE_KEY( 'P$Null',                           M2DRAG,   "", G$Base );
DEFINE_KEY( 'P$Reset',                          M1CLICK,  "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK,  "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK2, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK2, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK3, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK3, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK4, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK4, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK5, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK5, "", G$Base );

! "PC" Base:
DEFINE_KEY( 'P$Arrowkey',                       LEFT, "LEFT", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       RIGHT, "RIGHT", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       DOWN, "DOWN", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       UP, "UP", G$Base );

DEFINE_KEY( 'P$Paste($$PASTE_BUFFER)',          E1, "G_KP6", G$Base );      !Insert
DEFINE_KEY( 'P$Del_C(TRUE)',                    E4, "COMMA", G$Base );      !Delete
DEFINE_KEY( 'P$BOL',                            E2, "BS_KEY", G$Base );     !Home
DEFINE_KEY( 'P$EOL(CURRENT_DIRECTION)',         E5, "CTRL_E_KEY", G$Base ); !End
DEFINE_KEY( 'P$Screen(REVERSE)',                E3, "E3", G$Base );         !Page Up
DEFINE_KEY( 'P$Screen(FORWARD)',                E6, "E6", G$Base );         !Page Down

DEFINE_KEY( 'P$LSE_template(NULL)',             F7, "F14", G$Base );
! Help:
DEFINE_KEY( 'P$Keypad_Help; P$0',               F8, "Keypad_Diagram", G$Base );
DEFINE_KEY( 'P$FindReplaceNext',                F9, "F17", G$Base );

DEFINE_KEY( 'P$GotoMark("«LGM»")',              F10, "F18", G$Base );
DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', F11, "F19", G$Base );
DEFINE_KEY( 'GV$_flipR := 0; '
            + 'P$STarget(F$Bump,K$chevrons);',  F12, "F20", G$Base );

! The next two mappings are redundant, but useful for some "exceptional"
! PC terminal emulator keymaps -- logical KED$KEYBOARD = "PC":
DEFINE_KEY( 'P$Keypad_Help; P$0',               HELP, "Keypad_Diagram", G$Base );
DEFINE_KEY( 'P$Menu',                           DO, "DO_KEY", G$Base );

DEFINE_KEY( 'P$GoldKey',                        PF1, "PF1", G$Base ); !*<Gold>*
DEFINE_KEY( 'P$LSE_template(NULL)',             PF2, "PF2", G$Base ); ! PCs don't have <Do> or <F14>
DEFINE_KEY( 'P$STarget(F$Bump,GV$_srchtar)',    PF3, "PF3", G$Base );
DEFINE_KEY( 'P$Del_L',                          PF4, "PF4", G$Base );
DEFINE_KEY( 'P$Page(CURRENT_DIRECTION)',        KP7, "KP7", G$Base );
DEFINE_KEY( 'P$Paragraph(CURRENT_DIRECTION)',   KP8, "KP8", G$Base );
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,0)',       KP9, "KP9", G$Base );
! Following RAPT's lead, map <KP-> to same function as <KP,>:
DEFINE_KEY( 'P$Del_C(FALSE)',                   MINUS, "COMMA", G$Base );
DEFINE_KEY( 'P$SetDir(FORWARD,CURRENT_BUFFER)', KP4, "KP4", G$Base );
DEFINE_KEY( 'P$SetDir(REVERSE,CURRENT_BUFFER)', KP5, "KP5", G$Base );
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,1)',       KP6, "KP6", G$Base );
DEFINE_KEY( 'P$Del_C(FALSE)',                   COMMA, "COMMA", G$Base );
DEFINE_KEY( 'P$MoveW(CURRENT_DIRECTION)',       KP1, "KP1", G$Base );
DEFINE_KEY( 'P$EOL(CURRENT_DIRECTION)',         KP2, "KP2", G$Base );
DEFINE_KEY( 'P$MoveC(CURRENT_DIRECTION)',       KP3, "KP3", G$Base );
! see P$RET_ENTER_keys for definition of ENTER/km
DEFINE_KEY( 'P$MoveL(CURRENT_DIRECTION)',       KP0, "KP0", G$Base );
DEFINE_KEY( 'P$Select',                         PERIOD, "PERIOD", G$Base );

! "PC" Base: CTRL/letter keys
DEFINE_KEY( 'P$Modes',                          CTRL_A_KEY, "CTRL_A_KEY", G$Base );
DEFINE_KEY( 'P$EOL(CURRENT_DIRECTION)',         CTRL_E_KEY, "CTRL_E_KEY", G$Base );
DEFINE_KEY( 'P$BOL',                            BS_KEY, "BS_KEY", G$Base );
DEFINE_KEY( 'P$Tab',                            TAB_KEY, "TAB_KEY", G$Base );
DEFINE_KEY( 'P$Del_BOW',                        LF_KEY, "LF_KEY", G$Base );
DEFINE_KEY( 'P$Del_EOW',                        CTRL_K_KEY, "MINUS", G$Base );
DEFINE_KEY( 'COPY_TEXT(K$ff)',                  CTRL_L_KEY, "CTRL_L_KEY", G$Base );
! defines both RETURN and ENTER keys:
P$RET_ENTER_keys( G$Base );
DEFINE_KEY( 'P$GotoMark("«LBM»")',              CTRL_P_KEY, "CTRL_P_KEY", G$Base );
DEFINE_KEY( 'P$Learn',                          CTRL_R_KEY, "CTRL_R_KEY", G$Base );
DEFINE_KEY( 'P$Del_BOL',                        CTRL_U_KEY, "CTRL_U_KEY", G$Base );
! Ctrl/V now works like Windows/PC:
DEFINE_KEY( 'P$Paste($$PASTE_BUFFER)',          CTRL_V_KEY, "G_KP6", G$Base );
DEFINE_KEY( 'REFRESH',                          CTRL_W_KEY, "CTRL_W_KEY", G$Base );
DEFINE_KEY( 'P$CTRL_Z_key',                     CTRL_Z_KEY, "CTRL_Z_KEY", G$Base );
DEFINE_KEY( 'P$Rubout',                         DEL_KEY, "DEL_KEY", G$Base );

! "PC" Gold:
DEFINE_KEY( 'P$ShiftWin(NULL,REVERSE); P$0',    LEFT, "G_LEFT", G$Gold );
DEFINE_KEY( 'P$ShiftWin(NULL,FORWARD); P$0',    RIGHT, "G_RIGHT", G$Gold );
DEFINE_KEY( 'P$SwapWin(-1); P$0',               UP, "G_UP", G$Gold );
DEFINE_KEY( 'P$SwapWin(+1); P$0',               DOWN, "G_DOWN", G$Gold );

DEFINE_KEY( 'P$Indent(TRUE); P$0',              E1, "G_E1", G$Gold );  !Insert
DEFINE_KEY( 'P$Indent(FALSE); P$0',             E4, "G_E4", G$Gold );  !Delete
DEFINE_KEY( 'P$SearchForSR; P$0',               E2, "G_E2", G$Gold );  !Home
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,2); P$0',  E5, "G_E5", G$Gold );  !End (also <Gold><Ctrl/F>)
DEFINE_KEY( 'P$SetDir(REVERSE,CURRENT_BUFFER); '
            + 'SCROLL(CURRENT_WINDOW); P$0',    E3, "G_E3", G$Gold );  !Page Up
DEFINE_KEY( 'P$SetDir(FORWARD,CURRENT_BUFFER); '
            + 'SCROLL(CURRENT_WINDOW); P$0',    E6, "G_E6", G$Gold );  !Page Down

DEFINE_KEY( 'P$LSE_remove; P$0',                F7, "G_F14", G$Gold );
! HELP is defined in PC_MAP0
DEFINE_KEY( 'P$FindReplace(TRUE); P$0',         F9, "G_F17", G$Gold );
DEFINE_KEY( 'P$Mark("«LGM»"); P$0',             F10, "G_F18", G$Gold );
DEFINE_KEY( 'P$CenterL; P$0',                   F11, "G_F19", G$Gold );
DEFINE_KEY( 'P$Insert(K$chevrons); P$0',        F12, "G_F20", G$Gold );
! PF1 & PF2 are defined only in PC_MAP0
DEFINE_KEY( 'P$Search; P$0',                    PF3, "G_PF3", G$Gold );
DEFINE_KEY( 'P$Undel_L; P$0',                   PF4, "G_PF4", G$Gold );
DEFINE_KEY( 'P$Command; P$0',                   KP7, "G_KP7", G$Gold );
DEFINE_KEY( 'P$Fill; P$0',                      KP8, "G_KP8", G$Gold );
DEFINE_KEY( 'P$Replace; P$0',                   KP9, "G_KP9", G$Gold );
! Following RAPT's lead, map <Gold><KP-> to same function as <Gold><KP,>:
DEFINE_KEY( 'P$Undel_C; P$0',                   MINUS, "G_COMMA", G$Gold );
DEFINE_KEY( 'POSITION(END_OF(CURRENT_BUFFER));'
            + ' GV$_flipR := 0; P$0',           KP4, "G_KP4", G$Gold );
DEFINE_KEY( 'POSITION(BEGINNING_OF(CURRENT_BUFFER));'
            + ' GV$_flipR := 0; P$0',           KP5, "G_KP5", G$Gold );
DEFINE_KEY( 'P$Paste($$PASTE_BUFFER); P$0',     KP6, "G_KP6", G$Gold );
DEFINE_KEY( 'P$Undel_C; P$0',                   COMMA, "G_COMMA", G$Gold );
DEFINE_KEY( 'P$Ccase; P$0',                     KP1, "G_KP1", G$Gold );
DEFINE_KEY( 'P$Del_EOL; P$0',                   KP2, "G_KP2", G$Gold );
DEFINE_KEY( 'P$Code; P$0',                      KP3, "G_KP3", G$Gold );
DEFINE_KEY( 'P$Substitute; P$0',                ENTER, "G_ENTER", G$Gold );
DEFINE_KEY( 'SPLIT_LINE; MOVE_HORIZONTAL(-1); P$0',
                                                KP0, "G_KP0", G$Gold );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "G_PERIOD", G$Gold );

! "PC" Gold: GOLD-CTRL/letter keys
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,2); P$0',  CTRL_F_KEY, "G_CTRL_F_KEY", G$Gold );  !also <Gold><Select>
DEFINE_KEY( 'IF (GET_INFO(CURRENT_BUFFER,"NAME") = K$DCLbuf)'
            + ' THEN P$DCL; ELSE P$RET_key; ENDIF; P$0;',
                                                RET_KEY, "G_RET_KEY", G$Gold );
!CALLABLE_TPU requires keymap reset:
!(retired): DEFINE_KEY( 'P$0; P$Bye(K$Attach)',         CTRL_A_KEY, "G_CTRL_A_KEY", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_BOLD,'
                     + 'K$ANSI_Rend); P$0', CTRL_B_KEY, "", G$Gold );
DEFINE_KEY( 'P$Undel_W; P$0',               CTRL_J_KEY, "G_MINUS", G$Gold );
DEFINE_KEY( 'P$Undel_W; P$0',               CTRL_K_KEY, "G_MINUS", G$Gold );
DEFINE_KEY( 'P$Mark("«LBM»"); P$0',         CTRL_P_KEY, "CTRL_P_KEY", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_UNDER,'
                     + 'K$ANSI_Rend); P$0', CTRL_U_KEY, "", G$Gold );
DEFINE_KEY( 'P$0; P$Bye(K$Exit)',           CTRL_Z_KEY, "G_CTRL_Z_KEY", G$Gold );

! "PC" Buff:
DEFINE_KEY( 'P$ShiftWin("M",REVERSE); P$0',     LEFT, "B_LEFT", G$Buff );
DEFINE_KEY( 'P$ShiftWin("M",FORWARD); P$0',     RIGHT, "B_RIGHT", G$Buff );
DEFINE_KEY( 'P$SwapWin(-1); P$0',               UP, "B_UP", G$Buff );
DEFINE_KEY( 'P$SwapWin(+1); P$0',               DOWN, "B_DOWN", G$Buff );

DEFINE_KEY( 'P$SetRuler(GV$_ruler); P$0',       E1, "B_E1", G$Buff );  !Insert
DEFINE_KEY( 'P$SwapMsg(FALSE); P$0',            E4, "B_E4", G$Buff );  !Delete
DEFINE_KEY( 'P$SpecSearch; P$0',                E2, "B_E2", G$Buff );  !Home
DEFINE_KEY( 'P$MapN; P$0',                      E5, "B_E5", G$Buff );  !End
DEFINE_KEY( 'P$Cycle(REVERSE); P$0',            E3, "B_E3", G$Buff );  !Page Up
DEFINE_KEY( 'P$Cycle(FORWARD); P$0',            E6, "B_E6", G$Buff );  !Page Down

! HELP is defined in PC_MAP0
DEFINE_KEY( 'P$Compiler; P$0',                  F6, "B_DO_KEY", G$Buff );
! The next mapping is redundant, but useful for
! some "exceptional" PC terminal emulator keymaps --
DEFINE_KEY( 'P$Compiler; P$0',                  DO, "B_DO_KEY", G$Buff );
DEFINE_KEY( 'F$LSE_load; P$0',                  F7, "B_F14", G$Buff );
DEFINE_KEY( 'P$FindReplace(FALSE); P$0',        F9, "B_F17", G$Buff );
DEFINE_KEY( 'P$GotoMark(NULL); P$0',            F10, "B_F18", G$Buff );
DEFINE_KEY( 'P$RW; P$0',                        F11, "B_F19", G$Buff );
DEFINE_KEY( 'P$GotoAbsL; P$0',                  F12, "B_F20", G$Buff );
! PF1  & PF2 are defined only in PC_MAP0
DEFINE_KEY( 'P$Cycle(FORWARD); P$0',            PF3, "B_PF3", G$Buff );
DEFINE_KEY( 'P$Erase; P$0',                     PF4, "B_PF4", G$Buff );
DEFINE_KEY( 'P$FindBuf; P$0',                   KP7, "B_KP7", G$Buff );
DEFINE_KEY( 'P$Checkpoint; P$0',                KP8, "B_KP8", G$Buff );
DEFINE_KEY( 'P$Input(NULL); P$0',               KP9, "B_KP9", G$Buff );
DEFINE_KEY( 'P$Surround(K$so,K$si); P$0',       MINUS, "B_MINUS", G$Buff );
DEFINE_KEY( 'P$Surround(K$so,K$si); P$0',       CTRL_K_KEY, "B_MINUS", G$Buff );
DEFINE_KEY( 'P$Last(GV$_MBuf); P$0',            KP4, "B_KP4", G$Buff );
DEFINE_KEY( 'P$Last(GV$_LBuf); P$0',            KP5, "B_KP5", G$Buff );
DEFINE_KEY( 'F$Output(NULL); P$0',              KP6, "B_KP6", G$Buff );
DEFINE_KEY( 'P$Transl; P$0',                    COMMA, "B_COMMA", G$Buff );
DEFINE_KEY( 'P$ScrW; P$0',                      KP1, "B_KP1", G$Buff );
DEFINE_KEY( 'P$MapWin(NULL); P$0',              KP2, "B_KP2", G$Buff );
DEFINE_KEY( 'P$RenameBuf(CURRENT_BUFFER); P$0', KP3, "B_KP3", G$Buff );
DEFINE_KEY( 'P$Menu; P$0',                      ENTER, "B_ENTER", G$Buff );
DEFINE_KEY( 'P$DCL; P$0',                       KP0, "B_KP0", G$Buff );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "B_PERIOD", G$Buff );

! "PC" Buff: BUFF-CTRL/letter keys
DEFINE_KEY( 'P$FAO_Directives; P$0',  CTRL_F_KEY, "B_CTRL_F_KEY", G$Buff );

! "PC" Stat:
DEFINE_KEY( 'P$FVD; P$0',                       E1, "S_E1", G$Stat );  !Insert
!DEFINE_KEY( '«»; P$0',                          E4, "S_E4", G$Stat );  !Delete (unused)
DEFINE_KEY( 'P$CondCode; P$0',                  E2, "S_E2", G$Stat );  !Home
!DEFINE_KEY( 'P$Attach; P$0',                    E5, "S_E5", G$Stat );  !End (retired)
DEFINE_KEY( 'P$Pairs; P$0',                     E3, "S_E3", G$Stat );  !Page Up (unlabled on key-map)
DEFINE_KEY( 'P$GotoPairs; P$0',                 E6, "S_E6", G$Stat );  !Page Down (unlabled on key-map)

! HELP is defined in PC_MAP0
DEFINE_KEY( 'P$Insert(GV$_delstr); P$0',        F9, "S_F17", G$Stat );
DEFINE_KEY( 'P$Mark(NULL); P$0',                F10, "S_F18", G$Stat );
! PF1  & PF2 are defined only in PC_MAP0
DEFINE_KEY( 'P$Lines_in_SR; P$0',               PF4, "S_PF4", G$Stat );
DEFINE_KEY( 'GV$_Mbuf := GET_INFO(CURRENT_BUFFER,"NAME"); P$0',
                                                KP4, "S_KP4", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL line!%S on this page",'
            + 'F$L_Count)); P$0',               KP7, "S_KP7", G$Stat );
DEFINE_KEY( 'P$Debug; P$0',                     KP8, "S_KP8", G$Stat );
DEFINE_KEY( 'P$Bind; P$0',                      KP9, "S_KP9", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL word!%S in SR",'
            + 'F$Words_in_SR)); P$0',           MINUS, "S_MINUS", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL word!%S in SR",'
            + 'F$Words_in_SR)); P$0',           CTRL_K_KEY, "S_MINUS", G$Stat );
DEFINE_KEY( 'P$TPU_compile; P$0',               KP5, "S_KP5", G$Stat );
DEFINE_KEY( 'P$DropBuffer; P$0',                KP6, "S_KP6", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL character!%S in SR",F$Char_in_SR)); P$0',
                                                COMMA, "S_COMMA", G$Stat );
DEFINE_KEY( 'P$Count_L; P$0',                   KP1, "S_KP1", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("horizontal position is !SL (unshifted)",'
            + 'GET_INFO(CURRENT_BUFFER,"OFFSET_COLUMN"))); P$0',
                                                KP2, "S_KP2", G$Stat );
DEFINE_KEY( 'P$Current_C; P$0',                 KP3, "S_KP3", G$Stat );
DEFINE_KEY( 'P$QuoteChar; P$0',                 ENTER, "S_ENTER", G$Stat );
DEFINE_KEY( 'SPAWN(F$Prompt("Subprocess command",'
            + 'NULL,"U",FALSE),OFF); P$0',      KP0, "S_KP0", G$Stat );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "S_PERIOD", G$Stat );

! *** Undefined "PC" Function Keys ***
DEFINE_KEY( 'P$UndKey', F1, "", G$Base );  !F1, F2, F3, F4, F5, F6 seem to never
DEFINE_KEY( 'P$UndKey', F2, "", G$Base );  ! work on most PC terminal emulators
DEFINE_KEY( 'P$UndKey', F3, "", G$Base );  ! ...so don't even try!
DEFINE_KEY( 'P$UndKey', F4, "", G$Base );
DEFINE_KEY( 'P$UndKey', F5, "", G$Base );
DEFINE_KEY( 'P$UndKey', F6, "", G$Base );
DEFINE_KEY( 'P$UndKey', F14, "", G$Base );
DEFINE_KEY( 'P$UndKey', F17, "", G$Base );
DEFINE_KEY( 'P$UndKey', F18, "", G$Base );
DEFINE_KEY( 'P$UndKey', F19, "", G$Base );
DEFINE_KEY( 'P$UndKey', F20, "", G$Base );
!!DEFINE_KEY( 'P$UndKey', PF2, "", G$Base );

DEFINE_KEY( 'P$UndKey', F1, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F2, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F3, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F4, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F5, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F13, "", G$Gold );
DEFINE_KEY( 'P$UndKey', DO, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F17, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F18, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F19, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F20, "", G$Gold );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Gold );

DEFINE_KEY( 'P$UndKey', F1, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F2, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F3, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F4, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F5, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F13, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F17, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F18, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F19, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F20, "", G$Buff );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Buff );

DEFINE_KEY( 'P$UndKey', LEFT,  "", G$Stat );
DEFINE_KEY( 'P$UndKey', RIGHT, "", G$Stat );
DEFINE_KEY( 'P$UndKey', UP,    "", G$Stat );
DEFINE_KEY( 'P$UndKey', DOWN,  "", G$Stat );
DEFINE_KEY( 'P$UndKey', E4, "", G$Stat );
DEFINE_KEY( 'P$UndKey', E5, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F1, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F2, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F3, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F4, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F5, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F6, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F7, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F11, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F12, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F13, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F14, "", G$Stat );
DEFINE_KEY( 'P$UndKey', DO, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F17, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F18, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F19, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F20, "", G$Stat );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Stat );
DEFINE_KEY( 'P$UndKey', PF3, "", G$Stat );


! "VT" (default KED) KeyMaps (done last):

G$Base := CREATE_KEY_MAP( KM$ked0 );
G$Gold := CREATE_KEY_MAP( KM$ked1 );
G$Buff := CREATE_KEY_MAP( KM$ked2 );
G$Stat := CREATE_KEY_MAP( KM$ked3 );
G$KML  := CREATE_KEY_MAP_LIST( KML$ked, G$Base, G$Gold, G$Buff, G$Stat );
SET( UNDEFINED_KEY, KML$ked, "P$UndKey" );
SET( PRE_KEY_PROCEDURE,  KML$ked, 'P$PreKey' );
SET( POST_KEY_PROCEDURE, KML$ked, 'P$PostKey' );
SET( SHIFT_KEY, KEY_NAME( PF1, SHIFT_KEY ), KML$ked ); !undefine default

! "VT" Mouse support (non-DECwindows) --
! Restricted to industry-standard 2-button mouses:
DEFINE_KEY( 'P$MouseGoto',                      M1DOWN,   "", G$Base );
DEFINE_KEY( 'P$Null',                           M2DOWN,   "", G$Base );
DEFINE_KEY( 'P$MouseSelect',                    M1UP,     "", G$Base );
DEFINE_KEY( 'P$Null',                           M2UP,     "", G$Base );
DEFINE_KEY( 'P$MouseSelect',                    M1DRAG,   "", G$Base );
DEFINE_KEY( 'P$Null',                           M2DRAG,   "", G$Base );
DEFINE_KEY( 'P$Reset',                          M1CLICK,  "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK,  "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK2, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK2, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK3, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK3, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK4, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK4, "", G$Base );
DEFINE_KEY( 'P$Null',                           M1CLICK5, "", G$Base );
DEFINE_KEY( 'P$Null',                           M2CLICK5, "", G$Base );

! "VT" Base:
DEFINE_KEY( 'P$Arrowkey',                       LEFT, "LEFT", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       RIGHT, "RIGHT", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       DOWN, "DOWN", G$Base );
DEFINE_KEY( 'P$Arrowkey',                       UP, "UP", G$Base );
DEFINE_KEY( 'P$STarget(F$Bump,GV$_srchtar)',    E1, "E1", G$Base );    !Find
DEFINE_KEY( 'P$Paste($$PASTE_BUFFER)',          E2, "G_KP6", G$Base ); !Insert Here
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,1)',       E3, "E3", G$Base ); !Remove
DEFINE_KEY( 'P$Select',                         E4, "E4", G$Base ); !Select
DEFINE_KEY( 'P$Screen(REVERSE)',                E5, "E5", G$Base ); !Prev Screen
DEFINE_KEY( 'P$Screen(FORWARD)',                E6, "E6", G$Base ); !Next Screen

DEFINE_KEY( 'P$0; P$Bye(K$Quit);',              F8, "F8", G$Base );
DEFINE_KEY( 'P$GotoMark("«LGM»")',              F10, "F10", G$Base );
DEFINE_KEY( 'COPY_TEXT(ASCII(27))',             F11, "F11", G$Base );
DEFINE_KEY( 'P$BOL',                            F12, "F12", G$Base );
DEFINE_KEY( 'P$Del_BOW',                        F13, "F13", G$Base );
DEFINE_KEY( 'P$LSE_template(NULL)',             F14, "F14", G$Base );
DEFINE_KEY( 'P$Keypad_Help; P$0',               HELP, "Keypad_Diagram", G$Base );
DEFINE_KEY( 'P$Menu',                           DO, "DO_KEY", G$Base );
DEFINE_KEY( 'P$FindReplaceNext',                F17, "F17", G$Base );
DEFINE_KEY( 'P$GotoMark("«LGM»")',              F18, "F18", G$Base );
DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', F19, "F19", G$Base );
DEFINE_KEY( 'GV$_flipR := 0; '
            + 'P$STarget(F$Bump,K$chevrons);',  F20, "F20", G$Base );

DEFINE_KEY( 'P$GoldKey',                        PF1, "PF1", G$Base ); !*<Gold>*
DEFINE_KEY( 'P$STarget(F$Bump,GV$_srchtar)',    PF3, "PF3", G$Base );
DEFINE_KEY( 'P$Del_L',                          PF4, "PF4", G$Base );
DEFINE_KEY( 'P$Page(CURRENT_DIRECTION)',        KP7, "KP7", G$Base );
DEFINE_KEY( 'P$Paragraph(CURRENT_DIRECTION)',   KP8, "KP8", G$Base );
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,0)',       KP9, "KP9", G$Base );
DEFINE_KEY( 'P$Del_EOW',                        MINUS, "MINUS", G$Base );
DEFINE_KEY( 'P$SetDir(FORWARD,CURRENT_BUFFER)', KP4, "KP4", G$Base );
DEFINE_KEY( 'P$SetDir(REVERSE,CURRENT_BUFFER)', KP5, "KP5", G$Base );
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,1)',       KP6, "KP6", G$Base );
DEFINE_KEY( 'P$Del_C(FALSE)',                   COMMA, "COMMA", G$Base );
DEFINE_KEY( 'P$MoveW(CURRENT_DIRECTION)',       KP1, "KP1", G$Base );
DEFINE_KEY( 'P$EOL(CURRENT_DIRECTION)',         KP2, "KP2", G$Base );
DEFINE_KEY( 'P$MoveC(CURRENT_DIRECTION)',       KP3, "KP3", G$Base );
! see P$RET_ENTER_keys for definition of ENTER/km
DEFINE_KEY( 'P$MoveL(CURRENT_DIRECTION)',       KP0, "KP0", G$Base );
DEFINE_KEY( 'P$Select',                         PERIOD, "PERIOD", G$Base );

! "VT" Base: CTRL/letter keys
DEFINE_KEY( 'P$Modes',                          CTRL_A_KEY, "CTRL_A_KEY", G$Base );
DEFINE_KEY( 'P$EOL(CURRENT_DIRECTION)',         CTRL_E_KEY, "CTRL_E_KEY", G$Base );
DEFINE_KEY( 'P$BOL',                            BS_KEY, "BS_KEY", G$Base );
DEFINE_KEY( 'P$Tab',                            TAB_KEY, "TAB_KEY", G$Base );
DEFINE_KEY( 'P$Del_BOW',                        LF_KEY, "LF_KEY", G$Base );
DEFINE_KEY( 'P$Del_EOW',                        CTRL_K_KEY, "MINUS", G$Base );
DEFINE_KEY( 'COPY_TEXT(K$ff)',                  CTRL_L_KEY, "CTRL_L_KEY", G$Base );
! defines both RETURN and ENTER keys:
P$RET_ENTER_keys( G$Base );
DEFINE_KEY( 'P$GotoMark("«LBM»")',              CTRL_P_KEY, "CTRL_P_KEY", G$Base );
DEFINE_KEY( 'P$Learn',                          CTRL_R_KEY, "CTRL_R_KEY", G$Base );
DEFINE_KEY( 'P$Del_BOL',                        CTRL_U_KEY, "CTRL_U_KEY", G$Base );
! Ctrl/V now works like Windows/PC:
DEFINE_KEY( 'P$Paste($$PASTE_BUFFER)',          CTRL_V_KEY, "G_KP6", G$Base );
DEFINE_KEY( 'REFRESH',                          CTRL_W_KEY, "CTRL_W_KEY", G$Base );
DEFINE_KEY( 'P$CTRL_Z_key',                     CTRL_Z_KEY, "CTRL_Z_KEY", G$Base );
DEFINE_KEY( 'P$Rubout',                         DEL_KEY, "DEL_KEY", G$Base );

! "VT" Gold:
DEFINE_KEY( 'P$ShiftWin(NULL,REVERSE); P$0',    LEFT, "G_LEFT", G$Gold );
DEFINE_KEY( 'P$ShiftWin(NULL,FORWARD); P$0',    RIGHT, "G_RIGHT", G$Gold );
DEFINE_KEY( 'P$SwapWin(-1); P$0',               UP, "G_UP", G$Gold );
DEFINE_KEY( 'P$SwapWin(+1); P$0',               DOWN, "G_DOWN", G$Gold );
DEFINE_KEY( 'P$SearchForSR; P$0',               E1, "G_E1", G$Gold );
DEFINE_KEY( 'P$Indent(TRUE); P$0',              E2, "G_E2", G$Gold );
DEFINE_KEY( 'P$Indent(FALSE); P$0',             E3, "G_E3", G$Gold );
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,2); P$0',  E4, "G_E4", G$Gold ); !also <Gold><Ctrl/F>
DEFINE_KEY( 'P$SetDir(REVERSE,CURRENT_BUFFER); '
            + 'SCROLL(CURRENT_WINDOW); P$0',    E5, "G_E5", G$Gold );
DEFINE_KEY( 'P$SetDir(FORWARD,CURRENT_BUFFER); '
            + 'SCROLL(CURRENT_WINDOW); P$0',    E6, "G_E6", G$Gold );
DEFINE_KEY( 'COPY_TEXT(ASCII(155)); P$0',       F11, "G_F11", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_BOLD,'
                     + 'K$ANSI_Rend); P$0',     F12, "", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_UNDER,'
                     + 'K$ANSI_Rend); P$0',     F13, "", G$Gold );
DEFINE_KEY( 'P$LSE_remove; P$0',                F14, "G_F14", G$Gold );
! HELP is defined in KED_MAP0
DEFINE_KEY( 'P$FindReplace(TRUE); P$0',         F17, "G_F17", G$Gold );
DEFINE_KEY( 'P$Mark("«LGM»"); P$0',             F18, "G_F18", G$Gold );
DEFINE_KEY( 'P$CenterL; P$0',                   F19, "G_F19", G$Gold );
DEFINE_KEY( 'P$Insert(K$chevrons); P$0',        F20, "G_F20", G$Gold );
! PF1 & PF2 are defined only in KED_MAP0
DEFINE_KEY( 'P$Search; P$0',                    PF3, "G_PF3", G$Gold );
DEFINE_KEY( 'P$Undel_L; P$0',                   PF4, "G_PF4", G$Gold );
DEFINE_KEY( 'P$Command; P$0',                   KP7, "G_KP7", G$Gold );
DEFINE_KEY( 'P$Fill; P$0',                      KP8, "G_KP8", G$Gold );
DEFINE_KEY( 'P$Replace; P$0',                   KP9, "G_KP9", G$Gold );
DEFINE_KEY( 'P$Undel_W; P$0',                   MINUS, "G_MINUS", G$Gold );
DEFINE_KEY( 'POSITION(END_OF(CURRENT_BUFFER));'
            + ' GV$_flipR := 0; P$0',           KP4, "G_KP4", G$Gold );
DEFINE_KEY( 'POSITION(BEGINNING_OF(CURRENT_BUFFER));'
            + ' GV$_flipR := 0; P$0',           KP5, "G_KP5", G$Gold );
DEFINE_KEY( 'P$Paste($$PASTE_BUFFER); P$0',     KP6, "G_KP6", G$Gold );
DEFINE_KEY( 'P$Undel_C; P$0',                   COMMA, "G_COMMA", G$Gold );
DEFINE_KEY( 'P$Ccase; P$0',                     KP1, "G_KP1", G$Gold );
DEFINE_KEY( 'P$Del_EOL; P$0',                   KP2, "G_KP2", G$Gold );
DEFINE_KEY( 'P$Code; P$0',                      KP3, "G_KP3", G$Gold );
DEFINE_KEY( 'P$Substitute; P$0',                ENTER, "G_ENTER", G$Gold );
DEFINE_KEY( 'SPLIT_LINE; MOVE_HORIZONTAL(-1); P$0',
                                                KP0, "G_KP0", G$Gold );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "G_PERIOD", G$Gold );

! "VT" Gold: GOLD-CTRL/letter keys
DEFINE_KEY( 'P$Append($$PASTE_BUFFER,2); P$0',  CTRL_F_KEY, "G_CTRL_F_KEY", G$Gold );  !also <Gold><Select>
DEFINE_KEY( 'IF (GET_INFO(CURRENT_BUFFER,"NAME") = K$DCLbuf)'
            + ' THEN P$DCL; ELSE P$RET_key; ENDIF; P$0;',
                                                RET_KEY, "G_RET_KEY", G$Gold );
!CALLABLE_TPU requires keymap reset:
!(retired): DEFINE_KEY( 'P$0; P$Bye(K$Attach)',         CTRL_A_KEY, "G_CTRL_A_KEY", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_BOLD,'
                     + 'K$ANSI_Rend); P$0', CTRL_B_KEY, "", G$Gold );
DEFINE_KEY( 'P$Undel_W; P$0',               CTRL_J_KEY, "G_MINUS", G$Gold );
DEFINE_KEY( 'P$Undel_W; P$0',               CTRL_K_KEY, "G_MINUS", G$Gold );
DEFINE_KEY( 'P$Mark("«LBM»"); P$0',         CTRL_P_KEY, "CTRL_P_KEY", G$Gold );
DEFINE_KEY( 'P$Surround(K$ANSI_Str_UNDER,'
                     + 'K$ANSI_Rend); P$0', CTRL_U_KEY, "", G$Gold );
DEFINE_KEY( 'P$0; P$Bye(K$Exit)',           CTRL_Z_KEY, "G_CTRL_Z_KEY", G$Gold );

! "VT" Buff:
DEFINE_KEY( 'P$ShiftWin("M",REVERSE); P$0',     LEFT, "B_LEFT", G$Buff );
DEFINE_KEY( 'P$ShiftWin("M",FORWARD); P$0',     RIGHT, "B_RIGHT", G$Buff );
DEFINE_KEY( 'P$SwapWin(-1); P$0',               UP, "B_UP", G$Buff );
DEFINE_KEY( 'P$SwapWin(+1); P$0',               DOWN, "B_DOWN", G$Buff );
DEFINE_KEY( 'P$SpecSearch; P$0',                E1, "B_E1", G$Buff );
DEFINE_KEY( 'P$SetRuler(GV$_ruler); P$0',       E2, "B_E2", G$Buff );
DEFINE_KEY( 'P$SwapMsg(FALSE); P$0',            E3, "B_E3", G$Buff );
DEFINE_KEY( 'P$MapN; P$0',                      E4, "B_E4", G$Buff );
DEFINE_KEY( 'P$Cycle(REVERSE); P$0',            E5, "B_E5", G$Buff );
DEFINE_KEY( 'P$Cycle(FORWARD); P$0',            E6, "B_E6", G$Buff );
DEFINE_KEY( 'F$LSE_load; P$0',                  F14, "B_F14", G$Buff );
! HELP is defined in KED_MAP0
DEFINE_KEY( 'P$Compiler; P$0',                  DO, "B_DO_KEY", G$Buff );
DEFINE_KEY( 'P$FindReplace(FALSE); P$0',        F17, "B_F17", G$Buff );
DEFINE_KEY( 'P$GotoMark(NULL); P$0',            F18, "B_F18", G$Buff );
DEFINE_KEY( 'P$RW; P$0',                        F19, "B_F19", G$Buff );
DEFINE_KEY( 'P$GotoAbsL; P$0',                  F20, "B_F20", G$Buff );
! PF1  & PF2 are defined only in KED_MAP0
DEFINE_KEY( 'P$Cycle(FORWARD); P$0',            PF3, "B_PF3", G$Buff );
DEFINE_KEY( 'P$Erase; P$0',                     PF4, "B_PF4", G$Buff );
DEFINE_KEY( 'P$FindBuf; P$0',                   KP7, "B_KP7", G$Buff );
DEFINE_KEY( 'P$Checkpoint; P$0',                KP8, "B_KP8", G$Buff );
DEFINE_KEY( 'P$Input(NULL); P$0',               KP9, "B_KP9", G$Buff );
DEFINE_KEY( 'P$Surround(K$so,K$si); P$0',       MINUS, "B_MINUS", G$Buff );
DEFINE_KEY( 'P$Surround(K$so,K$si); P$0',       CTRL_K_KEY, "B_MINUS", G$Buff );
DEFINE_KEY( 'P$Last(GV$_MBuf); P$0',            KP4, "B_KP4", G$Buff );
DEFINE_KEY( 'P$Last(GV$_LBuf); P$0',            KP5, "B_KP5", G$Buff );
DEFINE_KEY( 'F$Output(NULL); P$0',              KP6, "B_KP6", G$Buff );
DEFINE_KEY( 'P$transl; P$0',                    COMMA, "B_COMMA", G$Buff );
DEFINE_KEY( 'P$ScrW; P$0',                      KP1, "B_KP1", G$Buff );
DEFINE_KEY( 'P$MapWin(NULL); P$0',              KP2, "B_KP2", G$Buff );
DEFINE_KEY( 'P$RenameBuf(CURRENT_BUFFER); P$0', KP3, "B_KP3", G$Buff );
DEFINE_KEY( 'P$Menu; P$0',                      ENTER, "B_ENTER", G$Buff );
DEFINE_KEY( 'P$DCL; P$0',                       KP0, "B_KP0", G$Buff );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "B_PERIOD", G$Buff );

! "VT" Buff: BUFF-CTRL/letter keys
DEFINE_KEY( 'P$FAO_Directives; P$0',  CTRL_F_KEY, "B_CTRL_F_KEY", G$Buff );

! "VT" Stat:
DEFINE_KEY( 'P$CondCode; P$0',                  E1, "S_E1", G$Stat );
DEFINE_KEY( 'P$FVD; P$0',                       E2, "S_E2", G$Stat );
DEFINE_KEY( 'P$Pairs; P$0',                     E4, "S_E4", G$Stat );
!(retired): DEFINE_KEY( 'P$Attach; P$0',                    E5, "S_E5", G$Stat );
DEFINE_KEY( 'P$GotoPairs; P$0',                 E6, "S_E6", G$Stat );
! HELP is defined in KED_MAP0
DEFINE_KEY( 'P$Insert(GV$_delstr); P$0',        F17, "S_F17", G$Stat );
DEFINE_KEY( 'P$Mark(NULL); P$0',                F18, "S_F18", G$Stat );
! PF1  & PF2 are defined only in KED_MAP0
DEFINE_KEY( 'P$Lines_in_SR; P$0',               PF4, "S_PF4", G$Stat );
DEFINE_KEY( 'GV$_Mbuf := GET_INFO(CURRENT_BUFFER,"NAME"); P$0',
                                                KP4, "S_KP4", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL line!%S on this page",'
            + 'F$L_Count)); P$0',               KP7, "S_KP7", G$Stat );
DEFINE_KEY( 'P$Debug; P$0',                     KP8, "S_KP8", G$Stat );
DEFINE_KEY( 'P$Bind; P$0',                      KP9, "S_KP9", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL word!%S in SR",'
            + 'F$Words_in_SR)); P$0',           MINUS, "S_MINUS", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL word!%S in SR",'
            + 'F$Words_in_SR)); P$0',           CTRL_K_KEY, "S_MINUS", G$Stat );
DEFINE_KEY( 'P$TPU_compile; P$0',               KP5, "S_KP5", G$Stat );
DEFINE_KEY( 'P$DropBuffer; P$0',                KP6, "S_KP6", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("!SL character!%S in SR",F$Char_in_SR)); P$0',
                                                COMMA, "S_COMMA", G$Stat );
DEFINE_KEY( 'P$Count_L; P$0',                   KP1, "S_KP1", G$Stat );
DEFINE_KEY( 'MESSAGE(FAO("horizontal position is !SL (unshifted)",'
            + 'GET_INFO(CURRENT_BUFFER,"OFFSET_COLUMN"))); P$0',
                                                KP2, "S_KP2", G$Stat );
DEFINE_KEY( 'P$Current_C; P$0',                 KP3, "S_KP3", G$Stat );
DEFINE_KEY( 'P$QuoteChar; P$0',                 ENTER, "S_ENTER", G$Stat );
DEFINE_KEY( 'SPAWN(F$Prompt("Subprocess command",'
            + 'NULL,"U",FALSE),OFF); P$0',      KP0, "S_KP0", G$Stat );
DEFINE_KEY( 'P$Reset; P$0',                     PERIOD, "S_PERIOD", G$Stat );

! *** Undefined "VT" Function Keys ***
DEFINE_KEY( 'P$UndKey', F2, "", G$Base );
DEFINE_KEY( 'P$UndKey', F3, "", G$Base );
DEFINE_KEY( 'P$UndKey', F4, "", G$Base );
DEFINE_KEY( 'P$UndKey', F5, "", G$Base );
DEFINE_KEY( 'P$UndKey', F6, "", G$Base );
DEFINE_KEY( 'P$UndKey', F7, "", G$Base );
DEFINE_KEY( 'P$UndKey', F9, "", G$Base );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Base );

DEFINE_KEY( 'P$UndKey', F2, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F3, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F4, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F5, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F6, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F7, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F8, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F9, "", G$Gold );
DEFINE_KEY( 'P$UndKey', F10, "", G$Gold );
DEFINE_KEY( 'P$UndKey', DO, "", G$Gold );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Gold );

DEFINE_KEY( 'P$UndKey', F2, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F3, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F4, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F5, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F6, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F7, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F8, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F9, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F10, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F11, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F12, "", G$Buff );
DEFINE_KEY( 'P$UndKey', F13, "", G$Buff );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Buff );

DEFINE_KEY( 'P$UndKey', LEFT,  "", G$Stat );
DEFINE_KEY( 'P$UndKey', RIGHT, "", G$Stat );
DEFINE_KEY( 'P$UndKey', UP,    "", G$Stat );
DEFINE_KEY( 'P$UndKey', DOWN,  "", G$Stat );
DEFINE_KEY( 'P$UndKey', E3, "", G$Stat );
DEFINE_KEY( 'P$UndKey', E5, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F2, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F3, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F4, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F5, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F6, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F7, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F8, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F9, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F10, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F11, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F12, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F13, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F14, "", G$Stat );
DEFINE_KEY( 'P$UndKey', DO, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F19, "", G$Stat );
DEFINE_KEY( 'P$UndKey', F20, "", G$Stat );
DEFINE_KEY( 'P$UndKey', PF2, "", G$Stat );
DEFINE_KEY( 'P$UndKey', PF3, "", G$Stat );

ENDPROCEDURE  !P$Define


! === KEYMAP SUPPORT === !

PROCEDURE P$0
LOCAL keymap;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: ABORT;
ENDON_ERROR
  LOOP
    EXITIF ( GV$_shftc = 0 );
    CASE GV$_shftc FROM 1 TO 3
      [3]: REMOVE_KEY_MAP( G$KML, G$Stat );
      [2]: REMOVE_KEY_MAP( G$KML, G$Buff );
      [1]: REMOVE_KEY_MAP( G$KML, G$Gold );
      [OUTRANGE]: !null
      ENDCASE;
    GV$_shftc := GV$_shftc - 1;
    ENDLOOP;
  P$Status( CURRENT_WINDOW );
ENDPROCEDURE  !P$0

PROCEDURE P$PreKey
LOCAL dkey;
  IF GV$_trace THEN
    CASE GV$_shftc FROM 0 TO 3
      [0]: dkey := "<" + STR( LAST_KEY ) + ">";
      [1]: dkey := "Gold/<" + STR( LAST_KEY ) + ">";
      [2]: dkey := "Buff/<" + STR( LAST_KEY ) + ">";
      [3]: dkey := "Stat/<" + STR( LAST_KEY ) + ">";
      [OUTRANGE]: dkey := "(unknown key)";
      ENDCASE;
    MESSAGE( "Trace key: " + dkey );
  ENDIF;
ENDPROCEDURE  !P$PreKey

PROCEDURE P$PostKey
  !null
ENDPROCEDURE  !P$PostKey

! replace TPU's SHIFT_KEY with multi-level "virtual" shift-key
PROCEDURE P$GoldKey
LOCAL keymap;
ON_ERROR
  P$0; ABORT;
ENDON_ERROR
  GV$_shftc := GV$_shftc + 1;
  CASE GV$_shftc FROM 1 TO 3
    [1]: ADD_KEY_MAP( G$KML, "FIRST", G$Gold );
    [2]: ADD_KEY_MAP( G$KML, "FIRST", G$Buff );
    [3]: ADD_KEY_MAP( G$KML, "FIRST", G$Stat );
    [OUTRANGE]: P$0; ABORT;
    ENDCASE;
  P$Status( CURRENT_WINDOW );
ENDPROCEDURE  !P$GoldKey

PROCEDURE P$Keymap( Kmap; Buf )
LOCAL tbuf, km;
ON_ERROR
[TPU$_UNDEFINEDPROC]: MESSAGE( K$VNE_msg, km ); P$0; ABORT;
         [OTHERWISE]: MESSAGE( K$NKM_msg, km ); P$0; ABORT;
ENDON_ERROR
  tbuf := F$Default( Buf, "=", BUFFER, 0 );
  km   := EDIT( Kmap, NOT_IN_PLACE, UPPER );
  IF ( km <> G$Map ) THEN
    P$0;
    G$Map := km;
    F$Execute( "G$KML := KML$" + km );
    F$Execute( "G$Base := KM$" + km + "0" );
    F$Execute( "G$Gold := KM$" + km + "1" );
    F$Execute( "G$Buff := KM$" + km + "2" );
    F$Execute( "G$Stat := KM$" + km + "3" );
    SET( SHIFT_KEY, KEY_NAME( PF1, SHIFT_KEY ), G$KML ); !undefine default
    IF ( tbuf = 0 ) THEN  !do all buffers
      tbuf := GET_INFO( BUFFERS, "FIRST" );
      LOOP
        EXITIF ( tbuf = 0 );
        IF ( G$KML <> GET_INFO( tbuf, "KEY_MAP_LIST" ) ) THEN
          SET( KEY_MAP_LIST, G$KML, tbuf );
        ENDIF;
        tbuf := GET_INFO( BUFFERS, "NEXT" );
        ENDLOOP;
    ELSE ! just switch the specified buffer's keymap
      SET( KEY_MAP_LIST, G$KML, tbuf );
    ENDIF;
  ENDIF;
  IF ( GV$_debug ) THEN
    MESSAGE( "Keymap: " + G$Map + " (" + G$KML + " = " +
             G$Base + "," + G$Gold + "," + G$Buff + "," + G$Stat + ")" );
  ENDIF;
ENDPROCEDURE  !P$Keymap


! === KEY BINDING SUPPORT === !

PROCEDURE P$Dmatch( km )
  IF ( GET_INFO( GV$_Mopen, "TYPE" ) <> STRING ) THEN
    GV$_Mopen  := GV$_Ldelims;
    GV$_Mclose := GV$_Rdelims;
    DEFINE_KEY( 'P$Imatched("(",NULL)', KEY_NAME( "(" ), "", km );
    DEFINE_KEY( 'P$Imatched("[",NULL)', KEY_NAME( "[" ), "", km );
    DEFINE_KEY( 'P$Imatched("{",NULL)', KEY_NAME( "{" ), "", km );
    DEFINE_KEY( 'P$Imatched("`",NULL)', KEY_NAME( "`" ), "", km );
    DEFINE_KEY( 'P$Imatched(K$dquote,NULL)', KEY_NAME( K$dquote ), "", km );
  ENDIF;
ENDPROCEDURE  !P$Dmatch

PROCEDURE P$UndMatch( km )
  GV$_Mopen  := 0;
  GV$_Mclose := 0;
  UNDEFINE_KEY( KEY_NAME( "(" ), km );
  UNDEFINE_KEY( KEY_NAME( "[" ), km );
  UNDEFINE_KEY( KEY_NAME( "{" ), km );
  UNDEFINE_KEY( KEY_NAME( "`" ), km );
  UNDEFINE_KEY( KEY_NAME( K$dquote ), km );
ENDPROCEDURE  !P$UndMatch

PROCEDURE P$Bind
LOCAL msg, ifil, buf, pgm, lkey, kcom;
ON_ERROR
  IF ( CURRENT_BUFFER = $$SCRATCH_BUFFER ) THEN
    POSITION( buf );
  ENDIF;
  RETURN;
ENDON_ERROR
  P$ClrMsg;
  msg  := "Compile/Bind";
  ifil := F$Prompt( "TPU file to " + msg, "ked$command", "UD", FALSE );
  buf  := CURRENT_BUFFER;
  POSITION( $$SCRATCH_BUFFER );
  ERASE( $$SCRATCH_BUFFER );
  READ_FILE( ifil );
  pgm := COMPILE( $$SCRATCH_BUFFER );
  LOOP
    MESSAGE( K$LC1_msg, 0, "for " + msg );
    lkey := READ_KEY;
    IF ( lkey = CTRL_Z_KEY ) THEN
      MESSAGE( K$CAN_msg, 0, msg );
      RETURN;
    ENDIF;
    kcom := LOOKUP_KEY( lkey, COMMENT );
    IF ( kcom <> NULL ) THEN MESSAGE( K$LC2_msg );
    ELSE IF ( F$PrintingChar( lkey ) = NULL ) THEN
           DEFINE_KEY( pgm, lkey, NULL, G$Base );
           MESSAGE( msg + " of `" + ifil + "' successful" );
           EXITIF( TRUE );
         ELSE MESSAGE( K$LC3_msg, 0, msg );
         ENDIF;
    ENDIF;
    ENDLOOP;
  POSITION( buf );
ENDPROCEDURE  !P$Bind

PROCEDURE P$Learn
LOCAL msg, LSeq, LKey, KCom, err, KMap, gold, isLetr, lLetr, uLetr;
ON_ERROR
[TPU$_NOTLEARNING]:
  MESSAGE( "Nothing to remember" );
  RETURN;
[OTHERWISE]:
  err := ( ERROR = TPU$_RECURLEARN );
ENDON_ERROR;
  IF ( NOT GV$_learning ) THEN
    P$Post( "Start " + F$Keyword( GV$_lmode, EXACT, "exact", "general" )
             + " Learn Sequence --" );
    MESSAGE( K$CTRL_Rp );
    LEARN_BEGIN( GV$_lmode );
    GV$_learning := TRUE;
  ELSE GV$_learning := FALSE;
    LSeq := LEARN_END;
    msg  := "Learn Sequence";
    KMap := G$Base;
    err  := FALSE;
    gold := FALSE;
    P$ClrMsg;
    LOOP
      IF ( NOT gold ) THEN MESSAGE( K$LC1_msg, 0, "for " + msg ); ENDIF;
      LKey := READ_KEY;
      CASE LKey FROM PF1 TO CTRL_Z_KEY
      [CTRL_Z_KEY]: MESSAGE( K$CAN_msg, 0, msg );
                    RETURN;
      [PF1]: KMap := G$Gold;  !a <Gold>-<letter> user assignment
             gold := TRUE;
      [OTHERWISE]: KCom := LOOKUP_KEY( LKey, COMMENT );
        IF ( KCom <> NULL ) THEN
          MESSAGE( K$LC2_msg );
        ELSE uLetr := ASCII( LKey );
          isLetr := ( INDEX( K$LETTERS, uLetr ) > 0 );
          IF ( isLetr ) THEN  !force case-insensitive
            lLetr := EDIT( uLetr, NOT_IN_PLACE, LOWER );
            uLetr := EDIT( uLetr, NOT_IN_PLACE, UPPER );
            LKey  := KEY_NAME( uLetr );
          ENDIF;
          IF ( F$PrintingChar( LKey ) = NULL ) THEN  !a function key
            DEFINE_KEY( LSeq, LKey, NULL, KMap );
            uLetr := NULL;
          ELSE IF ( gold AND isLetr ) THEN  !a printing char, w/Gold
             DEFINE_KEY( LSeq, KEY_NAME( uLetr ), NULL, KMap ); !Upper <Gold><X>
             DEFINE_KEY( LSeq, KEY_NAME( lLetr ), NULL, KMap ); !Lower <Gold><x>
             uLetr := " (<Gold><" + uLetr + "/" + lLetr + ">)";
           ELSE MESSAGE( K$LC3_msg, 0, msg );
           ENDIF;
          ENDIF;
          IF ( err ) THEN
            MESSAGE( K$LC4_msg, 0, msg );
            err := FALSE;
          ELSE MESSAGE( msg + " successful" + uLetr );
            EXITIF ( TRUE );
          ENDIF;
        ENDIF;
      ENDCASE;
      ENDLOOP;
  ENDIF;
ENDPROCEDURE  !P$Learn

PROCEDURE P$RET_key
LOCAL len;
ON_ERROR
  IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) = K$DCLbuf ) THEN
    COPY_TEXT( K$DCL );
    RETURN;
  ENDIF;
ENDON_ERROR
  IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) = K$DCLbuf ) THEN
    P$DCLsend( CURRENT_LINE );
  ELSE IF ( GET_INFO( CURRENT_BUFFER, "MODE" ) = OVERSTRIKE ) THEN
         P$MoveL( FORWARD );
         len := LENGTH( CURRENT_LINE );
         IF ( len >= GV$_Lmargin ) THEN
           MOVE_HORIZONTAL( +GV$_Lmargin );
         ELSE IF ( len > 0 ) AND ( len < GV$_Lmargin ) THEN
                POSITION( LINE_END );
              ELSE P$InsIndent( GV$_Lmargin );
              ENDIF;
         ENDIF;
       ELSE SPLIT_LINE;
         P$InsIndent( GV$_Lmargin );
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$RET_key

! (re)define keys used by menu processing (utility)
PROCEDURE P$RET_ENTER_keys( km )
  DEFINE_KEY( 'P$RET_key', RET_KEY, "RET_KEY", km );
  DEFINE_KEY( 'P$Repeat', ENTER, "ENTER", km );
ENDPROCEDURE  !P$RET_ENTER_keys

PROCEDURE P$CTRL_Z_key
  IF ( GV$_QuitPend ) THEN P$Bye( K$Quit ); ENDIF;
  IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) = K$DCLbuf ) THEN
    EXECUTE( "SEND_EOF(GV$_DCLpid)" );
    COPY_TEXT( K$DCL );
  ELSE IF ( CURRENT_WINDOW = TPU$X_SHOW_WINDOW ) THEN
         SET( TEXT, TPU$X_SHOW_WINDOW, BLANK_TABS );
         UNMAP( TPU$X_SHOW_WINDOW );
         P$0;
       ELSE P$Command;
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$CTRL_Z_key

PROCEDURE P$eXcursion
LOCAL km;
  ! eXcursion's "default" PC keymapping imposes a different twist on the
  ! so-called "standard" 101/102-key keymapping: It makes the physical F11 key
  ! generate the <Help> function, and the physical F12 key generates the <Do>
  ! function; the functions for F11 and F12 don't exist!
  ! P$eXcursion puts the "expected" KED functions on those two physical
  ! F11/F12 keys, regardless of what they're mapped to internally, thus
  ! UNmapping the REmapped confusion.
  km := G$Map;
  P$Keymap( "PC" );
  DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', HELP, "F19",   G$Base );
  DEFINE_KEY( 'GV$_flipR := 0; '
              + 'P$STarget(F$Bump,K$chevrons);',    DO,   "F20",   G$Base );
  DEFINE_KEY( 'P$CenterL; P$0',                     HELP, "G_F19", G$Gold );
  DEFINE_KEY( 'P$Insert(K$chevrons); P$0',          DO,   "G_F20", G$Gold );
  DEFINE_KEY( 'P$RW; P$0',                          HELP, "B_F19", G$Buff );
  DEFINE_KEY( 'P$GotoAbsL; P$0',                    DO,   "B_F20", G$Buff );
  DEFINE_KEY( 'P$UndKey',                           HELP, "",      G$Stat );
  DEFINE_KEY( 'P$UndKey',                           DO,   "",      G$Stat );
  P$Keymap( km );
ENDPROCEDURE  !P$eXcursion


! === RAPT Support === !

PROCEDURE P$RAPTsetup
  ! Define special mappings for RAPT:
  !   (re)define both F17--F20 for "VT" and F9--F12 for "PC",
  !   even though they are duplicates.
  ! Note that standard KED functions for these keys are lost in RAPT.
LOCAL km, tmpl;
  IF ( $$LEGEND_WINDOW = 0 ) THEN  !initial setup
    km := G$Map;
    ! "VT"/RAPT:
    P$Keymap( "KED" );
    DEFINE_KEY( 'P$0; P$Bye(K$Quit);',                F17, "", G$Base );
    DEFINE_KEY( 'P$RAPTnew(1);',                      F18, "", G$Base );
    DEFINE_KEY( 'P$RAPTnew(0);',                      F18, "", G$Gold );
    DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', F19, "", G$Base );
    DEFINE_KEY( 'P$0; P$Bye(K$Exit)',                 F20, "", G$Base );
    UNDEFINE_KEY( F17, G$Gold );  !remove <Gold>/Frep
    ! "PC"/RAPT:
    P$Keymap( "PC" );
    DEFINE_KEY( 'P$0; P$Bye(K$Quit);',                F9,  "", G$Base );
    DEFINE_KEY( 'P$RAPTnew(1);',                      F10, "", G$Base );
    DEFINE_KEY( 'P$RAPTnew(0);',                      F10, "", G$Gold );
    DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', F11, "", G$Base );
    DEFINE_KEY( 'P$0; P$Bye(K$Exit)',                 F12, "", G$Base );
    UNDEFINE_KEY( F9, G$Gold );  !remove <Gold>/Frep
    IF ( GV$Keyboard = "PCDECW" ) THEN
      DEFINE_KEY( 'F$Printfile("SYS$PRINT",TRUE,NULL)', HELP, "", G$Base );
      DEFINE_KEY( 'P$0; P$Bye(K$Exit)',                 DO,   "", G$Base );
    ENDIF;
    ! Remap whatever was the original mapping:
    P$Keymap( km );
    ! Construct a special system window/buffer
    ! to hold visible key-legends, alá RAPT:
    $$LEGEND_WINDOW := CREATE_WINDOW( GV$_screen - 5, 4, OFF );
    $$LEGEND_BUFFER := CREATE_BUFFER( K$Legbuf );
    SET( EOB_TEXT,  $$LEGEND_BUFFER, NULL );
    SET( MAX_LINES, $$LEGEND_BUFFER, 10 );
    SET( NO_WRITE,  $$LEGEND_BUFFER );
    SET( PERMANENT, $$LEGEND_BUFFER );
    SET( SYSTEM,    $$LEGEND_BUFFER );
    SET( TEXT,      $$LEGEND_WINDOW, NO_TRANSLATE );
    SET( STATUS_LINE, $$LEGEND_WINDOW, NONE, NULL ); !NULL turns OFF Stat-Line
    HELP_TEXT( "ked$help", "$RAPT_" + G$Map, OFF, $$LEGEND_BUFFER );
    POSITION( BEGINNING_OF( $$LEGEND_BUFFER ) );
    P$Do_N( "ERASE_LINE", NULL, 3 );
    MOVE_VERTICAL( +4 );
    ERASE_LINE;
    POSITION( BEGINNING_OF( $$LEGEND_BUFFER ) );
    ADJUST_WINDOW( CURRENT_WINDOW, 0, -4 );
  ELSE UNMAP( $$LEGEND_WINDOW ); !...only to reMAP it!
  ENDIF;
  MAP( $$LEGEND_WINDOW, $$LEGEND_BUFFER );
  POSITION( GV$_CurWin );
  tmpl := F$TranslateLNM( "ked$auto_template", NULL );
  IF ( tmpl <> NULL ) THEN
    P$RAPTnew( 2, tmpl );  !auto-expand a template, w/ no prompting
  ENDIF;
  UPDATE( ALL );
ENDPROCEDURE  !P$RAPTsetup

PROCEDURE P$RAPTnew( Check; Tmpl )
LOCAL rc, ans, tm, def;
  def := F$Default( Tmpl, "=", STRING, NULL );
  IF ( GET_INFO( $$LSE_BUFFER, "TYPE" ) = BUFFER ) THEN    !templates loaded?
    ans := NULL;
    rc := GET_INFO( CURRENT_BUFFER, "RECORD_COUNT" );
    IF ( rc > 0 ) THEN
      CASE Check FROM 0 TO 2
        [0]: ans := "Y";
             ERASE( CURRENT_BUFFER );
             UPDATE( CURRENT_WINDOW );
        [1]: ans := SUBSTR( F$Prompt( "Existing data will be deleted.  Continue (y/n)",
                            "N", "DU", FALSE ), 1, 1 );
             IF ( ans <> "Y" ) THEN RETURN; ENDIF;
             ERASE( CURRENT_BUFFER );
             UPDATE( CURRENT_WINDOW );
        [2]: ans := "N";
      ENDCASE;
    ENDIF;
    IF ( ans = "Y" ) OR ( rc = 0 ) THEN
      IF ( def <> NULL ) AND ( def <> "$DEFAULT" ) THEN
        tm := def;                      ! expand the specified template,
      ELSE tm := SPAN( K$LETTERS );       ! or the default (first) template
      ENDIF;
      P$LSE_template( tm );  !the first one
    ENDIF;
  ELSE MESSAGE( "No templates for this field" );
  ENDIF;
ENDPROCEDURE  !P$RAPTnew


! === BASIC SUPPORT === !

PROCEDURE P$Command
LOCAL cmd, i, topic, typ;
ON_ERROR
[TPU$_COMPILEFAIL]:
  MESSAGE( "Unrecognized TPU command during immediate compile" );
  RETURN;
[TPU$_CONTROLC,
 OTHERWISE]: RETURN;
ENDON_ERROR
  P$SelectRange;
  typ := F$GetFtype( NULL );
  IF ( typ = "TPU" ) AND ( GV$_SelectRng <> 0 ) THEN
    cmd := F$Prompt( "Execute TPU command in Select Range (y/n)", "N", "DU", FALSE );
    IF ( SUBSTR( cmd, 1, 1 ) = "Y" ) THEN
      EXECUTE( GV$_SelectRng );
      P$Reset;
      RETURN;
    ENDIF;
  ENDIF;
  cmd := F$Prompt( "TPU command", NULL, NULL, FALSE );
  IF ( cmd = NULL ) THEN RETURN;
  ELSE EDIT( cmd, TRIM, COMPRESS, UPPER, ON );
    IF ( SUBSTR( cmd, 1, 1 ) = "?" ) THEN
      topic := SUBSTR( cmd, 2, LENGTH( cmd ) - 1 );
      P$Help( topic, "sys$help:tpuhelp.hlb" );  !VAXTPU help library
    ELSE CASE SUBSTR( cmd, 1, 4 ) FROM "EXIT" TO "RECO"
      ["EXIT"]: P$Bye( K$Exit );
      ["QUIT"]: P$Bye( K$Quit );
      ["RECO"]: IF ( GV$_JouMeth = "B" ) THEN
                  P$Recover( NULL );
                ELSE MESSAGE( 'Keystroke Journaling: no buffers to recover' );
                ENDIF;
      ["HELP"]: IF ( cmd = "HELP" ) THEN
                  P$Help( "Summary" );
                ELSE i := INDEX( cmd, K$spc );
                  topic := SUBSTR( cmd, i, LENGTH( cmd ) - i );
                  P$Help( topic );
                ENDIF;
      [INRANGE,
       OUTRANGE] : cmd := COMPILE( cmd );
                   IF ( cmd <> 0 ) THEN EXECUTE( cmd ); ENDIF;
      ENDCASE;
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Command

PROCEDURE P$Trace( ; arg )
LOCAL val;
  !Primarily turns on keystroke tracing (see P$PreKey and P$PostKey)
  val := F$Default( arg, "U", UNSPECIFIED, ( NOT GV$_trace ) );
  IF ( arg = ON )  THEN val := TRUE;
  ELSE IF ( arg = OFF ) THEN val := FALSE; ENDIF;
  ENDIF;
  IF ( val = GV$_trace ) THEN RETURN; ENDIF;  !no change?
  IF ( val ) THEN GV$_trace := TRUE;
    SET( TRACEBACK, ON );
  ELSE GV$_trace := FALSE;
    SET( TRACEBACK, OFF );
  ENDIF;
ENDPROCEDURE  !P$Trace

PROCEDURE P$Debug( ; arg )
LOCAL val, Cbuf, Nwin, siz, lgd, splt;
ON_ERROR
ENDON_ERROR
  val := F$Default( arg, "U", UNSPECIFIED, ( NOT GV$_debug ) );
  IF ( arg = ON )  THEN val := TRUE;
  ELSE IF ( arg = OFF ) THEN val := FALSE; ENDIF;
  ENDIF;
  IF ( val = GV$_debug ) THEN RETURN; ENDIF;  !no change?
  Cbuf := CURRENT_BUFFER;
  GV$_CurWin := CURRENT_WINDOW;
  lgd  := ( GET_INFO( $$LEGEND_WINDOW, "TYPE" ) = WINDOW );
  splt := ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY );
  IF ( splt ) THEN     !split-windows?
    Nwin := GET_INFO( GV$_MWin, "LAST" );
    siz  := GV$_screen / ( Nwin * 3 );
  ELSE siz := GV$_screen / 3;
  ENDIF;
  IF ( lgd ) THEN
    IF ( siz <= 6 ) THEN siz := 4; ENDIF;
  ELSE IF ( siz < 2 ) THEN siz := 2; ENDIF;
  ENDIF;  !RAPT legend is displayed
  IF ( val ) THEN GV$_debug := TRUE;
    SET( TRACEBACK, ON );
    siz := -1 * siz;  !shrink main, increase message
  ELSE GV$_debug := FALSE;
    SET( TRACEBACK, OFF );
  ENDIF;
  IF ( splt ) THEN
    ADJUST_WINDOW( GV$_MWin{Nwin}, 0, siz );  !bottom window
  ENDIF;
  ADJUST_WINDOW( $$1_WINDOW, 0, siz );
  ADJUST_WINDOW( $$MESSAGE_WINDOW, siz, 0 );  !becomes current_window
  SET( SCROLLING, $$MESSAGE_WINDOW, ON, 0, 0, 0 );
  IF ( lgd ) AND NOT( GV$_debug ) THEN P$RAPTsetup; ENDIF; !reset RAPT key legends
  MAP( GV$_CurWin, Cbuf );                    !reset current_window
  MESSAGE( "Debug/Traceback: "
           + F$Keyword( GV$_debug, TRUE, "TRUE", "FALSE" ) );
ENDPROCEDURE  !P$Debug

PROCEDURE F$Default( Arg, Op, PTyp, Def )
LOCAL rval;
  CASE SUBSTR( Op, 1, 1 ) FROM "<" TO "u"
    ["U",
     "u"]: IF ( GET_INFO( Arg, "TYPE" ) = UNSPECIFIED ) THEN rval := Def;
           ELSE rval := Arg; ENDIF;
    ["<"]: IF ( GET_INFO( Arg, "TYPE" ) <> PTyp ) THEN rval := Def;
           ELSE rval := Arg; ENDIF;
    ["="]: IF ( GET_INFO( Arg, "TYPE" ) = PTyp ) THEN rval := Arg;
           ELSE rval := Def; ENDIF;
    ENDCASE;
  RETURN( rval );
ENDPROCEDURE  !F$Default

PROCEDURE F$Execute( cmd )
ON_ERROR
[TPU$_UNDEFINEDPROC]: MESSAGE( K$VNE_msg, cmd ); RETURN( FALSE );
         [OTHERWISE]: RETURN( FALSE );
ENDON_ERROR
  IF GV$_debug THEN MESSAGE( "F$Execute debug:  " + cmd ); ENDIF;
  EXECUTE( cmd );
  RETURN( TRUE );
ENDPROCEDURE  !F$Execute

PROCEDURE F$IStr( scode, ecode )
LOCAL code, strg;
  code := scode;
  strg := NULL;
  LOOP
    EXITIF ( code > ecode );
    strg := strg + ASCII( code );
    code := code + 1;
    ENDLOOP;
  RETURN( strg )
ENDPROCEDURE  !F$IStr

PROCEDURE P$WordDelims( W; Opt )
LOCAL d;
  d := F$Default( Opt, "=", STRING, NULL );
  W := K$spc + F$IStr( 9, 13 ) + "_";  !defaults
  IF ( d <> NULL ) THEN
    W := W + d;
  ENDIF;
ENDPROCEDURE  !P$WordDelims

PROCEDURE P$MouseNull
  MESSAGE( "P$MouseNull: MB!SL (no operation)", 0,
           GET_INFO( LAST_KEY, "MOUSE_BUTTON" ) );
ENDPROCEDURE  !P$MouseNull

PROCEDURE P$Null
  !do nothing
ENDPROCEDURE  !P$Null

PROCEDURE P$Do_N( cmd, chr, cnt )
LOCAL n;
ON_ERROR
  MESSAGE( "Command syntax error: `" + cmd + "'" );
  P$0; ABORT;
ENDON_ERROR
  n := cnt;  !read-only cnt
!!  IF ( n > G$screen ) AND ( cmd <> 0 ) THEN
!!    SET( SCREEN_UPDATE, OFF );
!!  ENDIF;
  LOOP
    EXITIF ( n < 1 );
    IF ( cmd <> 0 ) THEN
      EXECUTE( cmd );
    ELSE COPY_TEXT( chr );
    ENDIF;
    n := n - 1;
    ENDLOOP;
  IF ( cnt < 1 ) THEN MESSAGE( "...repeat done" ); ENDIF;
!!  SET( SCREEN_UPDATE, ON );
ENDPROCEDURE  !P$Do_N

PROCEDURE P$Repeat
LOCAL i, chr, key;
  i := F$Prompt( "Repeat", "0", "D", FALSE );
  EDIT( i, COLLAPSE );  !trailing blanks make INT return zero
  i := INT( i );
  P$0;
  key := LAST_KEY;
  IF ( key = PF1 ) THEN P$GoldKey; ENDIF;
  IF ( ( key = RET_KEY )
  OR   ( key = ENTER )
  OR   ( key = PF1 ) )
  AND ( i > 0 ) THEN
    LOOP
      UPDATE( CURRENT_WINDOW );  !to show PF1 key-state
      chr := READ_LINE( "Function: ", 1 );
      key := LAST_KEY;
      EXITIF ( key <> PF1 );  !Gold key?
      P$GoldKey;
      ENDLOOP;
  ENDIF;
  IF ( key = HELP ) THEN P$Keypad_Help;
  ELSE IF ( i > 0 ) THEN
         P$Do_N( LOOKUP_KEY( key, PROGRAM ), chr, i );
        IF ( i > 1 ) THEN MESSAGE( "...repeat done" ); ENDIF;
       ENDIF;
  ENDIF;
  P$0;
ENDPROCEDURE  !P$Repeat

PROCEDURE P$Reset( ; SearchGuard )
LOCAL sg;
  sg := F$Default( SearchGuard, "U", UNSPECIFIED, FALSE );
  ! GV$_flipR must be managed by various Search routines...
  GV$_RngA   := 0;
  GV$_RngB   := 0;
  GV$_LSErng := 0;
  ! This guard permits starting a SelRange, then do a search for
  ! a target-string to form a valid select range:
  IF NOT( sg )
  THEN GV$_SelectRng      := 0;
       GV$_SelectRngStart := 0;
       GV$_SearchRng      := 0;
  ENDIF;
  P$ChkRuler( TRUE );
ENDPROCEDURE  !P$Reset

PROCEDURE P$TPU_Compile
LOCAL c, p, ep, msg;
ON_ERROR
  P$Debug( TRUE );
  RETURN;
ENDON_ERROR
  c := 0;
  IF ( GV$_SelectRngStart = 0 ) THEN
    p := SEARCH_QUIETLY( "PRO" + "CEDURE ", REVERSE, NO_EXACT );
    IF ( p <> 0 ) THEN
      ep := SEARCH_QUIETLY( "ENDPRO" + "CEDURE", FORWARD, NO_EXACT );
      IF ( ep <> 0 ) THEN
        c := CREATE_RANGE( BEGINNING_OF( p ), END_OF( ep ), REVERSE );
      ENDIF;
    ENDIF;
  ELSE c := CREATE_RANGE( GV$_SelectRngStart, MARK( NONE ), NONE );
    P$Reset;
  ENDIF;
  IF ( GET_INFO( c, "TYPE" ) = RANGE ) THEN
    COMPILE( c );
    msg := "TPU compile done";
  ELSE msg := "No TPU proc" + "edure to compile";
  ENDIF;
  MESSAGE( msg );
ENDPROCEDURE  !P$TPU_Compile

PROCEDURE P$UndKey
LOCAL dkey;
  CASE GV$_shftc FROM 0 TO 3
    [0]: dkey := "<" + STR( LAST_KEY ) + ">";
    [1]: dkey := "Gold/<" + STR( LAST_KEY ) + ">";
    [2]: dkey := "Buff/<" + STR( LAST_KEY ) + ">";
    [3]: dkey := "Stat/<" + STR( LAST_KEY ) + ">";
    [OUTRANGE]: dkey := "(unknown key)";
    ENDCASE;
  MESSAGE( "Undefined key: " + dkey );
  P$0;
ENDPROCEDURE  !P$UndKey


! === JOURNALING === !

PROCEDURE F$JourName( Buf )
LOCAL bnam;
  IF ( GET_INFO( Buf, "TYPE" ) = STRING ) THEN  !recovering
    bnam := FILE_PARSE( Buf, NULL, NULL, NAME, TYPE );
  ELSE bnam := F$GetNT( Buf, "OUTPUT_FILE" );   !setting journaling
  ENDIF;
  TRANSLATE( bnam, "_______", ":[]<>.;", IN_PLACE );
  bnam := "SYS$SCRATCH:" + bnam + ".TPU$JOURNAL";
  IF ( GV$_debug ) THEN MESSAGE( 'Buffer journal filename: "' + bnam + '"' ); ENDIF;
  RETURN( bnam );
ENDPROCEDURE  !F$JourName

PROCEDURE P$ReRecover( Fil, Jf, Win )
LOCAL fn, buf, s;
ON_ERROR
[TPU$_OPENIN,
 TPU$_BADJOUFILE,
 TPU$_DUPBUFNAME,
 TPU$_RECOVERFAIL,
 TPU$_NOTJOURNAL]:
 buf := 0;
[TPU$_JRNLNOTSAFE]:
  MESSAGE( K$Jun_msg, 0, jf );
  MESSAGE( K$Jsv_msg );
[OTHERWISE]:
ENDON_ERROR
  fn  := Fil;
  s   := 'for ';
  buf := 0;
  P$FileDir( "sys$scratch:*.tpu$journal;*" );
  UPDATE( ALL );
  LOOP
    MESSAGE( K$Jnf_msg, 0, s, Jf );
    Jf := F$Prompt( "[1mJournal filename[0m to recover", NULL, "UN", FALSE );
    EXITIF ( Jf = NULL );
    Jf := FILE_PARSE( Jf, "sys$scratch:.tpu$journal" );
    buf := RECOVER_BUFFER( fn, Jf );
    EXITIF ( F$RecSave( buf, fn, Win ) );
    s := NULL;
    ENDLOOP;
  RETURN;
ENDPROCEDURE  !P$ReRecover

PROCEDURE P$Recover( Fil; Win )
LOCAL fn, wn, jf, buf, tbuf, ans, outf;
ON_ERROR
[TPU$_OPENIN,
 TPU$_BADJOUFILE,
 TPU$_RECOVERFAIL,
 TPU$_NOTJOURNAL]:
  P$ReRecover( fn, fn, wn );
  RETURN;
[TPU$_JRNLNOTSAFE]:
  MESSAGE( K$Jun_msg, 0, jf );
  MESSAGE( K$Jsv_msg );
[OTHERWISE]:
ENDON_ERROR
  ! Handles Buffer Journal recovery only; Keystroke Journal recovery is
  ! done by VAXTPU itself in response to the /RECOVER qualifier.
  fn := Fil;
  wn := F$Default( Win, "=", WINDOW, 0 );
  IF ( fn = NULL ) THEN
    fn := F$Prompt( "File to [1mrecover[0m", NULL, "UN", FALSE );
    IF ( fn = NULL ) THEN RETURN; ENDIF;
    tbuf := F$FindBuf( fn, "X" );
    IF ( tbuf <> 0 ) THEN
      ans := F$Prompt( fn + " already exists "
                       + "--- Overwrite it", "N", "UD", FALSE );
      IF ( SUBSTR( ans, 1, 1 ) = "N" ) THEN RETURN; ENDIF;
    ENDIF;
    P$RememberBuf;
  ENDIF;
  jf := F$JourName( fn );
  buf := RECOVER_BUFFER( fn, jf );  !may error-trap
  F$RecSave( buf, fn, wn );
ENDPROCEDURE  !P$Recover

PROCEDURE F$RecSave( Buf, Fn, Win )
LOCAL ok, outf;
  IF ( GET_INFO( Buf, "TYPE" ) <> BUFFER ) THEN
    Buf := F$FindBuf( Fn, "X" );
  ENDIF;
  ok := ( GET_INFO( Buf, "TYPE" ) = BUFFER );
  IF ( ok ) THEN
    SET( KEY_MAP_LIST, G$KML, Buf );
    IF ( GET_INFO( Win, "TYPE" ) = WINDOW ) THEN
      MAP( Win, Buf );
    ELSE MAP( CURRENT_WINDOW, Buf );
    ENDIF;
    F$Exists( Fn, outf, K$dfspec, "O" );
    SET( OUTPUT_FILE, Buf, outf );
    IF ( SUBSTR( F$Prompt( "[1mSave `" + outf + "' now (recommended)",
                           "Y", "UD", FALSE ), 1, 1 ) = "Y" ) THEN
      Fn := F$Output( "A", FALSE, outf );
      P$Post( K$ANSI_Str_BOLD + Fn + " recovered" + K$ANSI_Rend );
    ELSE MESSAGE( K$NYS_msg, 0, Fn );
    ENDIF;
    P$Status( CURRENT_WINDOW );
  ELSE MESSAGE( K$Nre_msg, 0, Fn );
  ENDIF;
  RETURN( ok );
ENDPROCEDURE  !F$RecSave

PROCEDURE P$Journal( Buf )
LOCAL nam, tmp, jf;
  IF ( NOT GET_INFO( COMMAND_LINE, "JOURNAL" ) ) THEN
    IF ( GV$_debug ) THEN MESSAGE( "No Journaling (/NOJOURNAL)" ); ENDIF;
    RETURN;
  ENDIF;
  nam := GET_INFO( Buf, "NAME" );
  IF ( GV$_JouMeth = "B" ) THEN  !Buffer journaling:
    IF ( NOT GET_INFO( Buf, "JOURNALING" ) ) THEN
      IF ( GET_INFO( Buf, "SAFE_FOR_JOURNALING" ) ) THEN
        jf := F$JourName( Buf );
        SET( JOURNALING, Buf, ON, jf );
        SET( JOURNALING, GV$_JouRate );
        jf := GET_INFO( Buf, "JOURNAL_FILE" );
        IF ( jf = 0 ) THEN
          MESSAGE( K$BJf_msg );
        ELSE IF ( GV$_debug ) THEN MESSAGE( "BufJournal: " + jf
                                            + ", Rate: " + INT( GV$_JouRate ) ); ENDIF;
        ENDIF;
      ELSE MESSAGE( K$Jun_msg, 0, nam );
      ENDIF;
    ENDIF;
  ELSE !Keystroke journaling:
    IF ( GV$_JouFile = NULL ) THEN  !not yet opened:
      tmp := GET_INFO( COMMAND_LINE, "JOURNAL_FILE" );
      IF ( INDEX( tmp, "*" ) OR INDEX( tmp, "%" ) ) THEN tmp := NULL; ENDIF;
      jf := FILE_PARSE( tmp, "sys$scratch:.tjl;",
                        FILE_PARSE( nam, NULL, NULL, NAME ) );
      IF ( F$Exists( tmp, jf, jf, "O" ) ) THEN
        GV$_JouFile := JOURNAL_OPEN( jf );
        SET( JOURNALING, GV$_JouRate );
      ENDIF;
      IF ( GV$_debug ) THEN MESSAGE( "KeyJournal: " + jf
                                     + ", Rate: " + INT( GV$_JouRate ) ); ENDIF;
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Journal


! === BUFFERS === !

PROCEDURE F$CreateBuf( sop; nam, wnd, inf, outf, dim )
LOCAL opt, op, sys, bout, bnam, bwnd, binf, bmxl, blm, brm, wmap;
ON_ERROR
  RETURN( 0 );
ENDON_ERROR
  sys := FALSE;
  binf := F$Default( inf, "U", STRING, NULL );
  bout := F$Default( outf, "U", STRING, binf );
  bnam := F$Default( nam, "U", STRING,
                     FILE_PARSE( bout, "$X$.TXT", NULL, NAME, TYPE ) );
  bwnd := F$Default( wnd, "=", WINDOW, 0 );
  bmxl := NULL;  blm := NULL;  brm := NULL;
  IF ( GET_INFO( dim, "TYPE" ) = STRING ) AND ( dim <> NULL ) THEN
    bmxl := F$ELEMENT( 0, K$semicolon, dim );
    blm  := F$ELEMENT( 1, K$semicolon, dim );
    brm  := F$ELEMENT( 2, K$semicolon, dim );
  ENDIF;

  IF ( binf <> NULL ) THEN
    GV$_B := CREATE_BUFFER( bnam, binf );
  ELSE GV$_B := CREATE_BUFFER( bnam );
  ENDIF;
  ! Stash this buffer's name in array:
  GV$_BufName{GV$_B} := bnam;
  GV$_LastMark{GV$_B} := BEGINNING_OF( GV$_B );

  SET( KEY_MAP_LIST, G$KML, GV$_B );
  IF ( GET_INFO( GV$_B, "TYPE" ) = BUFFER ) THEN
    IF ( bout <> NULL ) THEN
      F$Execute( "SET(OUTPUT_FILE, GV$_B, '" + bout + "')" ); ENDIF;
    IF ( blm <> NULL ) AND ( blm <> K$semicolon ) THEN
      F$Execute( "SET(LEFT_MARGIN, GV$_B, " + blm + ")" ); ENDIF;
    IF ( brm <> NULL ) AND ( brm <> K$semicolon ) THEN
      F$Execute( "SET(RIGHT_MARGIN, GV$_B, " + brm + ")" ); ENDIF;
    IF ( bmxl <> NULL ) AND ( bmxl <> K$semicolon ) THEN
      F$Execute( "SET(MAX_LINES, GV$_B, " + bmxl + ")" ); ENDIF;
    wmap := FALSE;
    opt := EDIT( sop, NOT_IN_PLACE, UPPER );
    op  := 1;

    LOOP
      EXITIF ( op > LENGTH( opt ) );
      CASE SUBSTR( opt, op, 1 ) FROM "A" TO "Z"
        ["E"]: F$Execute( "SET(EOB_TEXT, GV$_B, '[End " + bnam + "]')" );
        ["I"]: SET( INSERT, GV$_B );
        ["J"]: P$Journal( GV$_B );
        ["M"]: SET( MODIFIED, GV$_B, ON );
        ["O"]: SET( OVERSTRIKE, GV$_B );
        ["P"]: SET( PERMANENT, GV$_B );
        ["R"]: SET( NO_WRITE, GV$_B );
        ["S"]: SET( SYSTEM, GV$_B );
               SET( EOB_TEXT, GV$_B, NULL );
               sys := TRUE;
        ["W"]: wmap := TRUE;
        ENDCASE;
      op := op + 1;
      ENDLOOP;

    IF ( NOT sys ) THEN P$RememberBuf; ENDIF;
    IF ( GET_INFO( bwnd, "TYPE" ) = WINDOW ) THEN
      IF ( wmap ) THEN
        MAP( bwnd, GV$_B );
        POSITION( bwnd );
      ENDIF;
      IF ( GET_INFO( bwnd, "STATUS_LINE" ) <> 0 ) THEN !window has status-line?
        P$SetStat( "C", bwnd );
        P$Status( bwnd );
      ENDIF;
    ENDIF;
    IF ( GV$_MBuf = 0 ) AND ( NOT sys ) THEN
      GV$_MBuf := GET_INFO( GV$_B, "NAME" );  !"Main" is 1st user-buffer loaded
    ENDIF;
    GV$_flipR := 0;     !forget flip-range
  ELSE GV$_B := FALSE;  !create-buffer failure
  ENDIF;
  RETURN( GV$_B );      !which is CURRENT_BUFFER
ENDPROCEDURE  !F$CreateBuf

PROCEDURE P$ClrMsg
  IF NOT( GV$_debug ) THEN
    ERASE( TPU$X_MESSAGE_BUFFER );
    UPDATE( $$MESSAGE_WINDOW );
  ENDIF;
ENDPROCEDURE  !P$ClrMsg

PROCEDURE P$Cycle( dir; opt )
LOCAL buf, ver;
  ver := F$Default( opt, "U", UNSPECIFIED, TRUE );
  buf := GET_INFO( BUFFERS, "CURRENT" );
  LOOP
    IF ( dir = FORWARD ) THEN
      buf := GET_INFO( BUFFERS, "NEXT" );
      IF ( buf = 0 ) THEN buf := GET_INFO( BUFFERS, "FIRST" ); ENDIF;
    ELSE buf := GET_INFO( BUFFERS, "PREVIOUS" );
         IF ( buf = 0 ) THEN buf := GET_INFO( BUFFERS, "LAST" ); ENDIF;
    ENDIF;
    EXITIF ( NOT ( GET_INFO( buf, "SYSTEM" ) ) ); !skip all system buffers
    ENDLOOP;
  IF ( buf <> 0 ) THEN
    P$RememberBuf( ver );
    MAP( CURRENT_WINDOW, buf );
    POSITION( CURRENT_WINDOW );
    GV$_flipR := 0;    !forget flip-range
  ELSE P$Post( K$NLB_msg );
  ENDIF;
ENDPROCEDURE  !P$Cycle

PROCEDURE P$DropRange( tbuf, rng )
  !If range is defined, and then it's also "in" tbuf,
  ! then undefine that range:
  IF ( GET_INFO( rng, "TYPE" ) = RANGE ) THEN
    IF ( GET_INFO( rng, "BUFFER" ) = tbuf ) THEN
      rng := TPU$K_UNSPECIFIED;
    ENDIF;  
  ENDIF;  
ENDPROCEDURE  !P$DropRange

PROCEDURE P$DropBuffer
LOCAL nam, buf;
  buf := CURRENT_BUFFER;
  nam := GV$_BufName{buf};
  IF ( NOT GET_INFO( buf, "PERMANENT" ) ) THEN
    IF ( GET_INFO( buf, "MODIFIED" ) )
    AND ( NOT GET_INFO( buf, "NO_WRITE" ) ) THEN
      IF ( F$Prompt( "Save contents before dropping `" + nam + "' buffer",
                     "Y", "DFU", FALSE ) = "Y" ) THEN
        F$Output( "A", FALSE );
      ENDIF;
    ENDIF;
    P$Cycle( FORWARD, FALSE );
    IF ( buf <> CURRENT_BUFFER ) THEN
      !Be sure we're not just back where we started, i.e., one-&-last buffer!
      !...then undo any ranges lingering in the buffer to delete:
      P$DropRange( buf, GV$_flipR );
      P$DropRange( buf, GV$_SelectRng );
      P$DropRange( buf, GV$_SelectRngStart );
      P$DropRange( buf, GV$_RngA );
      P$DropRange( buf, GV$_RngB );
      P$DropRange( buf, GV$_LSErng );
      GV$_BufName{buf}  := TPU$K_UNSPECIFIED;
      GV$_LastMark{buf} := TPU$K_UNSPECIFIED;
      DELETE( buf );
      MESSAGE( "Buffer `" + nam + "' has been deleted" );
    ELSE MESSAGE( "Cannot delete the last remaining buffer" );
    ENDIF;
  ELSE P$Post( "Buffer `" + nam + "' is PERMANENT and cannot be deleted" );
  ENDIF;
ENDPROCEDURE  !P$DropBuffer

PROCEDURE P$Erase
LOCAL nam;
  nam := GET_INFO( CURRENT_BUFFER, "NAME" );
  IF ( nam = '$$DCL' )                  ! Clear DCL-Buffer and
  OR ( nam = 'TPU$X_MESSAGE' ) THEN     ! Message Window without asking...
    ERASE( CURRENT_BUFFER );
  ELSE IF ( F$Prompt( "Erase `" + nam + "' buffer",
                      "N", "DFU", FALSE ) = "Y" ) THEN
         ERASE( CURRENT_BUFFER );
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Erase

PROCEDURE F$FindBuf( bnam; options )
LOCAL nam, opt, fnt, sys, exct, ptr;
  opt := F$Default( options, "U", STRING, NULL );
  nam := CHANGE_CASE( bnam, UPPER, NOT_IN_PLACE );
  ptr := GET_INFO( BUFFERS, "FIND_BUFFER", nam );
  IF ( INDEX( opt, "X" ) > 0 ) THEN     !find eXactly this buffer name?
    RETURN( ptr );
  ENDIF;
  sys := ( INDEX( opt, "S" ) > 0 );     !find a System buffer?
  IF ( ptr <> 0 ) THEN
    IF ( GET_INFO( ptr, "SYSTEM" ) AND ( NOT sys ) ) THEN
      RETURN( 0 );  ! "sys = FALSE" means skip System buffers
    ENDIF;
  ENDIF;
  fnt := FILE_PARSE( nam, NULL, NULL, NAME, TYPE );
  IF ( ptr <> 0 ) AND ( NOT sys ) THEN
    IF  ( F$GetNT( ptr, "FILE_NAME" )   <> fnt )
    AND ( F$GetNT( ptr, "OUTPUT_FILE" ) <> fnt ) THEN
      ptr := GET_INFO( BUFFERS, "FIRST" );
      LOOP
        EXITIF ( ptr = 0 );
        EXITIF ( ( F$GetNT( ptr, "FILE_NAME" )   = fnt )
            OR   ( F$GetNT( ptr, "OUTPUT_FILE" ) = fnt ) );
        ptr := GET_INFO( BUFFERS, "NEXT" );
        ENDLOOP;
    ENDIF;
  ENDIF;
  RETURN( ptr );
ENDPROCEDURE  !F$FindBuf

PROCEDURE P$FindBuf
LOCAL n, fn, buf, abuf, tbuf, twin;
  fn := F$Prompt( "Filename for buffer", NULL, "UD", FALSE );
  IF ( fn = NULL ) THEN RETURN; ENDIF;
  buf := FILE_PARSE( fn, NULL, NULL, NAME );
  tbuf := F$FindBuf( fn );
  IF ( tbuf <> 0 ) THEN P$SetBuf( tbuf );
  ELSE IF ( SUBSTR( F$Prompt( "New `" + FILE_PARSE( fn ) + "'",
                               "Y", "DFU", FALSE ),
                    1, 1 ) = "N" ) THEN RETURN;
       ELSE n := 0;
            abuf := buf;
            LOOP
              tbuf := F$CreateBuf( "EJW" + GV$_insovr, abuf,
                                   CURRENT_WINDOW, , fn );
              EXITIF ( tbuf <> 0 ) OR ( n >= K$MaxFiles );
              n := n + 1;
              abuf := buf + "_" + STR( n );
              ENDLOOP;
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$FindBuf

PROCEDURE P$Last( buf )
LOCAL tbuf;
  IF ( GET_INFO( buf, "TYPE" ) = STRING ) THEN
    tbuf := F$FindBuf( buf, "X" );
    IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) <> buf ) THEN
      P$SetBuf( tbuf );
    ENDIF;
  ELSE P$Post( K$NLB_msg );
  ENDIF;
ENDPROCEDURE  !P$Last

PROCEDURE P$Post( msg )
  IF NOT ( GV$_debug ) THEN P$ClrMsg; ENDIF;
  MESSAGE( msg );
ENDPROCEDURE  !P$Post

PROCEDURE P$RememberBuf( ;opt )
LOCAL ver;
  ver := F$Default( opt, "U", UNSPECIFIED, TRUE );
  P$SwapMsg ( TRUE );
  IF ( NOT GET_INFO( CURRENT_BUFFER, "SYSTEM" ) ) THEN
    GV$_Lbuf := GET_INFO( CURRENT_BUFFER, "NAME" );
    IF ( ver ) THEN MESSAGE( "Last buffer: !AS", 0, GV$_Lbuf ); ENDIF;
  ENDIF;
ENDPROCEDURE  !P$RememberBuf

PROCEDURE P$RenameBuf( buf )
LOCAL fnam, bnam, bout;
  bout := GET_INFO( buf, "OUTPUT_FILE" );  !...the whole filespec
  fnam := FILE_PARSE( bout, NULL, NULL, NAME, TYPE );
  IF ( fnam = K$period ) THEN fnam := F$GetNT( buf, "FILE_NAME" ); ENDIF;
  bnam := F$Prompt( "New name for current buffer", fnam, "DNU", FALSE );
  IF ( bnam <> NULL ) THEN
    IF ( bnam = "*" ) THEN  !(re)set this buffer's name to its output filename
      bnam := fnam;
    ENDIF;
    GV$_BufName{buf} := bnam;    !set this buffer's name to user's choice
    bout := FILE_PARSE( bnam, bout, K$dfspec );
    SET( OUTPUT_FILE, buf, bout );
    bnam := "[End " + bnam + "]";
    SET( EOB_TEXT, buf, bnam );
    P$Status( CURRENT_WINDOW );
  ENDIF;
ENDPROCEDURE  !P$RenameBuf

PROCEDURE P$SetDir( dir, tbuf )
  IF ( GET_INFO( tbuf, "DIRECTION" ) <> dir ) THEN
    SET( dir, tbuf );
    P$Status( CURRENT_WINDOW );
  ENDIF;
  GV$_flipR := 0;  !forget flip-range
ENDPROCEDURE  !P$SetDir

PROCEDURE P$SetBuf( buf )
LOCAL bnam;
  IF ( CURRENT_WINDOW = TPU$X_SHOW_WINDOW ) THEN
    UNMAP( TPU$X_SHOW_WINDOW );
  ENDIF;
  IF ( GET_INFO( GV$_Lbuf, "TYPE" ) = STRING ) THEN  !TPU$init Gate
    P$RememberBuf;
  ENDIF;
  IF ( GET_INFO( buf, "TYPE" ) = BUFFER ) THEN
    GV$_B := buf;
    bnam := NULL;
  ELSE GV$_B := F$FindBuf( buf );
       bnam := buf;
  ENDIF;
  IF ( GET_INFO( GV$_B, "TYPE" ) = BUFFER ) THEN
    MAP( CURRENT_WINDOW, GV$_B );
    IF ( GV$_B = $$LIST_BUFFER ) THEN
      POSITION( BEGINNING_OF( GV$_B ) );
    ELSE POSITION( GV$_B );
    ENDIF;
  ELSE MESSAGE ( "No such buffer `" + bnam + "'" );
  ENDIF;
  P$ChkRuler( TRUE );
  P$Status( CURRENT_WINDOW );
  GV$_flipR := 0;  !forget flip-range
ENDPROCEDURE  !P$SetBuf

PROCEDURE P$SetStat( arg, cw )
LOCAL top, bot;
  GV$_statdisp := F$Default( arg, "<>", STRING, "C" );
  GV$_updstat  := ( GV$_statdisp = "PA" );
  IF ( SUBSTR( GV$_statdisp, 1, 1 ) = "P" )
  OR ( GET_INFO( cw, "ORIGINAL_LENGTH" ) < 8 ) THEN
    top := 0;  bot := 0;
  ELSE top := 3;  bot := 4;
  ENDIF;
  P$SwapMsg( TRUE );
  SET( SCROLLING, cw, ON, top, bot, 0 );
ENDPROCEDURE  !P$SetStat

PROCEDURE P$Status( Wnd )
LOCAL Buf, Txt, dir, rw, tm, tran, mode, fnam, spc, wth, clk;
ON_ERROR
  MESSAGE( "Status line update error" );
  P$Last( GV$_MBuf );
  P$0; ABORT;
ENDON_ERROR
  IF ( GET_INFO( Wnd, "TYPE") <> WINDOW ) THEN RETURN; ENDIF;
  IF ( Wnd = $$LEGEND_WINDOW ) THEN
    SET( STATUS_LINE, $$LEGEND_WINDOW, NONE, NULL ); !NULL turns OFF Stat-Line
    RETURN;
  ENDIF;
  Buf := GET_INFO( Wnd, "BUFFER" );
  IF ( GET_INFO( Buf, "TYPE") <> BUFFER ) THEN RETURN; ENDIF;
  IF ( INDEX( K$nostat, K$period + GET_INFO( Buf, "NAME" ) + K$period ) > 0 ) THEN
    RETURN;
  ENDIF;
  IF ( GET_INFO( Buf, "MODE" ) = INSERT ) THEN mode := "i";
  ELSE mode := "o"; ENDIF;
  IF ( GET_INFO( Buf, "DIRECTION" ) = FORWARD ) THEN dir := "v>";
  ELSE dir := "<^"; ENDIF;
  IF ( GET_INFO( Buf, "NO_WRITE" ) ) THEN rw := "ro";
  ELSE IF ( GET_INFO( Buf, "MODIFIED" )
       AND ( GET_INFO( GV$_ruRngB, "TYPE" ) <> RANGE ) ) THEN
         rw := "RW";
       ELSE rw := "rw";
       ENDIF;
  ENDIF;
  tm := GET_INFO( CURRENT_WINDOW, "TEXT" ); tran := K$spc;
  IF ( tm = NO_TRANSLATE ) THEN tran := "¹"; ENDIF;
  IF ( tm = GRAPHIC_TABS ) THEN tran := "²"; ENDIF;
  fnam := GV$_BufName{Buf};
  IF ( fnam = K$period ) OR ( fnam = NULL ) THEN
    fnam := "file: (none)";
  ELSE fnam := "file: " + fnam;
  ENDIF;
  Txt := FAO( "!AS -!AS- !AS [!AS]!AS !AS",
              SUBSTR( "   ¨  ¨¨ ¨¨¨", 1 + ( GV$_shftc * 3 ), 3 ),
              mode, dir, rw, tran, fnam );
  IF ( GV$_statdisp <> NULL ) THEN
    CASE SUBSTR( GV$_statdisp, 1, 1 ) FROM "C" TO "P"
      ["C"]: ! Clock display
             clk := FAO( "!%T", 0 );
             clk := "(" + SUBSTR( clk, 1, INDEX( clk, K$period ) - 1 ) + ")";
      ["P"]: ! Position display
             UPDATE( CURRENT_WINDOW );
             clk := FAO( "[!ZL,!ZL]",
                         GET_INFO ( CURRENT_WINDOW, "CURRENT_ROW" ),
                         GET_INFO ( CURRENT_BUFFER, "OFFSET_COLUMN" ) );
      ENDCASE;
    spc := LENGTH( Txt ) + LENGTH( clk ) + LENGTH( GV$UserSLData ) + 1;
    wth := GET_INFO( CURRENT_WINDOW, "WIDTH" ) - 1;    !"-1" because of <si>
    IF ( spc < wth ) THEN
      spc := SUBSTR( K$spaces, 1, wth - spc );
    ELSE spc := NULL; clk := NULL; ENDIF;
    Txt := FAO( "!4(AS) !AS!AS", K$si, Txt, spc, GV$UserSLData, clk, K$si ); !<si> guards SL-text
    SET( STATUS_LINE, Wnd, BOLD, Txt );
  ENDIF;
ENDPROCEDURE  !P$Status

PROCEDURE P$SwapMsg( test )
  IF ( test ) AND ( CURRENT_WINDOW <> $$MESSAGE_WINDOW ) THEN RETURN; ENDIF;
  IF ( CURRENT_WINDOW = $$MESSAGE_WINDOW ) THEN
    POSITION( GV$_LastWin );
    GV$_LastWin := $$MESSAGE_WINDOW;
  ELSE GV$_LastWin := CURRENT_WINDOW;
    GV$_CurWin := CURRENT_WINDOW;
    P$0;
    POSITION( $$MESSAGE_WINDOW );
  ENDIF;
ENDPROCEDURE  !P$SwapMsg

PROCEDURE P$Map1
LOCAL i, opos;
  P$0;
  IF ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY ) THEN
    opos := MARK( NONE );  !cursor goes back to current buffer
    P$SwapMsg( TRUE );
    i := GET_INFO( GV$_MWin, "FIRST" );
    LOOP
      EXITIF ( i = TPU$K_UNSPECIFIED );
      IF ( GET_INFO( GV$_MWin{i}, "TYPE" ) = WINDOW ) THEN
        UNMAP( GV$_MWin{i} );
      ENDIF;
      i := GET_INFO( GV$_MWin, "NEXT" );
      ENDLOOP;
    IF ( GET_INFO( $$LEGEND_WINDOW, "TYPE" ) = WINDOW ) THEN
      P$RAPTsetup;  !reset RAPT key legends
    ENDIF;
    POSITION( opos );
    MAP( $$1_WINDOW, CURRENT_BUFFER );
    GV$_CurWin := CURRENT_WINDOW;
    DELETE( GV$_MWin );  !bag the array
    GV$_MWin := 0;       !...indicate no split-windows
  ENDIF;
ENDPROCEDURE  !P$Map1

PROCEDURE P$MapN
  IF ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY ) THEN
    P$Map1;
  ELSE P$MapWin( INT( F$Prompt( "Number of windows", "3", "D", FALSE ) ) );
  ENDIF;
ENDPROCEDURE  !P$MapN

PROCEDURE P$MapWin( arg1; opt1 )
LOCAL i, nwin, ssiz, wlen, llen, spos, buf, restore1;
  P$0;
  restore1 := F$Default( opt1, "U", UNSPECIFIED, TRUE );
  IF ( restore1 ) AND ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY ) THEN
    P$Map1;
  ELSE IF ( GET_INFO( arg1, "TYPE" ) = BUFFER  ) THEN
      buf := arg1;
    ELSE buf := CURRENT_BUFFER;  !default
    ENDIF;
    nwin := 2;  !default
    IF ( GET_INFO( arg1, "TYPE" ) = INTEGER ) THEN
      IF ( arg1 > 2 ) THEN nwin := arg1; ENDIF;
    ENDIF;
    GV$_MWin := CREATE_ARRAY( nwin );
    ! Discover if N windows fit ``evenly'' on available screen space:
    ssiz := GV$_screen - 2;  !Total length minus room for Message Window
    LOOP
      wlen := ssiz / nwin;   !Division with truncation
      EXITIF ( wlen >= 7 );  !Arbitrary limit: No window smaller than 7 lines
      nwin := nwin - 1;
      IF ( nwin < 2 ) THEN RETURN; ENDIF;
      ENDLOOP;
    IF ( ( wlen * nwin ) < ssiz ) THEN     !Even fit?
      llen := ssiz - wlen * ( nwin - 1 );  !No, last gets biggest...
    ELSE llen := wlen;                     !Yes...
    ENDIF;
    i := 1;
    LOOP
      EXITIF ( i > nwin );
      spos := ( ( i - 1 ) * wlen ) + 1;
      IF ( i = nwin ) THEN wlen := llen; ENDIF;  !Last gets biggest...
      GV$_MWin{i} := CREATE_WINDOW( spos, wlen, ON );
      P$SetStat( GV$_statdisp, GV$_MWin{i} );
      MAP( GV$_MWin{i}, buf );
      P$Status( GV$_MWin{i} );
      i := i + 1;
      ENDLOOP;
    POSITION( GV$_MWin{1} );
    UPDATE( CURRENT_WINDOW );
    GV$_CurWin := CURRENT_WINDOW;
    IF ( GET_INFO( $$LEGEND_WINDOW, "TYPE" ) = WINDOW ) THEN
      P$RAPTsetup;  !reset RAPT key legends
    ENDIF;
  ENDIF;
  GV$_flipR := 0;    !forget flip-range
ENDPROCEDURE  !P$MapWin

PROCEDURE P$SwapWin( dr )
LOCAL i, hi, lo, dir;
  P$0;
  IF ( CURRENT_WINDOW = $$MESSAGE_WINDOW ) THEN
    POSITION( GV$_LastWin );
    GV$_LastWin := $$MESSAGE_WINDOW;
    RETURN;
  ENDIF;
  IF ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY ) THEN
    IF ( dr <> 1 ) THEN dir := -1; ELSE dir := +1 ENDIF;
    hi := GET_INFO( GV$_MWin, "LOW_INDEX" );
    lo  := GET_INFO( GV$_MWin, "HIGH_INDEX" );
    IF ( dir = -1 ) THEN i := lo;
    ELSE i := hi;
    ENDIF;
    LOOP
      EXITIF ( i = TPU$K_UNSPECIFIED );
      EXITIF ( GV$_MWin{i} = CURRENT_WINDOW );
      i := i + dir;
      ENDLOOP;
    IF ( i = TPU$K_UNSPECIFIED ) THEN P$Map1;
    ELSE IF ( dir = -1 ) THEN
           IF ( i = hi ) THEN POSITION( GV$_MWin{lo} );
           ELSE POSITION( GV$_MWin{i-1} );
           ENDIF;
         ELSE IF ( i = lo ) THEN POSITION( GV$_MWin{hi} );
              ELSE POSITION( GV$_MWin{i+1} );
              ENDIF;
         ENDIF;
    ENDIF;
  ENDIF;
  GV$_CurWin := CURRENT_WINDOW;
ENDPROCEDURE  !P$SwapWin


! === CUT/PASTE === !

PROCEDURE F$OnRange( Rng )
LOCAL OnTar;
  OnTar := FALSE;
  IF ( GET_INFO( Rng, "TYPE" ) = RANGE ) THEN
    IF ( GV$_srchbeg ) THEN
      OnTar := ( MARK( NONE ) = BEGINNING_OF( Rng ) );
    ELSE MOVE_HORIZONTAL( -1 );
         OnTar := ( MARK( NONE ) = END_OF( Rng ) );
         MOVE_HORIZONTAL( +1 );
    ENDIF;
  ENDIF;
  RETURN( OnTar );
ENDPROCEDURE  !F$OnRange

PROCEDURE F$CheckOnRange( Rng, PName )
LOCAL OnTar;
  OnTar := F$OnRange( Rng );
  IF ( GET_INFO( Rng, "TYPE" ) <> RANGE ) THEN
    MESSAGE( K$NSA_msg, 0, PName );
    RETURN( FALSE );
  ENDIF;
  IF NOT OnTar THEN
    MESSAGE( "Cursor is not on Target-Range (!AS)", 0, PName );
    UPDATE( ALL );
  ENDIF;
  Return( OnTar );
ENDPROCEDURE  !F$CheckOnRange

PROCEDURE P$Append( PasteBuf, Func )
LOCAL win, buf;
  ! Func: 0 = Append (KP9), 1 = Cut (KP6), 2 = Copy (Gold/Ctrl-F)
  IF ( GV$_SelectRng = 0 ) THEN    !GV$_SelectRng set by Mouse-Button?
    P$SelectRange;                 !no, finish the Select
  ENDIF;
  ! Cannot use F$CheckOnRange() here:
  IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE ) THEN
    win  := CURRENT_WINDOW;
    buf  := CURRENT_BUFFER;
    ! --- In the target paste-buffer ($$PASTE_BUFFER, etc.): ---
    POSITION( END_OF( PasteBuf ) );
    IF ( Func > 0 ) THEN  !Cut or Copy
      ERASE( PasteBuf );
      SPLIT_LINE;
    ENDIF;
    IF ( NOT F$atBOB ) THEN MOVE_HORIZONTAL( -1 ); ENDIF;
    IF ( Func = 2 ) THEN
      COPY_TEXT( GV$_SelectRng );     !Copy
    ELSE MOVE_TEXT( GV$_SelectRng );  !Cut or Append
    ENDIF;
    ! --- Back to user's buffer: ---
    MAP( win, buf );
    P$Status( win );
    P$Reset;
  ELSE MESSAGE( K$NSA_msg, 0, "P$Append" );
  ENDIF;
ENDPROCEDURE  !P$Append

PROCEDURE P$Paste( buf )
  IF ( GET_INFO( GV$_ruRngB, "TYPE" ) = RANGE ) THEN
    P$SetRuler( GV$_ruler );
  ELSE IF ( BEGINNING_OF( buf ) <> END_OF( buf ) ) THEN
         SET( TIMER, ON, "working..." );
         P$Insert( buf );
         APPEND_LINE;
         SET( TIMER, OFF, NULL );
       ENDIF;
  ENDIF;
  P$Status( CURRENT_WINDOW );
ENDPROCEDURE  !P$Paste

PROCEDURE P$Select
  IF ( GV$_SelectRngStart <> 0 ) THEN
    MESSAGE( "Select is active" );
  ELSE P$Reset;
       GV$_SelectRngStart := SELECT( REVERSE );
  ENDIF;
ENDPROCEDURE  !P$Select

PROCEDURE P$SelectRange
LOCAL here, selbuf;
  ! Work in the right buffer, esp. if searching for tar-strg from another buffer
  here := MARK( NONE );
  IF ( GV$_SelectRngStart <> 0 ) THEN
    selbuf := GET_INFO( GV$_SelectRngStart, "BUFFER" );
  ELSE selbuf := 0;
  ENDIF;
  IF ( GET_INFO( here, "BUFFER" ) <> selbuf ) THEN POSITION( selbuf ); ENDIF;
  IF ( GV$_SelectRngStart <> 0 ) THEN
    GV$_SelectRng := SELECT_RANGE;
    IF ( GV$_SelectRng = 0 ) THEN
      POSITION( END_OF( CURRENT_BUFFER ) );
      GV$_SelectRng := CREATE_RANGE( MARK( NONE ), MARK( NONE ), NONE );
      POSITION( GV$_SelectRngStart );
    ENDIF;
    GV$_SelectRngStart := 0;
  ELSE IF ( GET_INFO( GV$_SearchRng, "TYPE" ) = RANGE ) THEN
         ! This lets P$Ccase work on "the char it's on", not a previous SR:
         IF ( F$OnRange( GV$_SearchRng ) ) THEN
           GV$_SelectRng := GV$_SearchRng;
         ELSE GV$_SelectRng := 0;
         ENDIF;
       ENDIF;
  ENDIF;
  IF ( MARK( NONE ) <> here ) THEN POSITION( here ); ENDIF;
ENDPROCEDURE  !P$SelectRange

PROCEDURE P$MouseSelect
  IF ( GV$_SelectRngStart <> 0 ) THEN MESSAGE( "Select is active" );
  ELSE POSITION( MOUSE );
       GV$_MBU_mark := MARK( NONE );     !Mouse-Button Up
       P$ChkRuler;
       IF ( GV$_MBD_mark <> GV$_MBU_mark ) THEN
         GV$_SelectRng := CREATE_RANGE( GV$_MBD_mark, GV$_MBU_mark, REVERSE );
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$MouseSelect

PROCEDURE P$doFindReplace
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF F$CheckOnRange( GV$_SearchRng, "P$doFindReplace" ) THEN
    GV$_delstr := STR( GV$_SearchRng );
    ERASE( GV$_SearchRng );
    P$Paste( $$PASTE_BUFFER );
    GV$_SelectRng  := 0;
    GV$_flipR := 0;
  ENDIF;
ENDPROCEDURE  !P$doFindReplace

PROCEDURE P$Replace
  P$SelectRange;
  IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE )
  AND ( F$CheckOnRange( GV$_SearchRng, "P$Replace" ) ) THEN
    P$doFindReplace;
  ENDIF;
ENDPROCEDURE  !P$Replace

PROCEDURE P$Substitute
  IF ( F$CheckOnRange( GV$_SearchRng, "P$Substitute" ) ) THEN
    P$doFindReplace;
    P$STarget( F$Bump, GV$_srchtar );
    GV$_SearchRng := F$UlSearch( GV$_SearchRng );
    IF ( GV$_srchbeg ) THEN POSITION( BEGINNING_OF( GV$_SearchRng ) );
    ELSE POSITION( END_OF( GV$_SearchRng ) );
         MOVE_HORIZONTAL( +1 );
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Substitute


! === DCL === !

!(retired): PROCEDURE P$Attach
!(retired): LOCAL pn;
!(retired): ON_ERROR
!(retired):   P$Post( "Nonexistent process `" + pn + "'" );
!(retired): ENDON_ERROR
!(retired):   pn := F$Prompt( "Process name", NULL, NULL, TRUE );
!(retired):   IF ( pn = NULL ) THEN ATTACH;  !parent
!(retired):   ELSE ATTACH( pn );             !subprocess
!(retired):   ENDIF;
!(retired): ENDPROCEDURE  !P$Attach

PROCEDURE F$DCLcommand
LOCAL cmd, spat, epat, sr;
ON_ERROR
[TPU$_STRNOTFOUND]:
  POSITION( END_OF( CURRENT_BUFFER ) );
[TPU$_CONTROLC,
 TPU$_ENDOFBUF,
 OTHERWISE]: RETURN( 0 );
ENDON_ERROR
  IF ( GV$_SelectRngStart <> 0 ) THEN
    P$SelectRange;
    cmd := GV$_SelectRng;
  ELSE spat := LINE_BEGIN + K$DCL;
    epat := LINE_END + LINE_BEGIN + ( SPAN( K$spc_tab ) | NULL )
          + LINE_END + LINE_BEGIN;
    sr := SEARCH( spat, REVERSE );
    IF ( sr <> 0) THEN POSITION( BEGINNING_OF( sr ) );
    ELSE P$BOL;
    ENDIF;
    GV$_SelectRngStart := SELECT( BOLD );
    MOVE_HORIZONTAL( +1 );
    sr := SEARCH( epat, FORWARD );
    IF ( sr <> 0 ) THEN
      POSITION( END_OF( sr ) );
      P$MoveL( FORWARD );
    ENDIF;
    IF F$Anchored( K$DCL, NO_EXACT ) THEN P$BOL; ENDIF;
    cmd := SELECT_RANGE;
    P$MoveL( FORWARD );
  ENDIF;
  P$Reset;
  IF ( GV$_debug ) THEN
    MESSAGE( "DCL cmd: `" + STR( cmd ) + "'" );
  ENDIF;
  RETURN( cmd );
ENDPROCEDURE  !F$DCLcommand

PROCEDURE P$DCLcreate( ; creprc )
LOCAL create;
ON_ERROR
[TPU$_CREATEFAIL]:
  MESSAGE( "DCL subprocess could not be created" );
ENDON_ERROR;
  create := F$Default( creprc, "U", UNSPECIFIED, TRUE );
  IF ( $$DCL_BUFFER = 0 ) THEN
    P$RememberBuf;
    $$DCL_BUFFER := F$CreateBuf( "EIRPSW", K$DCLbuf, CURRENT_WINDOW );
  ELSE P$SetBuf( $$DCL_BUFFER );
  ENDIF;
  IF ( create ) THEN
    GV$_DCLpid := CREATE_PROCESS( $$DCL_BUFFER );
  ENDIF;
ENDPROCEDURE  !P$DCLcreate

PROCEDURE P$DCL
  IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) <> K$DCLbuf ) THEN
    IF ( $$DCL_BUFFER = 0 ) THEN
      MESSAGE( "Creating DCL subprocess..." );
      P$DCLcreate;
    ELSE P$SetBuf( $$DCL_BUFFER );
    ENDIF;
  ELSE GV$_DCLr := F$DCLcommand;
    IF ( GV$_DCLr <> 0 ) THEN
      POSITION( END_OF( CURRENT_BUFFER ) );
      SPLIT_LINE;
      COPY_TEXT( GV$_DCLr );
      P$MoveL( FORWARD );
      P$DCLsend( GV$_DCLr );
      GV$_DCLr := 0;
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$DCL

PROCEDURE P$DCLsend( cmd )
LOCAL buf, here;
ON_ERROR
[TPU$_NOPROCESS,
 TPU$_INVPARAM]:
  GV$_DCLpid := NULL;
ENDON_ERROR;
  buf := CURRENT_BUFFER;
  here := MARK( NONE );
  SET( TIMER, ON, "DCL working..." );
  IF ( GV$_DCLpid = NULL ) THEN
    P$DCLcreate;
  ENDIF;
  SEND( cmd, GV$_DCLpid );
  IF ( buf = $$DCL_BUFFER ) THEN
    POSITION( END_OF( $$DCL_BUFFER ) );
  ELSE P$JumpMark( here, NULL );
  ENDIF;
  SET( TIMER, OFF, NULL );
ENDPROCEDURE  !P$DCLsend


! === DELETE/UNDELETE === !

PROCEDURE P$Del_C( DelKey )
LOCAL tlin;
  GV$_SearchRng := 0;
  P$SelectRange;
  IF ( DelKey ) AND ( GV$_SelectRng <> 0 ) THEN
    !This behavior *only* applies to the PC-keyboard's <Delete> key,
    ! not to <X|, <Backspace>, <KP+>, <KP-> or <KP,>!
    P$Append( $$DELETE_BUFFER, 1 );
    GV$_delchar := 0;
  ELSE IF ( F$atEOB ) THEN RETURN; ENDIF;
    GV$_RngA := 0;
    GV$_RngB := 0;
    GV$_delchar := ERASE_CHARACTER( 1 );
    IF ( GV$_delchar = NULL ) THEN
      GV$_delchar := K$lf;
      tlin := CURRENT_LINE;
      MOVE_HORIZONTAL( +1 );
      IF ( NOT F$atEOB ) OR ( LENGTH( tlin ) = 0 ) THEN
        APPEND_LINE;
      ELSE MOVE_HORIZONTAL( -1 );
      ENDIF;
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Del_C

PROCEDURE P$Undel_C
  GV$_SearchRng := 0;
  IF ( GET_INFO( GV$_delchar, "TYPE" ) = STRING ) THEN
    IF ( GV$_delchar <> K$lf ) THEN
      P$Insert( GV$_delchar );
    ELSE SPLIT_LINE;
    ENDIF;
    IF ( CURRENT_DIRECTION = REVERSE ) THEN
      MOVE_HORIZONTAL( -1 );
    ENDIF;
  ELSE IF ( GV$_delchar = 0 ) THEN
         P$Paste( $$DELETE_BUFFER );
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Undel_C

PROCEDURE P$Del_BOW
LOCAL mrk, rng;
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( CURRENT_OFFSET > 0 ) THEN
    MOVE_HORIZONTAL( -1 );
    mrk := MARK( NONE );
    P$MoveWRev( GV$_wordel );
    rng := CREATE_RANGE( mrk, MARK( NONE ), NONE );
    GV$_delword := STR( rng );
    ERASE( rng );
  ELSE IF ( F$atEOB ) THEN MOVE_HORIZONTAL( -1 );
       ELSE APPEND_LINE;
       ENDIF;
       GV$_delword := K$lf;
  ENDIF;
ENDPROCEDURE  !P$Del_BOW

PROCEDURE P$Del_EOW
LOCAL mrk, rng;
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( NOT F$atEOL ) THEN
    mrk := MARK( NONE );
    P$MoveWFor( GV$_wordel );
    MOVE_HORIZONTAL( -1 );
    rng := CREATE_RANGE( mrk, MARK( NONE ), NONE );
    GV$_delword := STR( rng );
    ERASE( rng );
  ELSE IF ( NOT F$atEOB ) THEN
         MOVE_HORIZONTAL( +1 );
         IF ( NOT F$atEOB ) THEN APPEND_LINE;
         ELSE MOVE_HORIZONTAL( -1 );
         ENDIF;
       ENDIF;
       GV$_delword := K$lf;
  ENDIF;
ENDPROCEDURE  !P$Del_EOW

PROCEDURE P$Undel_W
  GV$_SearchRng := 0;
  IF ( GV$_delword <> K$lf ) THEN
    IF ( SUBSTR( GV$_delword, 1, 1 ) = K$lf ) THEN
      SPLIT_LINE;
      P$Insert( SUBSTR( GV$_delword, 2, LENGTH( GV$_delword ) - 1 ) );
    ELSE P$Insert( GV$_delword );
    ENDIF;
    IF ( CURRENT_DIRECTION = REVERSE ) THEN
      MOVE_HORIZONTAL( -LENGTH( GV$_delword ) );
    ENDIF;
  ELSE SPLIT_LINE;
    MOVE_HORIZONTAL( -1 );
  ENDIF;
ENDPROCEDURE  !P$Undel_W

PROCEDURE P$Del_BOL
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  GV$_delline := ERASE_CHARACTER( -CURRENT_OFFSET );
  IF ( GV$_delline = NULL ) THEN
    IF ( NOT F$atBOB ) THEN
      MOVE_VERTICAL( -1 );
      P$Del_L;
    ENDIF;
  ENDIF;
  GV$_delcrlf := FALSE;
  GV$_appline := FALSE;
ENDPROCEDURE  !P$Del_BOL

PROCEDURE P$Del_EOL
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( F$atEOL ) THEN
    MOVE_VERTICAL( +1 );
    IF ( NOT F$atEOB ) THEN
      POSITION( LINE_BEGIN );
      GV$_delline := ERASE_LINE;
      GV$_appline := TRUE;
      GV$_delcrlf := FALSE;
    ELSE GV$_appline := FALSE;
      GV$_delcrlf := TRUE;
    ENDIF;
    MOVE_HORIZONTAL( -1 );
  ELSE GV$_delline := ERASE_CHARACTER( LENGTH( CURRENT_LINE ) );
    GV$_appline := FALSE;
    GV$_delcrlf := FALSE;
  ENDIF;
ENDPROCEDURE  !P$Del_EOL

PROCEDURE P$Del_L
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( CURRENT_OFFSET = 0 ) THEN GV$_delline := ERASE_LINE;
  ELSE GV$_delline := ERASE_CHARACTER( LENGTH( CURRENT_LINE ) );
    MOVE_HORIZONTAL( -CURRENT_OFFSET );
    MOVE_VERTICAL( +1 );
    IF ( NOT F$atEOB ) THEN APPEND_LINE;
    ELSE MOVE_HORIZONTAL( -1 );
    ENDIF;
  ENDIF;
  GV$_delcrlf := TRUE;
  GV$_appline := FALSE;
ENDPROCEDURE  !P$Del_L

PROCEDURE P$Undel_L
LOCAL tlen;
  GV$_SearchRng := 0;
  IF ( GV$_appline ) THEN
    SPLIT_LINE;
    COPY_TEXT( GV$_delline );
    MOVE_HORIZONTAL( -( CURRENT_OFFSET + 1 ) );
  ELSE tlen := LENGTH( GV$_delline );
    IF ( GV$_delcrlf ) AND ( NOT F$atEOB ) THEN
      SPLIT_LINE;
      MOVE_HORIZONTAL( -1 );
    ENDIF;
    COPY_TEXT( GV$_delline );
    MOVE_HORIZONTAL( -tlen );
  ENDIF;
ENDPROCEDURE  !P$Undel_L

PROCEDURE P$Rubout
ON_ERROR
[TPU$_STRNOTFOUND]:
  P$Insert( K$spc );   !not at EOL
  MOVE_HORIZONTAL( -1 );
ENDON_ERROR
  GV$_SearchRng := 0;
  GV$_RngA := 0;
  GV$_RngB := 0;
  GV$_delchar := ERASE_CHARACTER( -1 );
  IF ( GV$_delchar = NULL ) THEN        !can't delete past BOL
    GV$_delchar := K$lf;
    APPEND_LINE;
  ENDIF;
  IF ( GET_INFO( CURRENT_BUFFER, "MODE" ) = OVERSTRIKE ) THEN
    SEARCH( ( ANCHOR + LINE_END ), FORWARD ); !at EOL?
  ENDIF;
ENDPROCEDURE  !P$Rubout


! === EXITS === !

PROCEDURE P$CALLUSER_Error( Err, Pname, Msg )
LOCAL id;
  ! With CALL_USER, expect general VMS error condition codes ("ERROR"):
  id := MESSAGE_TEXT( Err, 2 );         !"2" = msg-flag bit-1 set
  IF ( id = "%NOLOGNAM" ) THEN RETURN;  ! Just ignore this one...
  ELSE  ! Annunciate all others...they're unexpected:
    IF NOT( GV$_debug ) THEN ERASE( TPU$X_MESSAGE_BUFFER ); ENDIF;
    MESSAGE( '!AS/CALL_USER: "!AS"', 0, Pname, Msg );  !"0" = msg-flag clear
    MESSAGE( Err, 15 );                 !"15" = msg-flags bits 0,1,2,3 all set
  ENDIF;
ENDPROCEDURE  !P$CALLUSER_Error

PROCEDURE P$ExitLNM( exitLNM, savebuf; outf, lcnt )
LOCAL junk;
ON_ERROR
  ! NOTE! -- Non-CASE-style error handler required to handle CALL_USER errors.
  ! With CALL_USER, expect general VMS error condition codes ("ERROR"):
  P$CALLUSER_error( ERROR, "P$ExitLNM", junk );
  RETURN;
ENDON_ERROR
  IF ( savebuf ) THEN
    junk := CALL_USER( K$OpCode_Define_LNM,
                       exitLNM                !logical name
                       + K$pilcrow + outf     !outfilespec
                       + K$pilcrow + lcnt );  !line count
  ELSE
    junk := CALL_USER( K$OpCode_Delete_LNM, exitLNM );
  ENDIF;
ENDPROCEDURE  !P$ExitLNM

PROCEDURE P$Bye( Func )
LOCAL savebuf, buf, outf;
  P$0;
  IF ( NOT GV$_QuitPend ) AND ( CURRENT_WINDOW = TPU$X_SHOW_WINDOW ) THEN
    UNMAP( TPU$X_SHOW_WINDOW ); !compensate: just unmap
    RETURN;
  ELSE GV$_RngA := 0;
    GV$_RngB := 0;
    P$ClrMsg;
    IF ( GET_INFO( CURRENT_WINDOW, "TEXT" ) <> BLANK_TABS ) THEN
      SET( TEXT, CURRENT_WINDOW, BLANK_TABS );
    ENDIF;
    CASE Func FROM 0 TO 3
      [K$Exit]:
        SET( MESSAGE_FLAGS, 1 );
        P$RuErase( GV$_ruRngA );
        P$RuErase( GV$_ruRngB );
        IF NOT( GV$_debug ) THEN
          P$ClrMsg;
          IF ( GV$Application = "KED" ) THEN
            ADJUST_WINDOW( $$MESSAGE_WINDOW, -6, 0 ); !becomes current_window
          ENDIF;
        ENDIF;
        UPDATE( ALL );
        !!!SET( TIMER, ON, "exiting..." );
        SET( SUCCESS, ON );
        buf := F$FindBuf( GV$_Mbuf, "X" );
        !Note: Main Buffer might have been deleted, so following is conditional:
        IF ( GET_INFO( buf, "TYPE" ) = BUFFER ) THEN
          savebuf := ( GET_INFO( buf, "MODIFIED" )
                       AND NOT GET_INFO( buf, "NO_WRITE" ) );
          ! Explicitly write "Main buffer" --- trap the exact output filespec
          ! (including ";version") and setup the KED logical name:
          IF ( savebuf ) THEN outf := WRITE_FILE( buf ); ENDIF;
          P$ExitLNM( KED$ExitLNM, savebuf,
                     outf, STR( GET_INFO( buf, "RECORD_COUNT" ) ) );
          ! TPU's built-in will write all other modified/writeable buffers:
        ENDIF;
        EXIT;
      [K$NoFiles]:
        ERASE( TPU$X_SHOW_BUFFER );
        POSITION( TPU$X_SHOW_BUFFER );
        COPY_TEXT( "No file(s) selected for editing..." ); SPLIT_LINE;
        COPY_TEXT( "Exiting to DCL..." ); SPLIT_LINE; SPLIT_LINE;
        COPY_TEXT( K$CTRL_Zq ); SPLIT_LINE;
        SET( STATUS_LINE, TPU$X_SHOW_WINDOW, REVERSE, K$CTRL_Zq );
        MAP( TPU$X_SHOW_WINDOW, TPU$X_SHOW_BUFFER );
        UPDATE( TPU$X_SHOW_WINDOW );
        POSITION ( BEGINNING_OF( TPU$X_SHOW_BUFFER ) );
        GV$_QuitPend := TRUE;
        RETURN;
      [K$Quit]:
        P$ExitLNM( KED$ExitLNM, FALSE );
        QUIT;
      [K$Attach]: !(re)Attaching to parent process
!(retired):         F$Output( "A" );
!(retired):         IF ( GV$_JouMeth = "K" ) AND ( GV$_JouFile <> NULL ) THEN
!(retired):           JOURNAL_CLOSE; !close .TJL to separate sessions;
!(retired):           GV$_JouFile := NULL;
!(retired):         ENDIF;
!(retired):         ATTACH;        !<Gold>CTRL/A...to parent; then reopen .TJL
!(retired):         P$Journal( F$FindBuf( GV$_Mbuf, "X" ) );
!(retired):         RETURN;
      [OTHERWISE]: MESSAGE( "Illegal function code argument to P$Bye" );
      ENDCASE;
  ENDIF;
ENDPROCEDURE  !P$Bye


! === FUNCTIONS / UTILITIES === !

PROCEDURE F$PrintingChar( tkey )
LOCAL akey;
  akey := ASCII( tkey );
  IF ( akey = ASCII( 0 ) ) THEN
    RETURN( NULL );     !not a printing character
  ELSE RETURN( akey );
  ENDIF;
ENDPROCEDURE  !F$PrintingChar

PROCEDURE F$Anchored( pat, ex )
  RETURN( SEARCH_QUIETLY( ANCHOR + pat, FORWARD, ex ) <> 0 );
ENDPROCEDURE  !F$Anchored

PROCEDURE F$Lcontains( lstr, sep )
LOCAL found, i, tstr;
  found := FALSE;
  i := 0;
  LOOP
    tstr := F$ELEMENT( i, sep, lstr );
    EXITIF ( tstr = sep ) OR ( found );
    found := ( F$Anchored( MATCH( tstr ), NO_EXACT ) );
    i := i + 1;
    ENDLOOP;
  RETURN ( found );
ENDPROCEDURE  !F$Lcontains

PROCEDURE F$atBOB
  RETURN( MARK( NONE ) = BEGINNING_OF( CURRENT_BUFFER ) );
ENDPROCEDURE  !F$atBOB

PROCEDURE F$atEOB
  RETURN( MARK( NONE ) = END_OF( CURRENT_BUFFER ) );
ENDPROCEDURE  !F$atEOB

PROCEDURE F$atEOL
ON_ERROR
  RETURN( TRUE );  !maybe at EOB
ENDON_ERROR
  RETURN( CURRENT_CHARACTER = NULL );
ENDPROCEDURE  !F$atEOL

PROCEDURE F$Char_in_SR
LOCAL len;
  P$SelectRange;
  IF ( GV$_SelectRng <> 0 ) THEN
    len := LENGTH( GV$_SelectRng );
    P$Reset;
    RETURN( len );
  ELSE RETURN( 0 );
  ENDIF;
ENDPROCEDURE  !F$Char_in_SR

PROCEDURE P$CondCode
LOCAL b, cc, msg;
ON_ERROR
[OTHERWISE]:
  P$Post( "%KED-W-MSGNOTFND, message not found" );
ENDON_ERROR
  cc := F$Prompt( "Condition code", NULL, "NU", FALSE );
  IF ( INDEX( cc, "%X" ) = 1 ) THEN
    cc := INT( SUBSTR( cc, 3, LENGTH( cc ) - 2 ), 16 );  !hex
  ELSE cc := INT( cc, 10 );  !decimal
  ENDIF;
  IF ( MESSAGE_TEXT( cc, 2 ) <> "%MSGNOTFND" ) THEN
    P$Post( MESSAGE_TEXT( cc, 15 ) );
  ENDIF;
ENDPROCEDURE  !P$CondCode

PROCEDURE F$Ctrl( tchr )
LOCAL c;
  c := tchr;  !avoid side-effect on actual parameter
  CHANGE_CASE( c, UPPER );
  RETURN( ASCII( INDEX( "@" + K$UPLETTERS + "[8901", c ) - 1 ) );
ENDPROCEDURE  !F$Ctrl


! === DCL LEXICALS (mimics) === !

PROCEDURE F$ELEMENT( n, Sep, Strg )
LOCAL i, j, E, S;
  i := -1;
  j := n;
  E := Sep;
  S := Strg + Sep;
  LOOP
    EXITIF ( j < 0 ) OR ( i = 0 );
    i := INDEX( S, Sep );
    IF ( i > 0 ) THEN
      j := j - 1;
      E := SUBSTR( S, 1, i - 1 );
      S := SUBSTR( S, i + 1, LENGTH( S ) - i );
    ENDIF;
    ENDLOOP;
  !distinguish NULL value from "no such element":
  IF ( i = 0 ) THEN E := Sep; ENDIF;
  RETURN( E );
ENDPROCEDURE  !F$ELEMENT

PROCEDURE F$TRNLNM( LNM, Tbl, Idx, MaxIdx )
LOCAL Table, Ndx, ArgStr, ResStr, EqvStr;
ON_ERROR
!  MESSAGE( "%F$TRNLNM-F-NOLOGNAME, no logical name match" );
!  MESSAGE( FAO( "  logical: `!AS'", LNM ) );
!  message( error_text + " at line " + str( error_line ) );
!  P$0; ABORT;
ENDON_ERROR
  ! Argument-String: "Logical¶Table¶Index"
  IF ( GET_INFO( Tbl, "TYPE" ) = STRING ) THEN
    Table := Tbl;
  ELSE Table := NULL;
  ENDIF;
  IF ( GET_INFO( Idx, "TYPE" ) = INTEGER ) THEN
    Ndx := Idx;
  ELSE Ndx := 0;
  ENDIF;
  ArgStr := LNM + K$pilcrow + Table + K$pilcrow + STR( Ndx );
  IF ( GV$_debug ) THEN
    MESSAGE( " In: `" + ArgStr + "'");
  ENDIF;
  ResStr := CALL_USER( K$OpCode_Translate_LNM, ArgStr );
  IF ( GV$_debug ) THEN
    MESSAGE( "Out: `" + ResStr + "'");
  ENDIF;
  ! Return-String: "EquivStr¶Logical¶TblFoundIn¶Index¶MaxIndex"
  EqvStr := F$ELEMENT( 0, K$pilcrow, ResStr );
  Lnm    := F$ELEMENT( 1, K$pilcrow, ResStr );
  Tbl    := F$ELEMENT( 2, K$pilcrow, ResStr );
  !Idx & MaxIdx are returned as strings...
  !  caller should convert to INT() only if needed
  Idx    := F$ELEMENT( 3, K$pilcrow, ResStr );
  MaxIdx := F$ELEMENT( 4, K$pilcrow, ResStr );
  RETURN( EqvStr );
ENDPROCEDURE  !F$TRNLNM

PROCEDURE F$TranslateLNM( LNM, DefVal; Table, Ndx )
LOCAL Val, Tmp, Tbl, Idx, MaxIdx;
ON_ERROR
ENDON_ERROR
  Tmp := LNM;   !If parameter LNM is "LiteralString", need this Tmp assignment!
  Tbl := F$Default( Table, "=", STRING, NULL );
  Idx := F$Default( Ndx,   "=", INTEGER, 0 );
  Val := F$TRNLNM( Tmp, Tbl, Idx, MaxIdx );
  IF ( Val = NULL ) THEN
    Val := DefVal;     !give back the default if the translation fails
  ENDIF;
  IF ( GV$_debug ) THEN
    MESSAGE( "LNM translation: `" + Val + "'");
  ENDIF;
  RETURN( Val );
ENDPROCEDURE  !F$TranslateLNM

PROCEDURE P$SETSYMBOL( Sym, Val; GLFlag )
LOCAL GLF, ArgStr, ResStr;
ON_ERROR
  MESSAGE( "%F$SETSYMBOL-F-SETFAIL, failed to set symbol" );
  MESSAGE( FAO( "  symbol: `!AS'", Sym ) );
  P$0; ABORT;
ENDON_ERROR
  IF ( LENGTH( Sym ) > 255 ) THEN
    P$Post( "%P$SETSYMBOL-E-SYMTOOLONG, length of symbol name exceeds 255 characters" );
    ABORT;
  ENDIF;
  IF ( LENGTH( Val ) > 255 ) THEN
    P$Post( "%P$SETSYMBOL-E-VALTOOLONG, symbol's value exceeds 255 characters" );
    ABORT;
  ENDIF;
  ! Argument-String: "Symbol¶Value¶GlobalLocalFlag"
  GLF := F$Default( GLFlag, "=", INTEGER, LIB$K_CLI_GLOBAL_SYM );
  ArgStr := Sym + K$pilcrow + Val + K$pilcrow + STR( GLF );
  ResStr := CALL_USER( K$OpCode_Set_Symbol, ArgStr );
  IF ( GV$_debug ) THEN
    MESSAGE( " In: `" + ArgStr + "'");
    MESSAGE( "Out: `" + ResStr + "'");
  ENDIF;
ENDPROCEDURE  !P$SETSYMBOL

PROCEDURE F$GETSYMBOL( Sym, GLFlag )
LOCAL ArgStr, ResStr, Val;
ON_ERROR
  MESSAGE( "%F$GETSYMBOL-F-NOSUCHSYM, no such symbol" );
  MESSAGE( FAO( "  symbol: `!AS'", Sym ) );
  P$0; ABORT;
ENDON_ERROR
  IF ( LENGTH( Sym ) > 255 ) THEN
    P$Post( "%P$GETSYMBOL-E-SYMTOOLONG, length of symbol name exceeds 255 characters" );
    ABORT;
  ENDIF;
  ! Argument-String: "Symbol"
  ResStr := CALL_USER( K$OpCode_Get_Symbol, Sym );
  IF ( GV$_debug ) THEN
    MESSAGE( " In: `" + Sym + "'");
    MESSAGE( "Out: `" + ResStr + "'");
  ENDIF;
  ! Result-String: "Value¶GlobalLocalFlag"
  ! (LIB$GET_SYMBOL returns table where if found symbol: Local or Global)
  Val    := F$ELEMENT( 0, K$pilcrow, ResStr );
  GLFlag := INT( F$ELEMENT( 1, K$pilcrow, ResStr ) );
  RETURN( Val );
ENDPROCEDURE  !F$GETSYMBOL

PROCEDURE F$ParseFSpec( Lnm; Opt, Dflt )
LOCAL def, eqv, val, nam, log;
  ! If FILE_PARSE returns the logical name's string itself as the value,
  ! then there is no logical by that name currently defined...
  ! In this case, return either the default or null;
  ! if the logical does exist, return an appropriate parse.
  val := F$Default( Opt, "=", INTEGER, 1 );
  def := F$Default( Dflt, "=", STRING, NULL );
  log := EDIT( Lnm, UPPER, COLLAPSE, NOT_IN_PLACE );
  eqv := FILE_PARSE( log, NULL, NULL, NAME );
  IF ( eqv = log ) THEN
    RETURN( def );
  ELSE CASE val FROM 1 TO 4
         [1]: ! Filename only
              RETURN( eqv );
         [2]: ! Filename.Ext
              RETURN( FILE_PARSE( Lnm, def, NULL, NAME, TYPE ) );
         [3]: ! Dev:[Dir.Sub...]Filename.Ext
              RETURN( FILE_PARSE( Lnm, def, NULL,
                                  DEVICE, DIRECTORY, NAME, TYPE ) );
         [4]: ! Full: Node::Dev:[Dir...]Filename.Ext;Vers
              RETURN( FILE_PARSE( Lnm, def ) );
         ENDCASE;
  ENDIF;
ENDPROCEDURE  !F$ParseFSpec


PROCEDURE F$GetFname( p1, p2 )
LOCAL fnam;   !usually, args are "FILE_NAME" and "OUTPUT_FILE"
  IF ( p1 <> NULL ) THEN fnam := GET_INFO( CURRENT_BUFFER, p1 ); ENDIF;
  IF ( p2 <> NULL ) AND ( ( fnam = 0 ) OR ( fnam = NULL ) ) THEN
    fnam := GET_INFO( CURRENT_BUFFER, p2 ); ENDIF;
  fnam := F$Default( fnam, "<>", STRING, NULL );
  RETURN( fnam );
ENDPROCEDURE  !F$GetFname

PROCEDURE F$GetFtype( Fnam; DType, Dless, Norm )
LOCAL typ, deftyp, dotless, normalize;
  deftyp    := F$Default( Dtype, "U", UNSPECIFIED, "." );
  dotless   := F$Default( Dless, "U", UNSPECIFIED, TRUE );
  normalize := F$Default( Norm,  "U", UNSPECIFIED, TRUE );
  IF ( Fnam = NULL ) OR ( GET_INFO( Fnam, "TYPE" ) <> STRING ) THEN
    typ := GET_INFO( CURRENT_BUFFER, "OUTPUT_FILE" );
  ELSE typ := Fnam;
  ENDIF;
  typ := FILE_PARSE( typ, deftyp, NULL, TYPE );
  IF dotless THEN typ := typ - K$period; ENDIF;
  IF normalize THEN
    ! Want ".XYZ_OBSOLETE", ".XYZ-NEW", ".XYZ$FOO" (etc) to behave like ".XYZ":
    IF ( INDEX( typ, "_" ) > 0 ) THEN typ := F$ELEMENT( 0, "_", typ ); ENDIF;
    IF ( INDEX( typ, "-" ) > 0 ) THEN typ := F$ELEMENT( 0, "-", typ ); ENDIF;
    IF ( INDEX( typ, "$" ) > 0 ) THEN typ := F$ELEMENT( 0, "$", typ ); ENDIF;
  ENDIF;
  RETURN( typ );
ENDPROCEDURE  !F$GetFtype

PROCEDURE F$GetNT( ptr, kind )
LOCAL f0;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: P$0; ABORT;
ENDON_ERROR
  f0 := GET_INFO( ptr, kind );
  IF ( GET_INFO( f0, "TYPE" ) = STRING ) THEN
    f0 := FILE_PARSE( f0, NULL, NULL, NAME, TYPE );
    ELSE f0 := NULL;
    ENDIF;
  RETURN( f0 );
ENDPROCEDURE  !F$GetNT

PROCEDURE F$Keyword( tv, mv, ts, fs )
  IF ( tv = mv ) THEN RETURN( ts );
 ELSE RETURN( fs );
 ENDIF;
ENDPROCEDURE  !F$Keyword

PROCEDURE F$L_Count
LOCAL tl, junk, adj, c, here;
  SET( TIMER, ON, "counting..." );
  here := MARK( NONE );
  P$Page( REVERSE );
  IF ( F$atBOB ) THEN adj := 0;  !yes, no leading <ff>;
  ELSE adj := -1;                !no, account for line containing first <ff>
  ENDIF;
  tl := F$L_Number( junk );
  P$Page( FORWARD );
  c := F$L_Number( junk ) - tl + adj;
  POSITION( here );
  SET( TIMER, OFF, NULL );
  RETURN( c );
ENDPROCEDURE  !F$L_Count

PROCEDURE F$L_Number( totLs )
LOCAL here, curL;
  here  := MARK( FREE_CURSOR );
  totLs := GET_INFO( CURRENT_BUFFER, "RECORD_COUNT" );
  curL  := GET_INFO( here, "RECORD_NUMBER" );
  RETURN( curL );
ENDPROCEDURE  !F$L_Number

PROCEDURE F$Lines_in_SR( sno, eno )
LOCAL c, here, junk;
  SET( TIMER, ON, "counting..." );
  P$SelectRange;
  here := MARK( NONE );
  IF ( GV$_SelectRng <> 0 ) THEN
    POSITION( BEGINNING_OF( GV$_SelectRng ) );
    sno := F$L_Number( junk );
    POSITION( END_OF( GV$_SelectRng ) );
    eno := F$L_Number( junk );
    POSITION( here );
    P$Reset;
    c := eno - sno + 1;
  ELSE c := 0;
  ENDIF;
  SET( TIMER, OFF, NULL );
  RETURN( c );
ENDPROCEDURE  !F$Lines_in_SR

PROCEDURE P$Lines_in_SR
LOCAL s, e;
  MESSAGE( "!SL lines in SR; start: !SL, end: !SL", 0,
           F$Lines_in_SR( s ,e ), s, e ); 
ENDPROCEDURE  !P$Lines_in_SR

PROCEDURE F$Prompt( prmpt, dflt, opt, parseit )
! opt values - "D": return "dflt" if defaulted (else NULL)
!              "F": return first-character of answer only
!              "N": don't show default
!              "Q": disregard quoted string for upcase
!              "U": Upcase the answer
LOCAL punc, ans;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: P$0; ABORT;
ENDON_ERROR
  IF ( INDEX( "YNTFyntf", dflt ) > 0 ) THEN punc := "? ";
  ELSE punc := ": ";
  ENDIF;
  IF ( INDEX( opt, "N" ) = 0 ) THEN punc := " <" + dflt + ">" + punc; ENDIF;
  ans := READ_LINE( prmpt + punc );
  IF ( parseit ) THEN ans := FILE_PARSE( ans, NULL, NULL, NAME ); ENDIF;
  IF ( INDEX( opt, "D" ) > 0 ) AND ( ans = NULL ) THEN ans := dflt; ENDIF;
  IF ( INDEX( opt, "F" ) > 0 ) THEN ans := SUBSTR( ans, 1, 1 ); ENDIF;
  IF ( INDEX( opt, "U" ) > 0 ) THEN
    IF ( INDEX( opt, "Q" ) > 0 ) THEN EDIT( ans, UPPER, OFF );
    ELSE EDIT( ans, UPPER ); !TPU bug with "ON", use default
    ENDIF;
  ENDIF;
  RETURN( ans );
ENDPROCEDURE  !F$Prompt

PROCEDURE F$RemoveC( ch, s )
LOCAL tmp, c;
  tmp := s;
  LOOP  !remove any "ch" from "s"
    c := INDEX( tmp, ch );
    EXITIF ( c = 0 );
    tmp := SUBSTR( tmp, 1, c - 1 ) + SUBSTR( tmp, c + 1, LENGTH( tmp ) - c );
    ENDLOOP;
  RETURN( tmp );
ENDPROCEDURE  !F$RemoveC

PROCEDURE P$SetMod( mdfy )
LOCAL state;
  IF ( mdfy ) THEN state := ON;
  ELSE state := OFF;
  ENDIF;
  SET( MODIFIED, CURRENT_BUFFER, state );
ENDPROCEDURE  !P$SetMod

PROCEDURE F$Words_in_SR
LOCAL i, pos, pat, here, tl;
ON_ERROR
  POSITION( here );
  RETURN( i );
ENDON_ERROR
  i := 0;
  pat := SPANL( K$spc_tab ) | LINE_END;
  here := MARK( NONE );
  P$Append( $$SCRATCH_BUFFER, TRUE ); P$Paste( $$SCRATCH_BUFFER );
  POSITION( BEGINNING_OF( $$SCRATCH_BUFFER ) );
  LOOP  !avoid leading/trailing/multiple space count problems
    tl := ERASE_LINE;
    EDIT( tl, TRIM, COMPRESS, OFF );
    IF ( LENGTH( tl ) > 0 ) THEN
      IF ( NOT F$atEOB ) THEN
        P$Insert( tl ); SPLIT_LINE;
        ELSE P$Insert( tl ); EXITIF ( TRUE );
      ENDIF;
    ENDIF;
    EXITIF ( F$atEOB );
    ENDLOOP;
  POSITION( BEGINNING_OF( $$SCRATCH_BUFFER ) );
  LOOP   ! count words
    pos := SEARCH( pat, FORWARD );
    POSITION( END_OF( pos ) );  !error-traps "not found"
    IF ( NOT F$atEOB ) THEN i := i + 1; ENDIF;
    MOVE_HORIZONTAL( +1 );
    ENDLOOP;
ENDPROCEDURE  !F$Words_in_SR


! === HELP === !

PROCEDURE F$Get_Keypad( km )
LOCAL buf;
  IF ( $$KEYPAD_WINDOW = 0 ) THEN
    $$KEYPAD_WINDOW := CREATE_WINDOW( 1, GV$_screen, OFF );
  ENDIF;
  SET( STATUS_LINE, $$KEYPAD_WINDOW, NONE, NULL );
  SET( TEXT, $$KEYPAD_WINDOW, NO_TRANSLATE );  !enables line-drawing, etc.
  buf := F$FindBuf( K$Scrbuf, "S" );
  ERASE( buf );
  HELP_TEXT( "ked$help", km, OFF, buf );
  POSITION( BEGINNING_OF( buf ) );
  P$Do_N( "ERASE_LINE", NULL, 3 );
  LOOP  ! delete extra spaces at BOL
    EXITIF ( MARK( NONE ) = END_OF( buf ) );
    ERASE_CHARACTER( +2 );
    MOVE_VERTICAL( +1 );
    ENDLOOP;
  ERASE_LINE;  ! delete one blank line at EOB
  RETURN( BEGINNING_OF( buf ) );
ENDPROCEDURE  !F$Get_Keypad

PROCEDURE P$Keypad_Help
LOCAL km, ptxt, hkey, cstr;
  SET( TIMER, OFF, NULL );
  ptxt := "<KEY> = help on that key; " + "<HELP> = diagram; " + K$CTRL_Zp;
  km := GET_INFO( KEY_MAP, "FIRST", G$KML );
  POSITION( F$Get_Keypad( km ) );
  MAP( $$KEYPAD_WINDOW, CURRENT_BUFFER );
  UPDATE( $$KEYPAD_WINDOW );
  hkey := READ_KEY;
  LOOP
    cstr := LOOKUP_KEY( hkey, COMMENT );
    EXITIF ( ( hkey = CTRL_Z_KEY ) OR ( hkey = CTRL_M_KEY ) );
    IF ( hkey = HELP ) OR ( hkey = F8 )  ! VT and PC responses...
    THEN POSITION( F$Get_Keypad( km ) );
    ELSE SET( TEXT, $$KEYPAD_WINDOW, NO_TRANSLATE );  !enables bold, etc.
      SET( STATUS_LINE, $$KEYPAD_WINDOW, REVERSE, ptxt );
      IF ( cstr = NULL ) THEN cstr := "NO_HELP" ENDIF;
      HELP_TEXT( "ked$help", "KED " + cstr, OFF, CURRENT_BUFFER );
      POSITION( BEGINNING_OF( CURRENT_BUFFER ) );
      P$Do_N( "ERASE_LINE", NULL, 5 );
    ENDIF;
    UPDATE( $$KEYPAD_WINDOW );
    hkey := READ_KEY;
    ENDLOOP;
  UNMAP( $$KEYPAD_WINDOW );
ENDPROCEDURE  !P$Keypad_Help

PROCEDURE P$Help( tpar; lib )
LOCAL libr, subj;
ON_ERROR
  IF ( CURRENT_WINDOW = TPU$X_SHOW_WINDOW ) THEN
    UNMAP( TPU$X_SHOW_WINDOW );
  ENDIF;
  P$0; ABORT;
ENDON_ERROR
  libr := F$Default( lib, "U", UNSPECIFIED, "ked$help" );
  subj := tpar;
  IF ( subj = NULL ) THEN
    subj := F$Prompt( "Topic", "Summary", "D", FALSE );
  ENDIF;
  P$ClrMsg;
  SET( PAD, TPU$X_SHOW_WINDOW, OFF );
  SET( STATUS_LINE, TPU$X_SHOW_WINDOW, REVERSE, K$CTRL_Zp );
  SET( TEXT, TPU$X_SHOW_WINDOW, NO_TRANSLATE );
  SET( VIDEO, TPU$X_SHOW_WINDOW, NONE );
  SET( WIDTH, TPU$X_SHOW_WINDOW, GET_INFO( SCREEN, "WIDTH" ) );
  MAP( TPU$X_SHOW_WINDOW, TPU$X_SHOW_BUFFER );
  HELP_TEXT( libr, subj, OFF, TPU$X_SHOW_BUFFER );
  POSITION( BEGINNING_OF( TPU$X_SHOW_BUFFER ) );
  IF ( NOT F$atEOB ) THEN
    IF ( LENGTH( CURRENT_LINE ) = 0 ) THEN ERASE_LINE; ENDIF;
  ENDIF;
  GV$_flipR := 0;
ENDPROCEDURE  !P$Help


! === INPUT/OUTPUT === !

PROCEDURE F$Exists( f, fspc; default, io, reset )
LOCAL def, tio, rst;
ON_ERROR
  MESSAGE( K$xNF_msg, 0, "Directory",
           FILE_PARSE( f, NULL, NULL, DEVICE, DIRECTORY ) );
  RETURN( FALSE );
ENDON_ERROR
  def := F$Default( default, "U", UNSPECIFIED, K$dfspec );
  tio := F$Default( io, "U", UNSPECIFIED, "I" );
  rst := F$Default( reset, "U", UNSPECIFIED, FALSE );
  CASE tio FROM "I" TO "O"
    ["I"]: fspc := FILE_SEARCH( f, def );
           IF ( rst ) THEN rst := FILE_SEARCH( NULL ); ENDIF; !reset context
    ["O"]: IF ( NOT rst ) THEN
             rst := FILE_SEARCH( NULL );  !reset context
             fspc := FILE_SEARCH( f, def );
             rst := FILE_SEARCH( NULL );  !reset context
             IF ( fspc = NULL ) THEN fspc := FILE_PARSE( f, def ); ENDIF;
           ELSE fspc := FILE_PARSE( f, def );
           ENDIF;
           fspc := SUBSTR( fspc, 1, INDEX( fspc, K$semicolon ) );
    ENDCASE;
  RETURN( fspc <> NULL );
ENDPROCEDURE  !F$Exists

PROCEDURE P$FileDir( ifil )
LOCAL here, c, fil;
  IF ( GET_INFO( CURRENT_BUFFER, "NAME" ) <> K$DCLbuf ) THEN
    P$DCLcreate( FALSE );
  ENDIF;
  SET( TIMER, ON, "DCL working..." );
  POSITION( END_OF( CURRENT_BUFFER ) );
  SPLIT_LINE; COPY_TEXT( FAO ( "Directory of files matching `!AS'", ifil ) );
  SPLIT_LINE; SPLIT_LINE;
  MOVE_VERTICAL( -1 );  here := MARK( NONE );  MOVE_VERTICAL( +1 );
  c := 0;
  LOOP
    fil := FILE_SEARCH( ifil );
    EXITIF ( fil = NULL );
    c := c + 1;
    COPY_TEXT( FAO( "!2* !AS", fil ) );
    SPLIT_LINE;
    ENDLOOP;
  SPLIT_LINE;
  COPY_TEXT( FAO ( "Total of !ZL matching file!%S", c ) );
  SPLIT_LINE;
  POSITION( here );
  fil := FILE_SEARCH( NULL );  !reset context
  SET( TIMER, OFF, NULL );
ENDPROCEDURE  !P$FileDir

PROCEDURE P$Input( fspec )
LOCAL ifil, tfil, xfil, rw;
ON_ERROR
[TPU$_PARSEFAIL]:
  MESSAGE( 'Select Range does not contain a legal file specification' );
  P$0; ABORT;
ENDON_ERROR
  LOOP
    IF  ( GV$_SelectRngStart <> 0 ) THEN
      P$SelectRange;
      tfil := STR( GV$_SelectRng );
      GV$_SelectRng := 0;
      EDIT( tfil, COLLAPSE );
      tfil := FILE_PARSE( tfil );
    ELSE tfil := fspec;
    ENDIF;
    ifil := F$Prompt( "File", tfil, "UDQ", FALSE );
    IF ( ifil = NULL ) THEN RETURN;
    ELSE CASE SUBSTR( ifil, 1, 1 ) FROM "'" TO "?"
           ["'"]: IF ( SUBSTR( ifil, 2, 1 ) = "C" ) THEN     !allow "'CX'", etc.
                    ifil := F$GetFname( "FILE_NAME", "OUTPUT_FILE" );
                    IF ( ifil = NULL ) THEN ifil := ".;"; ENDIF; !empty filespec
                    ifil := SUBSTR( ifil, 1, INDEX( ifil, K$semicolon ) );
                  ELSE ifil := NULL;
                  ENDIF;
           ["?"]: ifil := SUBSTR( ifil, 2, LENGTH( ifil ) );
                  EDIT( ifil, COLLAPSE );
                  IF ( ifil = NULL ) THEN ifil := "*.*" ENDIF;
                  P$FileDir( ifil );
                  RETURN;
           ENDCASE;
    ENDIF;
    IF ( F$Exists( ifil, xfil, K$dfspec, "I", TRUE ) ) THEN
      IF ( INDEX( ifil, "*" ) > 0 ) OR ( INDEX( ifil, "%" ) > 0 ) THEN
        P$Wildfiles( ifil, CURRENT_WINDOW );
        RETURN;
      ELSE EXITIF ( TRUE );      
      ENDIF;
    ELSE MESSAGE( K$xNF_msg, 0, "File", ifil );
    ENDIF;
    ENDLOOP;
  rw := NULL;
  P$Readfile( xfil, rw, CURRENT_WINDOW );
ENDPROCEDURE  !P$Input


PROCEDURE F$Printfile( DQue, Prmpt, What )
LOCAL mod, Tmp, Que, ws, msg, junk;
  IF Prmpt THEN
    Que := F$Prompt( "Printer queue", DQue, "UD", FALSE );
  ELSE Que := DQue;
  ENDIF;
  Tmp := CALL_USER( K$OpCode_Check_ifQue, Que );
  IF ( Tmp <> NULL ) THEN  !Is a printer que
    IF ( What = NULL ) THEN
      IF ( GV$_SelectRngStart <> 0 ) THEN
        ws := F$Prompt( "All/Select_Range", "S", "DFU", FALSE );
      ELSE ws := "A";
      ENDIF;
    ELSE ws := What;
    ENDIF;
    SET( TIMER, ON, "printing file...");
    mod := GET_INFO( CURRENT_BUFFER, "MODIFIED" );
    IF ( ws = "A" ) THEN
      Tmp := WRITE_FILE( CURRENT_BUFFER, Tmp );
      msg := NULL;
    ELSE IF ( GV$_SelectRng = 0 ) THEN P$SelectRange; ENDIF;
      IF ( GV$_SelectRng <> 0 ) THEN Tmp := WRITE_FILE( GV$_SelectRng, Tmp ); ENDIF;
      msg := " from Select Range";
      P$Reset;
    ENDIF;
    junk := CALL_USER( K$OpCode_Que_File, Que + "," + Tmp );
    IF ( mod ) THEN  !reset Modified state
      SET( MODIFIED, CURRENT_BUFFER, ON );
    ENDIF;
    SET( TIMER, OFF, NULL );
    P$ClrMsg;
    MESSAGE( K$Pr1_msg, 0, Tmp );
    MESSAGE( K$Pr2_msg, 0, msg, Que );
  ELSE MESSAGE( "`" + Que + "' is not a printer queue" );
  ENDIF;
  RETURN( Tmp );
ENDPROCEDURE  !F$PrintFile

PROCEDURE P$Checkpoint
LOCAL here, buf, fn, bcnt, i;
  P$post( "Checkpointing all RW buffers..." );
  here := MARK( NONE );
  bcnt := 0;
  buf := GET_INFO( BUFFERS, "FIRST" );
  LOOP
    EXITIF ( buf = 0 );
    IF ( NOT GET_INFO( buf, "SYSTEM" ) ) THEN         !skip all system buffers
        IF ( NOT GET_INFO( buf, "NO_WRITE" ) )
        AND ( GET_INFO( buf, "MODIFIED" )
        AND ( GET_INFO( GV$_ruRngB, "TYPE" ) <> RANGE ) ) THEN   !it's "RW"...
          POSITION( buf );
          fn := F$Output( "A", FALSE );                          !so write it
          bcnt := bcnt + 1;
        ENDIF;
    ENDIF;
    buf := GET_INFO( BUFFERS, "NEXT" );
    ENDLOOP;
  POSITION( here );
  ! Update status lines for any visible windows (F$Output did CURRENT_WINDOW):
  IF ( GET_INFO( GV$_MWin, "TYPE" ) = ARRAY ) THEN
    i := 1;
    LOOP
      EXITIF ( GET_INFO( GV$_MWin{i}, "TYPE" ) <> WINDOW );
      P$Status( GV$_MWin{i} );
      i := i + 1;
      ENDLOOP;
  ENDIF;
  IF ( GV$_JouMeth = "K" ) AND ( GV$_JouFile <> NULL ) THEN
    ! Close, delete and re-open this session's .TJL:
    JOURNAL_CLOSE;
    P$DCLsend( "DELETE /NOLOG " + GV$_JouFile );
    GV$_JouFile := JOURNAL_OPEN( GV$_JouFile );
    SET( JOURNALING, GV$_JouRate );
    IF ( GV$_debug ) THEN MESSAGE( "KeyJournal: " + GV$_JouFile
                                   + ", Rate: " + STR( GV$_JouRate ) ); ENDIF;
  ENDIF;
  IF ( bcnt > 0 ) THEN
    MESSAGE( K$Cp1_msg, 0, bcnt );
  ELSE MESSAGE( K$Cp2_msg );
  ENDIF;
ENDPROCEDURE  !P$Checkpoint

PROCEDURE F$Output( p1; prompt, outf )
LOCAL ws, Prmpt, Cfil, Ofil, Ospc, Msg, Tmp, isQue, isFile, junk, Buf;
ON_ERROR
  ! NOTE! -- Non-CASE-style error handler required to handle CALL_USER errors.
  ! With CALL_USER, expect general VMS error condition codes ("ERROR"):
  P$CALLUSER_error( ERROR, "F$Output", junk );
  MESSAGE( 'line: ' + STR( ERROR_LINE ) + ' --- File not saved' );
  P$Reset;
  P$0; ABORT;
ENDON_ERROR
  Prmpt := F$Default( prompt, "U", UNSPECIFIED, TRUE );
  Cfil  := F$Default( outf, "U", UNSPECIFIED,
                      GET_INFO( CURRENT_BUFFER, "OUTPUT_FILE" ) );
  IF ( Prmpt OR ( Cfil = NULL ) ) THEN
    Ofil := F$Prompt( "File", F$GetFname( "OUTPUT_FILE", "FILE_NAME" ),
                      "UD", FALSE );
    Ofil := FILE_PARSE( Ofil, Cfil, K$dfspec );
  ELSE IF ( CALL_USER( K$OpCode_Check_ifQue, Cfil ) <> NULL ) THEN
         Cfil := F$Prompt( "Printer queue", Cfil, "UD", FALSE );
       ENDIF;
       Ofil := Cfil;
  ENDIF;
  IF ( p1 <> NULL ) THEN
    ws := SUBSTR( p1, 1, 1 );
  ELSE IF ( GV$_SelectRngStart <> 0 ) THEN
         ws := F$Prompt( "All/Select_Range", "S", "DFU", FALSE );
       ELSE ws := "A";
       ENDIF;
  ENDIF;
  SET( TIMER, ON, "writing file...");
  Cfil := FILE_PARSE( Ofil, NULL, NULL, NAME );
  Tmp := CALL_USER( K$OpCode_Check_ifQue, Cfil );
  isQue := ( Tmp <> NULL );
  IF NOT( isQue ) THEN
    isFile := F$Exists( Ofil, Ofil, K$dfspec, "O", TRUE );
  ELSE isFile := FALSE;
  ENDIF;
  IF ( isQue OR isFile ) THEN
    CASE ws FROM "A" TO "S"
      ["A"]: IF ( isQue ) THEN
               Ospc := F$PrintFile( CFil, FALSE, ws );
             ELSE Buf := CURRENT_BUFFER;
               SET( OUTPUT_FILE, Buf, Ofil );
               Ospc := WRITE_FILE( Buf, Ofil );
               P$Journal( Buf );
               IF ( Buf = GET_INFO( CURRENT_WINDOW, "BUFFER" ) ) THEN
                 GV$_B := Buf;
                 junk := FILE_PARSE( Ofil, NULL, NULL, NAME, TYPE );
                 F$Execute( "SET(EOB_TEXT, GV$_B, '[End " + junk + "]')" );
                 GV$_BufName{Buf} := junk;
                 P$Status( CURRENT_WINDOW );
               ENDIF;
             ENDIF;
             Msg := NULL;
      ["S",
       "R"]: IF ( GET_INFO( GV$_SelectRng, "TYPE" ) <> RANGE ) THEN
               P$SelectRange;
             ENDIF;
             IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE ) THEN
               IF ( isQue ) THEN
                 Ospc := F$PrintFile( CFil, FALSE, ws );
               ELSE Ospc := WRITE_FILE( GV$_SelectRng, Ofil );
               ENDIF;
               P$Reset;
               Msg := " from Select Range";
             ELSE MESSAGE( K$NSA_msg, 0, "F$Output" );
             ENDIF;
      ENDCASE;
    IF ( ws <> "R" ) THEN      ! "R" is quiet
      IF ( isQue ) THEN
        P$ClrMsg;
        MESSAGE( K$Pr1_msg, 0, Ospc );
        MESSAGE( K$Pr2_msg, 0, Msg, Cfil );
      ELSE MESSAGE( K$Out_msg, 0, Ospc, Msg);
           SET( NO_WRITE, CURRENT_BUFFER, OFF );
      ENDIF;
    ENDIF;
  ENDIF;
  SET( TIMER, OFF, NULL );
  RETURN( Ofil );
ENDPROCEDURE  !F$Output

PROCEDURE P$Readfile( inf, rw, win )
LOCAL n, buf, tbuf, abuf, wri, outf;
  P$SwapMsg( TRUE );
  n := 0;
  buf  := FILE_PARSE( inf, NULL, NULL, NAME, TYPE );
  abuf := buf;
  LOOP
    tbuf := F$FindBuf( abuf, "X" );
    EXITIF ( tbuf = 0 ) OR ( n >= K$MaxFiles );
    n := n + 1;
    abuf := buf + "_" + STR( n );
    ENDLOOP;
  IF ( n < K$MaxFiles ) THEN
    IF ( rw = NULL ) THEN
      rw := F$Prompt( "Read/Write or Read_Only (RW/RO)", "RW", "DU", FALSE );
    ENDIF;
    IF ( SUBSTR( rw, 1, 2 ) = "RO" ) OR ( rw = "R" ) THEN wri := "R";
    ELSE wri := NULL;
    ENDIF;
    F$Exists( inf, outf, K$dfspec, "O", TRUE );
    buf := F$CreateBuf( "EJW" + GV$_insovr + wri, abuf, win, inf, outf );
    POSITION( BEGINNING_OF( buf ) );
  ELSE P$Post( 'Exceeded maximum number of files: ' + INT( K$MaxFiles ) );
  ENDIF;
  P$Status( CURRENT_WINDOW );
ENDPROCEDURE  !P$Readfile

PROCEDURE P$Wildfiles( ifil; win )
LOCAL Fa, i, twin, wild, fil, rw, ans;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: P$0; ABORT;
ENDON_ERROR
  twin := F$Default( win, "<>", WINDOW, CURRENT_WINDOW );
  wild := FALSE;
  Fa   := CREATE_ARRAY( 100, 1 );
  i    := 1;
  LOOP
    Fa{i} := FILE_SEARCH( ifil );
    EXITIF ( Fa{i} = NULL );
    i := i + 1;
    ENDLOOP;
  ! ^__Don't let other file_search context resets interfere with this loop...
  rw := FILE_SEARCH( NULL );  !reset context
  rw := NULL;
  i := 1;
  LOOP
    EXITIF ( Fa{i} = NULL );
    IF ( NOT wild ) THEN
      ans := F$Prompt( Fa{i} + " (y/n)", "N", "DU", FALSE );
    ENDIF;
    CASE SUBSTR( ans, 1, 1 ) FROM "*" TO "Y"
      ["N"]: wild := FALSE;
      ["Q"]: EXITIF ( TRUE );
      ["*"]: wild := TRUE;
             P$Readfile( Fa{i}, rw, twin );
      ["R"]: rw := ans;
             P$Readfile( Fa{i}, rw, twin );
      ["Y"]: rw := NULL;
             P$Readfile( Fa{i}, rw, twin );
      ENDCASE;
    i := i + 1;
    ENDLOOP;
  DELETE( Fa );
  UPDATE( CURRENT_WINDOW );
ENDPROCEDURE  !P$Wildfiles


! === LSE SUPPORT === !

PROCEDURE P$Compiler
LOCAL buf, cmd, p0, p1, rng;
  GV$_compdflt := F$Prompt( "Parameters", GV$_compdflt, "UD", FALSE );
  IF ( F$Exists( "ked$compiler", p0, "ked$utils:.com;", "I", TRUE ) ) THEN
    IF ( GET_INFO( CURRENT_BUFFER, "MODIFIED" ) ) THEN
      p1 := F$Output( "A", FALSE );
    ELSE p1 := GET_INFO( CURRENT_BUFFER, "OUTPUT_FILE" );
    ENDIF;
    cmd := "@" + p0 + K$spc + p1 + K$spc + GV$_compdflt;
    IF ( GV$_debug ) THEN MESSAGE( "`" + cmd + "'"); ENDIF;
    SPAWN( cmd );
    IF ( F$Exists( "ked$output", p0, K$dfspec, "I", TRUE ) ) THEN
      buf := CURRENT_BUFFER;
      IF ( $$LIST_BUFFER = 0 ) THEN
        $$LIST_BUFFER := F$CreateBuf( "EIRPW", K$Lisbuf );
      ENDIF;
      POSITION( $$LIST_BUFFER );
      ERASE( $$LIST_BUFFER );
      READ_FILE( "ked$output" );
      POSITION( buf );
      P$MapWin( $$LIST_BUFFER, FALSE );    !don't remap 1 window
      MAP( GV$_MWin{2}, buf );
      POSITION( BEGINNING_OF( $$LIST_BUFFER ) );
      rng := SEARCH_QUIETLY( GV$_CmplErr, FORWARD, NO_EXACT );
      IF ( rng <> 0 )
      THEN POSITION( rng );
        GV$_RngA := F$UlSearch( rng );
      ENDIF;
      POSITION( buf );
    ELSE MESSAGE( K$xNF_msg, 0, "Listing file", FILE_PARSE( "ked$output" ) );
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Compiler

PROCEDURE F$LSE_copy( line, obuf )
LOCAL pat, vr, sr, v;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  POSITION( BEGINNING_OF( $$SCRATCH_BUFFER ) );
  ERASE( $$SCRATCH_BUFFER );
  !one pad-space permits finding $N at line-begin:
  COPY_TEXT( K$spc + line );
  ! ignore self-quoted-metachar "$$...", find all "$N"'s for substitution:
  pat := NOTANY( GV$_LSEmeta ) + GV$_LSEmeta + SPAN( K$DIGITS ) @vr;
  LOOP
    IF ( GV$_debug ) THEN MESSAGE( CURRENT_LINE ); ENDIF;
    POSITION( LINE_BEGIN );
    sr := SEARCH_QUIETLY( pat, FORWARD, EXACT );
    EXITIF ( sr = 0 );  !no "$N"; done
    v := "$" + SUBSTR( vr, 3, LENGTH( vr ) - 1 );
    IF ( GV$_debug ) THEN MESSAGE( "v `" + v + "'" ); ENDIF;
    GV$_Xstr := NULL;  !clear previous value
    EXECUTE( "GV$_Xstr := " + v ); !retrieve "$N" global var
    POSITION( BEGINNING_OF( vr ) );
    MOVE_HORIZONTAL( +1 );  !compensate: escape-char
    ERASE_CHARACTER( LENGTH( v ) );
    COPY_TEXT( GV$_Xstr );  !substitute
    ENDLOOP;
  POSITION( LINE_BEGIN );
  pat := ( GV$_LSEmeta + GV$_LSEmeta ) @vr;
  LOOP  !replace quoted metachar with single metachar
    IF ( GV$_debug ) THEN MESSAGE( CURRENT_LINE ); ENDIF;
    sr := SEARCH_QUIETLY( pat, FORWARD, EXACT );
    EXITIF ( sr = 0 );
    POSITION( BEGINNING_OF( vr ) );
    ERASE_CHARACTER( +1 );  !the quote "$"
    MOVE_HORIZONTAL( +1 );  !over the final "$"
    ENDLOOP;
  !remove one space-padding:
  F$LSE_copy := SUBSTR( CURRENT_LINE, 2, LENGTH( CURRENT_LINE ) - 1 );
ENDPROCEDURE  !F$LSE_copy

PROCEDURE P$LSE_$v( obuf )
! This routine tolerates multiple $TEMPLATE names for a template-block:
!   $TEMPLATE this
!   $TEMPLATE that
!   $0 arg := def
!   $BEGIN
!     body of template
!   $END[$]
LOCAL id, pat, sr, var, par, def;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  ! "=" is missing in "id" pattern --
  ! Cannot allow ":=" within the variable's default value:
  id := K$LETTERS + K$DIGITS + K$spc_tab + K$dquote + K$squote
      + "~!@#$%^&*()[]{}-_+;:\|,./?"  ! ":" allowed, but not "="
      + K$SPECIAL8 + K$EUROLETTERS;
  var := NULL;  par := NULL;  def := NULL;
  pat := ANCHOR + ( GV$_LSEmeta + SPAN( K$DIGITS ) @var ) + ( SPAN( id ) @par )
       + ( LINE_END | ( MATCH( ":=" ) + ( SPAN( id ) @def ) ) );
  sr := SEARCH_QUIETLY( pat, FORWARD, EXACT );
  IF ( sr <> 0 ) THEN
    par := STR( par );
    def := SUBSTR( def, 1, LENGTH( def ) );  !string or range
    EDIT( par, TRIM, OFF );
    EDIT( def, TRIM, OFF );
    var := "$" + SUBSTR( var, 2, LENGTH( var ) - 1 );
    IF ( GV$_debug ) THEN
      MESSAGE( "var `" + var + "'   par `" + par + "'   def `" + def + "'");
    ENDIF;
    GV$_Xstr := F$Prompt( par, def, "D", FALSE );
    EXECUTE( var + ":=GV$_Xstr" );  !creates on-the-fly global-var "$N"
  ENDIF;
ENDPROCEDURE  !P$LSE_$v

PROCEDURE P$LSE_list
LOCAL tnams, nam, pat, sr, sep;
  tnams := 'Template names: ';
  sep   := NULL;
  POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
  LOOP
    pat := LINE_BEGIN + "$TEMPLATE" + SPAN( K$WHITESPACE ) + ( ( REMAIN ) @nam );
    sr := SEARCH_QUIETLY( pat, FORWARD, NO_EXACT );
    IF ( sr <> 0 ) THEN
      POSITION( END_OF( sr ) );
      nam := SUBSTR( nam, 1, LENGTH( nam ) );
      IF ( tnams <> NULL ) THEN
        tnams := tnams + sep + nam;
        IF ( sep = NULL ) THEN sep := ", "; ENDIF;
      ELSE tnams := nam;
      ENDIF;
      IF ( LENGTH( tnams ) > 70 ) THEN
        MESSAGE( tnams );
        tnams := NULL;
      ENDIF;
    ELSE !last template found
      IF ( tnams <> NULL ) THEN
        MESSAGE( tnams );
      ENDIF;
      EXITIF ( TRUE );
    ENDIF;
    ENDLOOP;
ENDPROCEDURE  !P$LSE_list

PROCEDURE F$LSE_load
LOCAL ln, typ;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  typ := F$GetFname( "OUTPUT_FILE", "FILE_NAME" );
  typ := F$GetFtype( typ );
  ln := F$Prompt( "LSE template file to load", typ, "UD", FALSE );
  EDIT( ln, UPPER );
  IF ( SUBSTR( ln, 1, 4 ) <> "KED$" ) THEN ln := "KED$" + ln; ENDIF;
  GV$_ruPos := 1;    !force $RULER reload
  RETURN ( F$LSE_init( ln, TRUE ) );
ENDPROCEDURE  !F$LSE_load

PROCEDURE P$LSE_template( tmpl )
LOCAL opt, ind, pat, sr, line, sl, lc, atx, spos, epos, bob;
ON_ERROR
[TPU$_STRNOTFOUND]:
  MESSAGE( K$xNF_msg, 0, "Template", opt );
  POSITION( GV$_Bvar );  !restore user buffer
  P$0;
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  GV$_Bvar := CURRENT_BUFFER;
  GV$_LSErng := 0;
  spos := 0;
  epos := 0;
  IF ( GV$_LSEp = NULL ) THEN
    MESSAGE( "No templates loaded yet" );
    IF ( NOT F$LSE_load ) THEN RETURN; ENDIF;
  ENDIF;
  IF ( tmpl = NULL ) THEN
    opt := F$Prompt( GV$_LSEp, NULL, "N", FALSE );
    IF ( SUBSTR( opt, 1, 1 ) = "!" ) THEN  !Escape hatch...user changed mind...
      MESSAGE( "No template selected" );
      RETURN;                              ! just quit...
    ENDIF;
    IF ( SUBSTR( opt, 1, 1 ) = "?" ) THEN
      P$LSE_list;                          !Generate template help list,
      POSITION( GV$_Bvar );                    !restore user buffer
      RETURN;                              ! and just quit...
    ENDIF;
  ELSE opt := tmpl;
  ENDIF;
  !Generate an instantiated template:
  bob := F$atBOB;
  epos := MARK( NONE );
  IF ( NOT bob ) THEN
    MOVE_HORIZONTAL( -1 );
    spos := MARK( NONE );
  ENDIF;
  POSITION( epos );
  ind := SUBSTR( K$spaces, 1, CURRENT_OFFSET );  !measure indentation
  POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
  pat := LINE_BEGIN + "$TEMPLATE" + SPAN( K$WHITESPACE ) + opt;
  sr := SEARCH( pat, FORWARD, NO_EXACT );
  IF ( sr <> 0 ) THEN
    POSITION( BEGINNING_OF( sr ) );
    LOOP  ! acquire any prompted variables
      EXITIF ( F$LSE_get( line, sl ) );  !found "$BEGIN"
      P$LSE_$v( GV$_Bvar );
      ENDLOOP;
    lc := 1;
    atx := GV$_LSEmeta + GV$_LSEexec;
    LOOP  ! copy template lines, making required substitutions
      EXITIF ( F$LSE_get( line, sl ) );  !found "$END..."
      line := F$LSE_copy( line, GV$_Bvar );
      POSITION( GV$_Bvar );
      IF ( SUBSTR( line, 1, 2 ) = atx ) THEN
        !execute TPU command starting with "$@";
        !substitutions are already done, but don't copy this line
        EXECUTE( SUBSTR( line, 3, LENGTH( line ) - 2 ) );
      ELSE !copy indented template line with substitutions
        IF ( lc > 1 ) THEN COPY_TEXT( ind );
        ELSE lc := lc + 1;
        ENDIF;
        COPY_TEXT( line );
        IF ( sl ) THEN SPLIT_LINE; ENDIF;
      ENDIF;
      POSITION( $$LSE_BUFFER );
      ENDLOOP;
    POSITION( GV$_Bvar );  !return to end of copied template
    IF ( NOT sl ) THEN APPEND_LINE; ENDIF;
    POSITION( epos );
    MOVE_HORIZONTAL( -1 );
    epos := MARK( NONE );
    IF ( bob ) THEN
      spos := BEGINNING_OF( CURRENT_BUFFER );
      POSITION( spos );
    ELSE POSITION( spos );
         MOVE_HORIZONTAL( +1 );
         spos := MARK( NONE );
    ENDIF;
    IF ( spos <> 0 ) AND ( epos <> 0 ) THEN
      GV$_LSErng := CREATE_RANGE( spos, epos, BOLD );
    ENDIF;
    pat := GV$_LSEmeta + "*";  !final user positioning
    sr := SEARCH_QUIETLY( pat, FORWARD, EXACT, GV$_LSErng );
    IF ( sr <> 0 ) THEN
      POSITION( BEGINNING_OF( sr ) );
      ERASE_CHARACTER( LENGTH( pat ) );
    ELSE POSITION( epos );
         MOVE_HORIZONTAL( + 1 );
    ENDIF;
    SET( FORWARD, CURRENT_BUFFER );
  ENDIF;
ENDPROCEDURE  !P$LSE_template

PROCEDURE P$LSE_remove
LOCAL cbuf;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  IF ( GET_INFO( GV$_LSErng, "TYPE" ) = RANGE ) THEN
    GV$_Bvar := CURRENT_BUFFER;
    cbuf := GET_INFO( GV$_LSErng, "BUFFER" );
    IF ( cbuf <> GV$_Bvar ) THEN P$RememberBuf; ENDIF;
    POSITION( BEGINNING_OF( GV$_LSErng ) );
    IF ( cbuf <> GV$_Bvar ) THEN MAP( CURRENT_WINDOW, CURRENT_BUFFER ); ENDIF;
    ERASE( GV$_LSErng );
    SPLIT_LINE;
    MOVE_HORIZONTAL( -1 );
    GV$_LSErng := 0;
  ELSE P$Post( 'No current LSE template to erase' );
  ENDIF;
ENDPROCEDURE  !P$LSE_remove

PROCEDURE F$LSE_get( line, sl; btok, etok )
LOCAL bt, et;
! Returns next line in $$LSE_BUFFER, conditional split-line (if sl > 0),
! and functional TRUE if at a template delimiter ($BEGIN, $END...)
! or FALSE if more template text to process:
  bt := F$Default( btok, "=", STRING, "$BEGIN" );
  et := F$Default( etok, "=", STRING, "$END" );
  P$MoveL( FORWARD );
  IF ( NOT F$atEOB ) THEN
    line := CURRENT_LINE;
    sl := NOT F$anchored( et + "$", NO_EXACT );
    F$LSE_get := F$Anchored( bt, NO_EXACT )
               OR F$Anchored( et, NO_EXACT );
  ELSE line := NULL;
    sl := FALSE;
    F$LSE_get := TRUE;
  ENDIF;
ENDPROCEDURE  !F$LSE_get

PROCEDURE F$LSE_init( fnam, flag )
LOCAL nam, here;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  IF ( F$Exists( fnam, nam, "ked$utils:.template;", "I", TRUE ) ) THEN
    here := MARK( NONE );
    IF ( $$LSE_BUFFER = 0 ) THEN
      $$LSE_BUFFER := F$CreateBuf( "IRS", K$LSEbuf, , nam );  !never mapped
    ELSE POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
      ERASE( $$LSE_BUFFER );  !erase and load
      READ_FILE( nam );
    ENDIF;
    nam := FILE_PARSE( nam, NULL, NULL, NAME );
    IF ( SUBSTR( nam, 1, 4 ) = "KED$" ) THEN
      G$LSEloaded := SUBSTR( nam, 5, LENGTH( nam ) - 4 );
    ELSE G$LSEloaded := nam;
    ENDIF;
    GV$_LSEmeta := "$";  !default meta-char
    P$LSE_prompt;
    IF ( GV$_ruPos = 1 ) THEN P$LSE_ruler; ENDIF;
    P$LSE_TPUini( here );  !Initialize in context of user's buffer
    IF ( flag ) THEN MESSAGE( "LSE templates read from `" + nam + "'" ); ENDIF;
    POSITION( here );
  ELSE IF ( flag ) THEN MESSAGE( K$xNF_msg, 0, "LSE template file", fnam );
       ELSE P$SetRuler( GV$_ruler );
       ENDIF;
  ENDIF;
  RETURN( nam <> NULL );
ENDPROCEDURE  !F$LSE_init

PROCEDURE P$LSE_prompt
LOCAL pat, sr, p;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: POSITION( GV$_Bvar ); P$0; ABORT;
ENDON_ERROR
  pat := LINE_BEGIN + "$PROMPT" + SPAN( K$WHITESPACE );
  POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
  sr := SEARCH_QUIETLY( pat, FORWARD, NO_EXACT );
  IF ( sr <> 0 ) THEN
    POSITION( END_OF( sr ) );
    MOVE_HORIZONTAL( +1 );
    pat := REMAIN @p;
    sr  := SEARCH( pat, FORWARD, EXACT );
    GV$_LSEp := STR( p );
  ELSE GV$_LSEp := "Template";
  ENDIF;
ENDPROCEDURE  !P$LSE_prompt

PROCEDURE P$LSE_ruler
LOCAL pat, sr, r, line, sl;
  r   := NULL;
  pat := LINE_BEGIN + "$RULER";
  POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
  sr := SEARCH_QUIETLY( pat, FORWARD, NO_EXACT );
  IF ( sr <> 0 ) THEN
    POSITION( BEGINNING_OF( sr ) );
    LOOP
      EXITIF ( F$LSE_get( line, sl ) );  !found "$END(RULER)"
      r := r + line;
      ENDLOOP;
    IF ( r <> NULL ) THEN P$SetRuler( r ); ENDIF;
  ENDIF;
ENDPROCEDURE  !P$LSE_ruler

PROCEDURE P$LSE_TPUini( Ubuf )
LOCAL pat, sr, line, sl;
  ERASE( $$SCRATCH_BUFFER );
  pat := LINE_BEGIN + "$TPUINI";
  POSITION( BEGINNING_OF( $$LSE_BUFFER ) );
  sr := SEARCH_QUIETLY( pat, FORWARD, NO_EXACT );
  IF ( sr <> 0 ) THEN
    POSITION( BEGINNING_OF( sr ) );
    LOOP
      EXITIF ( F$LSE_get( line, sl ) );  !found "$END(TPUINI)"
      POSITION( $$SCRATCH_BUFFER );
      COPY_TEXT( line );
      SPLIT_LINE;
      POSITION( $$LSE_BUFFER );
      ENDLOOP;
    IF ( GET_INFO( Ubuf, "TYPE" ) = MARKER ) THEN
      POSITION( Ubuf );  !Initialize in context of user's buffer
    ENDIF;
    EXECUTE( $$SCRATCH_BUFFER );  !User's $TPUINI code
    POSITION( $$LSE_BUFFER );
  ENDIF;
ENDPROCEDURE  !P$LSE_TPUini


! === LSE User Callable === !

PROCEDURE COM$SpecialIndent ( arg1 )
LOCAL rm, here, p, ind, spcs, l;
  rm := GET_INFO( CURRENT_BUFFER, "MODE" );
  SET( INSERT, CURRENT_BUFFER );
  here := MARK( NONE );
  p := SEARCH_QUIETLY( "$ IF ", REVERSE, EXACT );
  IF ( p <> 0 ) THEN
    POSITION( p );
    IF ( CURRENT_OFFSET > 0 ) THEN
      ERASE_CHARACTER( 2 );              !delete "$ " before "IF"
      ind := CURRENT_OFFSET - 2;
      IF ( ind > 0 ) THEN
        !Need enough " " to line up THEN/ELSE/ENDIF-lines under their IF
        spcs := K$spc * ind;
        POSITION( LINE_BEGIN );
        MOVE_VERTICAL( +1 );    ! "$ .THEN"
        l := ERASE_LINE;
        EDIT( l, TRIM, IN_PLACE );
        COPY_TEXT( SUBSTR( l, 1, 2 ) + spcs + SUBSTR( l, 3, LENGTH(l)-2 ) );
        SPLIT_LINE;
        l := ERASE_LINE;        ! "$ .ELSE"
        EDIT( l, TRIM, IN_PLACE );
        COPY_TEXT( SUBSTR( l, 1, 2 ) + spcs + SUBSTR( l, 3, LENGTH(l)-2 ) );
        SPLIT_LINE;
        l := ERASE_LINE;        ! "$ .ENDIF"
        EDIT( l, TRIM, IN_PLACE );
        COPY_TEXT( SUBSTR( l, 1, 2 ) + spcs + SUBSTR( l, 3, LENGTH(l)-2 ) );
        SPLIT_LINE;
      ENDIF;
    ENDIF;
  ENDIF;
  POSITION( here );
  SET( rm, CURRENT_BUFFER );
ENDPROCEDURE  !COM$SpecialIndent

PROCEDURE KED$UserYear ( arg1 )
LOCAL rm, here, date, tar, yy;
  rm := GET_INFO( CURRENT_BUFFER, "MODE" );
  SET( INSERT, CURRENT_BUFFER );
  date := FAO( "!%D", 0 );
  here := MARK( NONE );
  yy := SUBSTR( date, 8, 4 );
  POSITION( BEGINNING_OF( CURRENT_BUFFER ) );
  LOOP
    tar := SEARCH_QUIETLY( arg1, FORWARD );
    EXITIF ( tar = 0 );
    IF ( tar <> 0 ) THEN
      POSITION( BEGINNING_OF( tar ) );
      ERASE( tar );
      COPY_TEXT( yy );
    ENDIF;
    ENDLOOP;
  POSITION( here );
  SET( rm, CURRENT_BUFFER );
ENDPROCEDURE  !KED$UserYear

PROCEDURE KED$FileNameType
LOCAL tmp;
  tmp := GET_INFO(CURRENT_BUFFER,"OUTPUT_FILE");
  IF ( GET_INFO(tmp,"TYPE") <> STRING ) THEN tmp := NULL; ENDIF;
  tmp := FILE_PARSE(tmp,NULL,NULL,NAME,TYPE);
  IF ( tmp = "." ) OR ( tmp = "" ) THEN tmp := K$chevrons; ENDIF;
  RETURN( tmp );
ENDPROCEDURE  !KED$FileNameType

PROCEDURE KED$FileName
LOCAL tmp;
  tmp := GET_INFO(CURRENT_BUFFER,"OUTPUT_FILE");
  IF ( GET_INFO(tmp,"TYPE") <> STRING ) THEN tmp := NULL; ENDIF;
  tmp := FILE_PARSE(tmp,NULL,NULL,NAME);
  IF ( tmp = "." ) OR ( tmp = "" ) THEN tmp := K$chevrons; ENDIF;
  RETURN( tmp );
ENDPROCEDURE  !KED$FileName

PROCEDURE KED$LSE_Replace( arg1, arg2; Ubuf )
LOCAL buf, rm, here, tar;
  buf := F$Default( Ubuf, "<>", BUFFER, CURRENT_BUFFER );
  here := MARK( NONE );
  rm := GET_INFO( buf, "MODE" );
  SET( INSERT, buf );
  POSITION( BEGINNING_OF( buf ) );
  LOOP
    tar := SEARCH_QUIETLY( arg1, FORWARD );
    EXITIF ( tar = 0 );
    IF ( tar <> 0 ) THEN
      POSITION( BEGINNING_OF( tar ) );
      ERASE( tar );
      COPY_TEXT( arg2 );
    ENDIF;
    ENDLOOP;
  SET( rm, buf );
  POSITION( here );
ENDPROCEDURE  !KED$LSE_Replace


! === MENU === !

PROCEDURE P$Menu
LOCAL pstr;
ON_ERROR
[TPU$_EXECUTEFAIL]:
  MESSAGE( K$xNF_msg, 0, "User procedure", GV$_Cmenu );
  MESSAGE( "-- supply it in a `/COMMAND=tpuini' command file." );
  P$Menu_End;
  RETURN;
[TPU$_CONTROLC,
 OTHERWISE]: P$0; P$Menu_End; RETURN;
ENDON_ERROR
  CASE ( GV$_Lmenu + GV$_Hmenu ) FROM 0 TO 40
    [2,8,       !do not change these values [2,8]...
     7,         !...[7] currently unused
     OUTRANGE]: !RESUME editing
                P$Post( K$NMA_msg );
                P$Menu_End;
                ABORT;
    [0]: !initial entry-point thru state-machine:
         P$0;
         SET( KEY_MAP_LIST, KML$menu, MESSAGE_BUFFER );
         GV$_Lmenu := 1;
         GV$_Hmenu := 0;
         GV$_Cmenu := NULL;
         pstr := "  DO      SHOW    SET     RECOVER";
         P$ClrMsg;
         P$Menu_Prompt( NULL, pstr );
    [1]: !discover which level-1 choice has been made,
         ! DO/SHOW/SET/RECOVER; cases [2,8] RESERVED for "resume"!
         GV$_Lmenu := 2;  !==> [3,4,5,6, ,8]
         GV$_Hmenu := F$Menu_Word;
         P$Menu;
    [3]: GV$_Lmenu := 31;      !DO
         GV$_Hmenu := 0;
         pstr := "  SPELL   SORT    TRIM    DETAB   CRLF    CLEAN   STRIPV  USER";
         GV$_Cmenu := "DO ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
    [4]: GV$_Lmenu := 9;       !SHOW
         GV$_Hmenu := 0;
         pstr := "  BUFFER  SEARCH  STATUS  PAIRS   "
                     + "LEARN   TABS    CCASE   VERSION";
         GV$_Cmenu := "SHOW ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
    [9]: !SHOW -- discover which level-2 choice has been made:
         P$Menu_Show( F$Menu_Word );
         P$Menu_End;
    [5]: GV$_Lmenu := 11;      !SET
         GV$_Hmenu :=  0;
         pstr := "  SEARCH  STATUS  PAIRS   LEARN   TABS    CCASE";
         GV$_Cmenu := "SET ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
    [6]: !RECOVER -- recover a file/buffer from buffer-journaling:
         P$ClrMsg;
         P$Recover( NULL );
         P$Menu_End;
   [11]: !SET -- discover which level-2 choice has been made:
         GV$_Lmenu := 11;
         GV$_Hmenu := F$Menu_Word;
         P$Menu;  !intermediate pass
   [12]: GV$_Lmenu := 32;               !SET SEARCH
         GV$_Hmenu :=  0;
         pstr := "  wild    literal begin   end     general exact   "
               + "flip    noflip";
         GV$_Cmenu := GV$_Cmenu + "SEARCH ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [32]: CASE F$Menu_Word FROM 1 TO 8  !SET SEARCH
           [1]: GV$_wildmode := TRUE;         !wild
           [2]: GV$_wildmode := FALSE;        !literal
           [3]: GV$_srchbeg  := TRUE;         !begin
           [4]: GV$_srchbeg  := FALSE;        !end
           [5]: GV$_srchcase := NO_EXACT;     !general
           [6]: GV$_srchcase := EXACT;        !exact
           [7]: GV$_srchflip := 1;            !flip
           [8]: GV$_srchflip := 0;            !no-flip
           [OUTRANGE]: P$Post( K$NMA_msg ); !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 2 );
         P$Menu_End;
   [13]: GV$_Lmenu := 33;               !SET STATUS
         GV$_Hmenu :=  0;
         pstr := "  clock   pos     arrow   off";
         GV$_Cmenu := GV$_Cmenu + "STATUS ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [33]: CASE F$Menu_Word FROM 1 TO 4              !SET STATUS
           [1]: P$SetStat( "C",  CURRENT_WINDOW ); !clock
           [2]: P$SetStat( "P",  CURRENT_WINDOW ); !position (normal update)
           [3]: P$SetStat( "PA", CURRENT_WINDOW ); !position (arrow update)
           [4]: P$SetStat( NULL, CURRENT_WINDOW ); !disable status line update
           [OUTRANGE]: P$Post( K$NMA_msg );       !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 3 );
         P$Menu_End;
   [14]: GV$_Lmenu := 34;               !SET PAIRS
         GV$_Hmenu :=  0;
         pstr := "  add     remove  on      off";
         GV$_Cmenu := GV$_Cmenu + "PAIRS ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [34]: CASE F$Menu_Word FROM 1 TO 4  !SET PAIRS
           [1]: P$Smatch;     !add
           [2]: P$Snomatch( NULL );           !remove: interactive use
           [3]: P$Dmatch( G$Base );           !on: reset to initial pairs
           [4]: P$Undmatch( G$Base );         !off
           [OUTRANGE]: P$Post( K$NMA_msg );   !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 4 );
         P$Menu_End;
   [15]: GV$_Lmenu := 35;               !SET LEARN
         GV$_Hmenu :=  0;
         pstr := "  exact   noexact";
         GV$_Cmenu := GV$_Cmenu + "LEARN ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [35]: CASE F$Menu_Word FROM 1 TO 2  !SET LEARN
           [1]: GV$_lmode := EXACT;     !exact
           [2]: GV$_lmode := NO_EXACT;  !general
           [OUTRANGE]: P$Post( K$NMA_msg );    !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 5 );
         P$Menu_End;
   [16]: GV$_Lmenu := 36;               !SET TABS
         GV$_Hmenu :=  0;
         pstr := "  Indent  NoInd   <SPC>   <TAB>";
         GV$_Cmenu := GV$_Cmenu + "TABS ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [36]: CASE F$Menu_Word FROM 1 TO 4  !SET TABS
           [1]: GV$_autotab  := TRUE;   !automatic indentation enabled
           [2]: GV$_autotab  := FALSE;  !automatic indentation disabled
           [3]: GV$_realtabs := FALSE;  !use tabulation: tab-stops via spaces
           [4]: GV$_realtabs := TRUE;   !use real <TAB> characters
           [OUTRANGE]: P$Post( K$NMA_msg );    !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 6 );
         P$Menu_End;
   [17]: GV$_Lmenu := 37;               !SET CCASE
         GV$_Hmenu :=  0;
         pstr := "  Invert  UPPER   lower";
         GV$_Cmenu := GV$_Cmenu + "CCASE ";
         P$Menu_Prompt( GV$_Cmenu, pstr );
   [37]: CASE F$Menu_Word FROM 1 TO 3  !SET CCASE
           [1]: GV$_ccase := INVERT;
           [2]: GV$_ccase := UPPER;
           [3]: GV$_ccase := LOWER;
           [OUTRANGE]: P$Post( K$NMA_msg );    !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$Menu_Show( 7 );
         P$Menu_End;
   [31]: GV$_Cmenu1 := NULL;
         GV$_Cmenu2 := NULL;
         CASE F$Menu_Word FROM 1 TO 8  !DO
           [1]: GV$_Cmenu := "P$Spell";         ! SPELL
           [2]: GV$_Cmenu := "P$Sort";          ! SORT the Select_Range
           [3]: GV$_Cmenu := "P$Edit(K$spc+K$tab,'»','Trailing blank trim')";
           [4]: GV$_Cmenu := "P$Detab";         ! DETAB
           [5]: GV$_Cmenu := "P$Edit(K$cr+K$lf,'R','<CR><LF> removal')";
           [6]: GV$_Cmenu  := "P$Edit(K$ANSI_Str_BOLD,'L',NULL)";
                GV$_Cmenu1 := "P$Edit(K$ANSI_Str_UNDER,'L',NULL)";
                GV$_Cmenu2 := "P$Edit(K$ANSI_Rend,'L','Cleanup')";
           [7]: GV$_Cmenu := "P$StripFVer";     ! STRIPV
           [8]: GV$_Cmenu := "P$User";
           [OUTRANGE]: P$Post( K$NMA_msg );    !RESUME editing
                       P$Menu_End;
                       ABORT;
           ENDCASE;
         P$SwapMsg( FALSE );
         EXECUTE( GV$_Cmenu );
         IF ( GV$_Cmenu1 <> NULL ) THEN EXECUTE( GV$_Cmenu1 ); ENDIF;
         IF ( GV$_Cmenu2 <> NULL ) THEN EXECUTE( GV$_Cmenu2 ); ENDIF;
         P$Menu_End;
   ENDCASE;
ENDPROCEDURE  !P$Menu

PROCEDURE P$Menu_Prompt( cstr, pstr )
  IF ( cstr <> NULL ) THEN
    P$ClrMsg;  !avoid GV$_debug effects
    MESSAGE( cstr );
  ENDIF;
  IF ( CURRENT_WINDOW <> $$MESSAGE_WINDOW ) THEN P$SwapMsg( FALSE ); ENDIF;
  COPY_TEXT( pstr );
  SET( FORWARD, MESSAGE_BUFFER );
  POSITION( BEGINNING_OF( MESSAGE_BUFFER ) );
  IF ( cstr <> NULL ) THEN MOVE_VERTICAL( +1 ); ENDIF;
ENDPROCEDURE  !P$Menu_Prompt

PROCEDURE P$Menu_End
  GV$_Lmenu := 0;  !resets
  GV$_Hmenu := 0;
  GV$_Cmenu := NULL;
  P$SwapMsg( TRUE );
  IF ( LOOKUP_KEY( ENTER, PROGRAM ) <> 0 ) THEN
    UNDEFINE_KEY( ENTER, G$Base );
  ENDIF;
  SET( KEY_MAP_LIST, G$KML, MESSAGE_BUFFER );
  P$RET_ENTER_keys( G$Base );
  P$0;
ENDPROCEDURE  !P$Menu_End

PROCEDURE F$Menu_Word
! return index (cardinal) number of word in menu-string; cursor must 
! be on/within word -- if on interword space, return flag-value:
  IF ( CURRENT_CHARACTER = K$spc ) THEN
    RETURN( -1000 );  !guarantee an OUTRANGE CASE in P$Menu
  ELSE RETURN( ( CURRENT_COLUMN + 5 ) / 8 );
  ENDIF;
ENDPROCEDURE  !F$Menu_Word

PROCEDURE P$Menu_Show( indx )    ! support for command menu
LOCAL buf, code, cbuf, pos, fnam;
  pos  := CURRENT_WINDOW;
  P$ClrMsg;
  CASE indx FROM 0 TO 9
  [OUTRANGE,
   0]: P$Post( K$NMA_msg );
       P$Menu_End;
       ABORT;
  [1]: P$SwapMsg( TRUE );
       cbuf := CURRENT_BUFFER;
       ERASE( TPU$X_SHOW_BUFFER );
       POSITION( TPU$X_SHOW_BUFFER );
       COPY_TEXT( FAO( "!AS!39* !AS!2* !AS",
                       "Buffer name", "Lines", "Characteristics" ) );
       SPLIT_LINE;
       P$Insert( K$so ); P$Do_N( 0, "q", 80 ); P$Insert( K$si ); SPLIT_LINE;
       buf := GET_INFO( BUFFERS, "FIRST" );
       LOOP
         EXITIF ( buf = 0 );
         IF ( INDEX( K$noshow, K$period + GET_INFO( buf, "NAME" )
                                + K$period ) = 0 ) THEN
           IF ( GET_INFO( buf, "NO_WRITE" ) ) THEN code := "RO";
           ELSE code := "R/W";
           ENDIF;
           IF ( GET_INFO( buf, "MODIFIED" ) ) THEN
             code := code + ", Modified";
           ENDIF;
           IF ( buf = cbuf ) THEN code := code + ", [4mCurrent[0m"; ENDIF;
           COPY_TEXT( FAO( "!46AS !8SL!2* !AS",
                           GET_INFO( buf, "NAME" ),
                           GET_INFO( buf, "RECORD_COUNT" ),
                           code ) );  SPLIT_LINE;
           fnam := GET_INFO( buf, "FILE_NAME" );
           IF ( fnam <> NULL ) AND ( GET_INFO( fnam, "TYPE" ) = STRING ) THEN
             EDIT( fnam, LOWER );
             COPY_TEXT( "   In: " + K$ANSI_Str_BOLD + fnam + K$ANSI_Rend );  SPLIT_LINE;
           ENDIF;
           fnam := GET_INFO( buf, "OUTPUT_FILE" );
           IF ( fnam <> NULL ) AND ( GET_INFO( fnam, "TYPE" ) = STRING ) THEN
             EDIT( fnam, LOWER );
             COPY_TEXT( "  Out: " + K$ANSI_Str_BOLD + fnam + K$ANSI_Rend );  SPLIT_LINE;
           ENDIF;
           SPLIT_LINE;
         ENDIF;
         buf := GET_INFO( BUFFERS, "NEXT" );
         ENDLOOP;
       SET( WIDTH, TPU$X_SHOW_WINDOW, GET_INFO( SCREEN, "WIDTH" ) );
       SET( STATUS_LINE, TPU$X_SHOW_WINDOW, REVERSE, K$CTRL_Zp );
       MAP( TPU$X_SHOW_WINDOW, TPU$X_SHOW_BUFFER );
       SET( TEXT, TPU$X_SHOW_WINDOW, NO_TRANSLATE );
       UPDATE( TPU$X_SHOW_WINDOW );
       POSITION ( BEGINNING_OF( TPU$X_SHOW_BUFFER ) );
  [2]: MESSAGE( "Search settings:  "
         + F$Keyword( GV$_wildmode,  TRUE, "Wildcard  ",  "Literal  " )
         + F$Keyword( GV$_srchbeg,   TRUE, "Begin  ",     "End  " )
         + F$Keyword( GV$_srchcase, EXACT, "Exact  ",     "General  ")
         + F$Keyword( GV$_srchflip,     1, "Flip",        "Noflip" ) );
       COPY_TEXT( " Wildcard chars:  "
         + F$Keyword( GV$_wildmode, TRUE, "« * % @ # [|] \ ^ »", NULL ) );
  [3]: IF ( GV$_statdisp = NULL ) THEN MESSAGE( "Status update:  Off" );
       ELSE MESSAGE( "Status update:  "
             + F$Keyword( GV$_statdisp, "C",  "Clock", "Position " )
             + F$Keyword( GV$_statdisp, "PA", "-- arrow update ", NULL )
             + F$Keyword( GV$_statdisp, "C",  NULL, "[Row,Col]" ) );
       ENDIF;
  [4]: P$Show_Match;
  [5]: MESSAGE( "Learn mode:  "
         + F$Keyword( GV$_lmode, EXACT, "EXACT", "NOEXACT" ) );
  [6]: MESSAGE( "Tab mode:  automatic indentation is "
         + F$Keyword( GV$_autotab, TRUE, "ON; ", "OFF; " )
         + F$Keyword( GV$_realtabs, TRUE, "true <TAB>",
                       "tabulation with <SPC>" )
         + " characters" );
  [7]: IF ( GV$_ccase = INVERT ) THEN MESSAGE( "Change-case mode:  Invert" );
       ELSE MESSAGE( "Change-case mode:  "
                     + F$Keyword( GV$_ccase, UPPER, "UPPER", "lower" ) );
       ENDIF;
  [8]: P$Post( K$version );
       MESSAGE( "TPU v" + STR( GET_INFO( SYSTEM, "VERSION" ) ) + K$period
                        + STR( GET_INFO( SYSTEM, "UPDATE" ) )
                + ", Application " + GV$Application
                + ", Keyboard " + GV$Keyboard
                + ", Journaling " + F$Keyword( GV$_JouMeth, "B", "Buffer", "Keystroke" ) );
       POSITION( BEGINNING_OF( TPU$X_MESSAGE_BUFFER ) );
       POSITION( pos );
  ENDCASE;
ENDPROCEDURE  !P$Menu_Show

PROCEDURE P$User
  ! place-holder routine
  P$Post( "Sample user-written `P$User' TPU procedure;" );
  MESSAGE( "-- supply yours in a `/COMMAND=tpuini' command file." );
ENDPROCEDURE  !P$User


! === MOVES === !

PROCEDURE P$Arrowkey
LOCAL lkey;
ON_ERROR
ENDON_ERROR
  CASE LAST_KEY FROM UP TO LEFT
    [UP]:    MOVE_VERTICAL( -1 );
    [DOWN]:  MOVE_VERTICAL( +1 );
    [LEFT]:  MOVE_HORIZONTAL( -1 );
    [RIGHT]: MOVE_HORIZONTAL( +1 );
    ENDCASE;
  P$ChkRuler;
  IF ( GV$_updstat ) THEN P$Status( CURRENT_WINDOW ); ENDIF;
ENDPROCEDURE  !P$Arrowkey

PROCEDURE P$BOL
ON_ERROR
  P$ChkRuler;
ENDON_ERROR
  IF ( CURRENT_OFFSET = 0 ) THEN MOVE_VERTICAL( -1 );
  ELSE POSITION( LINE_BEGIN );
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$BOL

PROCEDURE P$EOL( dir )
ON_ERROR
  P$ChkRuler;
ENDON_ERROR
  IF ( dir = FORWARD ) THEN
    IF ( F$atEOL ) THEN MOVE_HORIZONTAL( +1 ); ENDIF;
  ELSE POSITION( LINE_BEGIN );
    MOVE_VERTICAL( -1 );
  ENDIF;
  POSITION( LINE_END );
  P$ChkRuler;
ENDPROCEDURE  !P$EOL

PROCEDURE P$GotoAbsL
LOCAL absl, maxl;
  absl := F$Prompt( "Absolute line number", NULL, NULL, FALSE );
  IF ( absl = NULL ) THEN RETURN; ENDIF;
  GV$_RngA := 0;
  GV$_RngB := 0;
  absl := INT( absl );
  maxl := GET_INFO( CURRENT_BUFFER, "RECORD_COUNT" );
  IF ( absl > maxl ) THEN absl := maxl; ENDIF;
  POSITION( absl );
ENDPROCEDURE  !P$GotoAbsL

PROCEDURE P$Mark( mrk; mflg )
LOCAL nam, mnam, msg;
  msg  := F$Default( mflg, "<>", INTEGER, TRUE );
  nam  := NULL;
  mnam := NULL;
  CASE mrk FROM "«LBM»" TO "«LGM»"
    ["«LBM»"]: GV$_LastMark{CURRENT_BUFFER} := MARK( NONE ); !Last Buffer Mark
               nam := K$spc + mrk;
    ["«LGM»"]: GV$_LastMark{"«LGM»"} := MARK( NONE );        !Last Global Mark
               nam := K$spc + mrk;
    [INRANGE,
     OUTRANGE]: IF ( mrk = NULL ) THEN
                  mnam := F$Prompt( "Mark name", NULL, "UD", TRUE );
                  IF ( mnam <> NULL ) THEN
                    nam := " `" + mnam + "'";
                    IF ( INDEX( GV$_marks, K$spc + mnam ) = 0 ) THEN
                      GV$_marks := GV$_marks + K$spc + mnam;
                    ENDIF;
                  ENDIF;
                ELSE mnam := mrk;
                ENDIF;
                IF ( mnam <> NULL )
                AND ( INDEX( mnam, "«" ) = 0 ) THEN   !not "«LGM»" or "«LBM»"
                  GV$_LastMark{mnam} := MARK( NONE );
                ENDIF;
    ENDCASE;
  IF ( msg ) THEN MESSAGE( "Position marked!AS", 0, nam ); ENDIF;
ENDPROCEDURE  !P$Mark

PROCEDURE P$GotoMark( mrk )
LOCAL dnam, mnam, tmrk, buf;
  CASE mrk FROM "«LBM»" TO "«LGM»"
    ["«LBM»"]: tmrk := GV$_LastMark{CURRENT_BUFFER};
               P$JumpMark( tmrk, "Last Buffer Marker «LBM» has been lost" );
    ["«LGM»"]: tmrk := GV$_LastMark{"«LGM»"};
               P$JumpMark( tmrk, "Last Global Marker «LGM» has been lost" );
    [INRANGE,
     OUTRANGE]: IF ( mrk = NULL ) THEN
                  dnam := "show marks";
                  mnam := F$Prompt( "Mark", dnam, "UD", TRUE );
                  EDIT( dnam, UPPER );
                  IF ( mnam = dnam ) THEN
                    IF ( GV$_marks = NULL ) THEN
                      mnam := " (none)";
                    ELSE mnam := GV$_marks;
                         P$Post( "Current marks:" + mnam );
                    ENDIF;
                    RETURN;
                  ELSE IF ( INDEX( GV$_marks, mnam ) = 0 ) THEN
                         MESSAGE( "No such mark: `" + mnam + "'" );
                         MESSAGE( "Current marks: " + GV$_marks );
                         RETURN;
                       ENDIF;
                  ENDIF;
                ELSE mnam := mrk;
                ENDIF;
                tmrk := GV$_LastMark{mnam};
                P$JumpMark( tmrk, NULL );
    ENDCASE;
  P$ChkRuler;
ENDPROCEDURE  !P$GotoMark

PROCEDURE P$JumpMark( pos, msg )
LOCAL postype, buf;
  postype := GET_INFO( pos, "TYPE" );
  IF ( postype = MARKER ) THEN
    ! The trick with POSITION() to a marker in another buffer is
    !   to first MAP the buffer to the current window (POSITION
    !   doesn't do that part)...
    buf := GET_INFO( pos, "BUFFER" );
    IF ( buf <> CURRENT_BUFFER ) THEN P$Setbuf( buf ); ENDIF;
    POSITION( pos );
  ELSE IF ( postype = BUFFER ) THEN
         P$Setbuf( pos );
         POSITION( BEGINNING_OF( pos ) );
       ELSE IF ( msg <> NULL ) THEN MESSAGE( msg ); ENDIF;
       ENDIF;
  ENDIF;
ENDPROCEDURE  !P$JumpMark

PROCEDURE P$MouseGoto
LOCAL cl, here, atEol;
  GV$_mdfy := GET_INFO( CURRENT_BUFFER, "MODIFIED" );
  POSITION( MOUSE );
  here  := GET_INFO( CURRENT_BUFFER, "OFFSET_COLUMN" ) - 1;
  atEol := ( F$atEOL );
  IF ( NOT F$atEOB ) THEN
    cl := ERASE_LINE;
    EDIT( cl, TRIM_TRAILING, OFF );
    P$Insert( cl );
    SPLIT_LINE;
    P$BOL;
    IF ( atEOL ) THEN POSITION( LINE_END );
    ELSE MOVE_HORIZONTAL( +here );
    ENDIF;
  ENDIF;
  IF ( GV$_SelectRng = 0 ) THEN
    GV$_MBD_mark := MARK( NONE );        !Mouse-Button Down
  ENDIF;
  P$ChkRuler;
  P$SetMod( GV$_mdfy );
ENDPROCEDURE  !P$MouseGoto          

PROCEDURE P$ShiftWin( opt, dir )
LOCAL i, l, w, d, here;
  d := -1000;
  IF ( opt = "M" ) THEN  ! "M"aximum shift
    IF ( dir = REVERSE ) THEN
      POSITION( LINE_BEGIN );
    ELSE i := 1;         ! Accommodates longest line in this "neighborhood"
      l := -1;
      here := MARK( NONE );
      P$Do_N( "P$MoveL(REVERSE)", NULL, 5 );
      LOOP  !find maximum line length in this neighborhood
        EXITIF ( i > 20 ) OR ( F$atEOB );
        w := LENGTH( CURRENT_LINE );
        IF ( w > l ) THEN l := w; ENDIF;
        P$MoveL( FORWARD );
        i := i + 1;
        ENDLOOP;
      w := GET_INFO( CURRENT_WINDOW, "WIDTH" ) - 8;
      IF ( l > w ) THEN d := l - w; ELSE d := 0; ENDIF;
      POSITION( here );
      IF ( NOT F$atEOL ) THEN P$EOL( FORWARD ); ENDIF;
    ENDIF;
  ELSE  ! standard shift (by 32 characters)
    d := ( GET_INFO( CURRENT_WINDOW, "WIDTH" ) * 100 ) / 250;  !(80/2.5)=32
    IF ( dir = REVERSE ) THEN d := -d; ENDIF;
  ENDIF;
  SHIFT( CURRENT_WINDOW, d );
  P$ChkRuler;
ENDPROCEDURE  !P$ShiftWin

PROCEDURE P$MoveC( dir )
ON_ERROR
  P$ChkRuler;
ENDON_ERROR
  IF ( dir = FORWARD ) THEN MOVE_HORIZONTAL( +1 );
  ELSE MOVE_HORIZONTAL( -1 )
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$MoveC

PROCEDURE P$MoveL( dir )
LOCAL offs;
ON_ERROR
  P$ChkRuler;
ENDON_ERROR
  offs := CURRENT_OFFSET;
  POSITION( LINE_BEGIN );
  IF ( dir = FORWARD ) THEN
    IF NOT ( F$atEOB ) THEN MOVE_VERTICAL( +1 ); ENDIF;
  ELSE IF NOT ( F$atBOB ) THEN
         IF ( offs = 0 ) THEN MOVE_VERTICAL( -1 ); ENDIF;
       ENDIF;
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$MoveL

PROCEDURE P$MoveW( dir )
LOCAL mrk;
ON_ERROR
  P$ChkRuler;
ENDON_ERROR
  IF ( dir = FORWARD ) THEN
    mrk := MARK( NONE );
    P$MoveWFor( GV$_word );
    IF ( mrk = MARK( NONE ) ) THEN MOVE_HORIZONTAL( +1 ); ENDIF;
  ELSE mrk := MARK( NONE );
    P$MoveWRev( GV$_word );
    IF ( mrk = MARK( NONE ) ) THEN MOVE_HORIZONTAL( -1 ); ENDIF;
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$MoveW

PROCEDURE P$MoveWFor( wd )
LOCAL scn, spn, len, rng;
  scn := SCAN( wd ) | LINE_END;
  spn := SPAN( wd ) | LINE_END;
  rng := SEARCH_QUIETLY( scn, FORWARD );   !skip over delimiters
  IF ( rng <> 0 ) THEN
    len := LENGTH( rng );
    IF ( GV$_debug ) THEN
      GV$_RngA := CREATE_RANGE( BEGINNING_OF( rng ),
                                END_OF( rng ), UNDERLINE );
      ENDIF;
    IF ( len = 0 ) OR ( INDEX( wd, CURRENT_CHARACTER ) > 0 ) THEN
      POSITION( rng );
    ELSE MOVE_HORIZONTAL( len );
    ENDIF;
  ENDIF;
  IF ( INDEX( wd, CURRENT_CHARACTER ) > 0 ) THEN
    rng := SEARCH_QUIETLY( spn, FORWARD );   !find next delimiter
    IF ( rng <> 0 ) THEN
      len := LENGTH( rng );
      IF ( GV$_debug ) THEN
        GV$_RngA := CREATE_RANGE( BEGINNING_OF( rng ),
                                  END_OF( rng ), UNDERLINE );
        ENDIF;
    ELSE len := 0;
    ENDIF;
    IF ( len = 0 ) AND ( rng <> 0 ) THEN POSITION( rng );
    ELSE MOVE_HORIZONTAL( len );
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$MoveWFor

PROCEDURE P$MoveWRev( wd )
LOCAL nta, a, rng;
  IF ( CURRENT_OFFSET > 0 ) THEN
    IF ( INDEX( wd, CURRENT_CHARACTER ) = 0 ) THEN MOVE_HORIZONTAL( -1 ); ENDIF;
    nta := NOTANY( wd ) | LINE_BEGIN;
    a   :=    ANY( wd ) | LINE_BEGIN;
    rng := SEARCH_QUIETLY( nta, REVERSE );
    IF ( rng <> 0 ) THEN
      POSITION( BEGINNING_OF( rng ) );
      rng := SEARCH( a, REVERSE );
      POSITION( rng );
      IF ( GV$_debug ) THEN
        GV$_RngA := CREATE_RANGE( BEGINNING_OF( rng ),
                                  END_OF( rng ), UNDERLINE );
      ENDIF;
      IF ( CURRENT_OFFSET > 0 ) THEN MOVE_HORIZONTAL( +1 ); ENDIF;
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$MoveWRev

PROCEDURE P$Page( dir )
LOCAL np;
ON_ERROR
  P$toEOB( dir );
  RETURN;
ENDON_ERROR
  IF ( dir = FORWARD ) THEN MOVE_HORIZONTAL( +1 )
  ELSE MOVE_HORIZONTAL( -1 )
  ENDIF;
  np := SEARCH( PAGE_BREAK, dir );
  POSITION( BEGINNING_OF( np ) );
  P$ChkRuler;
ENDPROCEDURE  !P$Page

PROCEDURE P$Paragraph( dir )
LOCAL bump, pval, mrk, typ, ptar, rng;
ON_ERROR
  P$toEOB( dir );
  RETURN;
ENDON_ERROR;
  IF ( dir = FORWARD ) THEN bump := 1; ELSE bump := 0; ENDIF;
  pval := NULL;
  mrk  := MARK( NONE );
  typ := F$GetFtype( NULL );
  CASE typ
    ["COM"]: ptar := ( LINE_BEGIN
                       + ( SPAN( K$spc_tab ) | NULL
                           | ( "$" + SPAN( K$spc_tab + "!" ) ) )
                       + LINE_END );
             IF ( dir = REVERSE ) THEN MOVE_VERTICAL( -1 ); ENDIF;
    ["PAS",
     "RPA",
     "SCA"]: ptar := ( LINE_BEGIN + MATCH( "BEGIN" ) @pval )
                   | ( LINE_BEGIN
                       + ( SPAN( K$spc_tab ) | NULL )
                       + LINE_END );
             IF ( F$LContains( "BEGIN", K$semicolon ) ) THEN
               MOVE_HORIZONTAL( 1 * bump );
             ENDIF;
    ["TEX"]: ptar := ( LINE_BEGIN + ( "\begin" | "\end" | "\item" ) @pval )
                   | ( LINE_BEGIN
                       + ( SPAN( K$spc_tab ) | NULL )
                       + LINE_END );
             IF ( F$LContains( "\begin;\end;\item", K$semicolon ) ) THEN
               MOVE_HORIZONTAL( 1 * bump );
             ENDIF;
    [INRANGE,
     OUTRANGE]: ptar := ( LINE_BEGIN
                          + ( SPAN( K$spc_tab ) | NULL )
                          + LINE_END );
    ENDCASE;
  IF ( dir = FORWARD ) THEN
    rng := SEARCH( ptar, FORWARD, GV$_srchcase );
  ELSE bump := ( LENGTH( pval ) = 0 );
    MOVE_HORIZONTAL( -1 - bump );
    rng := SEARCH( ptar, REVERSE, GV$_srchcase );
    IF ( rng = 0 ) THEN POSITION( mrk ); ENDIF;
  ENDIF;
  IF ( rng <> 0 ) THEN
    IF  ( GET_INFO( pval, "TYPE" ) = RANGE )
    AND ( LENGTH( pval ) > 0 ) THEN
      POSITION( BEGINNING_OF( rng ) );
    ELSE POSITION( END_OF( rng ) );
         P$MoveL( FORWARD );
    ENDIF;
  ENDIF;
  LOOP  !skip multiple blank lines
    EXITIF ( LENGTH( CURRENT_LINE ) > 0 ) OR F$atBOB OR F$atEOB;
    P$MoveL( dir );
    ENDLOOP;
  P$ChkRuler;
ENDPROCEDURE  !P$Paragraph

PROCEDURE P$Screen( dir )
LOCAL siz, top, bot;
ON_ERROR
ENDON_ERROR
  siz := GET_INFO( CURRENT_WINDOW, "VISIBLE_LENGTH" ) - 2;
  top := GET_INFO( CURRENT_WINDOW, "SCROLL_TOP" );
  bot := GET_INFO( CURRENT_WINDOW, "SCROLL_BOTTOM" );
  POSITION( LINE_BEGIN );
  IF ( dir = FORWARD ) THEN MOVE_VERTICAL( siz - bot + 1 );
  ELSE MOVE_VERTICAL( -( siz - top ) );
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$Screen

PROCEDURE P$toEOB( dir )
  IF ( dir = FORWARD ) THEN POSITION( END_OF( CURRENT_BUFFER ) );
  ELSE POSITION( BEGINNING_OF( CURRENT_BUFFER ) );
  ENDIF;
  P$ChkRuler;
ENDPROCEDURE  !P$toEOB


! === REPORTS === !

PROCEDURE P$Current_C( ; ch )
LOCAL tch, cn, code, ltr;
  IF ( CURRENT_OFFSET = LENGTH( CURRENT_LINE ) )
  THEN MESSAGE( "End-of-Line" );
  ELSE tch := F$Default( ch, "U", UNSPECIFIED, CURRENT_CHARACTER );
       P$Map_CTRLs( tch, cn, ltr );
       code := ASCII( tch );
       IF ( cn = ltr ) THEN
         ltr := "`" + ltr + "'";
       ELSE ltr := "<" + cn + "> or <" + ltr + ">";
       ENDIF;
       MESSAGE( "Character is !AS -- ASCII code is !ZB, %o!OB, %x!XB",
                0, ltr, code, code, code );
  ENDIF;
ENDPROCEDURE  !P$Current_C

PROCEDURE P$Count_L
LOCAL lc, tc, pc;
  lc := F$L_Number( tc );
  IF ( tc <= 0 ) THEN
    lc :=   0;
    pc := 100;
  ELSE IF ( F$atEOB ) THEN lc := tc; ENDIF;
    ! TPU divides with truncation; make it round instead:
    pc := ( ( ( lc * 1000 ) / tc ) + 5 ) / 10;
  ENDIF;
  MESSAGE( "Current line number is !SL, !3SL% of total !SL line!%S",
           0, lc, pc, tc );
ENDPROCEDURE  !P$Count_L

PROCEDURE P$Map_CTRLs( char, cn, ltr )
LOCAL code;
  code := ASCII( char );
  CASE ( code ) FROM 0 TO 255
    [  0]:  cn := "nul";    [  1]:  cn := "soh";    [  2]:  cn := "stx";
    [  3]:  cn := "etx";    [  4]:  cn := "eot";    [  5]:  cn := "enq";
    [  6]:  cn := "ack";    [  7]:  cn := "bel";    [  8]:  cn := "bs";
    [  9]:  cn := "ht";     [ 10]:  cn := "lf";     [ 11]:  cn := "vt";
    [ 12]:  cn := "ff";     [ 13]:  cn := "cr";     [ 14]:  cn := "so";
    [ 15]:  cn := "si";     [ 16]:  cn := "dle";    [ 17]:  cn := "dc1";
    [ 18]:  cn := "dc2";    [ 19]:  cn := "dc3";    [ 20]:  cn := "dc4";
    [ 21]:  cn := "nak";    [ 22]:  cn := "syn";    [ 23]:  cn := "etb";
    [ 24]:  cn := "can";    [ 25]:  cn := "em";     [ 26]:  cn := "sub";
    [ 27]:  cn := "esc";    [ 28]:  cn := "fs";     [ 29]:  cn := "gs";
    [ 30]:  cn := "rs";     [ 31]:  cn := "us";     [ 32]:  cn := "sp";
    [127]:  cn := "del";
    [132]:  cn := "ind";    [133]:  cn := "nel";    [134]:  cn := "ssa";
    [135]:  cn := "esa";    [136]:  cn := "hts";    [137]:  cn := "htj";
    [138]:  cn := "vts";    [139]:  cn := "pld";    [140]:  cn := "plu";
    [141]:  cn := "ri";     [142]:  cn := "ss2";    [143]:  cn := "ss3";
    [144]:  cn := "dcs";    [145]:  cn := "pu1";    [146]:  cn := "pu2";
    [147]:  cn := "sts";    [148]:  cn := "cch";    [149]:  cn := "mw";
    [150]:  cn := "spa";    [151]:  cn := "epa";
    [155]:  cn := "csi";    [156]:  cn := "st";     [157]:  cn := "osc";
    [158]:  cn := "pm";     [159]:  cn := "apc";
    [128, 129, 130, 131,
     152, 153, 154, 164,
     166, 172, 173, 174,
     175, 180, 184, 190,
     208, 222, 240, 254]:  cn := "Reserved";
    [INRANGE,
    OUTRANGE]:  cn := char;
    ENDCASE;
  IF ( ( code >= 0   ) AND ( code <= 31  ) )      !nonprintable control-code?
  OR ( ( code >= 128 ) AND ( code <= 159 ) ) THEN
    ltr := "^" + ASCII( code + 64 );
  ELSE ltr := char;
  ENDIF;
ENDPROCEDURE  !P$Map_CTRLs


! === SEARCH === !

PROCEDURE F$Bldpat( expr )
LOCAL part, strg, ptrn, at_v, i, j, c, lexpr,
      quote, ctrl, mat, alt, meta1, meta2, parcnt;
ON_ERROR
[TPU$_EXECUTEFAIL, TPU$_COMPILEFAIL]:
  MESSAGE( "Pattern failed; Expr: " + expr );
  MESSAGE( "             Pattern: " + ptrn );
  RETURN( NULL );
[TPU$_CONTROLC,
 OTHERWISE]: P$0; ABORT;
ENDON_ERROR
meta1  := "%*@# ";
meta2  := meta1 + "«|\^»";
i      := 1;
parcnt := 0;
part   := NULL;
strg   := NULL;
ptrn   := NULL;
at_v   := " @GV$_RngB";
quote  := FALSE;
ctrl   := FALSE;
mat    := FALSE;
lexpr  := LENGTH( expr );  !invariant
LOOP
  EXITIF ( i > lexpr );
  c := SUBSTR( expr, i, 1 );
  IF ( quote ) THEN
    IF ( c = K$squote ) THEN part := part + "''";  !double it
    ELSE part := part + c;
    ENDIF;
    strg  := strg + c;
    i     := i + 1;
    quote := FALSE;
  ELSE IF ( ctrl ) THEN
         c    := F$Ctrl( c );
         part := part + c;
         strg := strg + c;
         i    := i + 1;
         ctrl := FALSE;
ELSE CASE c FROM " " TO "»"
["\"]: ! quote next character
       quote := TRUE;
       i     := i + 1;
["^"]: ! CTRL next character
       ctrl := TRUE;
       i    := i + 1;
["«"]: ! Begin-of-line
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       P$Bpat2( "+", ptrn, part, parcnt );
       ptrn := ptrn + " + LINE_BEGIN";
       at_v := NULL;
       i    := i + 1;
["»"]: ! End-of-line
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       P$Bpat2( "+", ptrn, part, parcnt );
       ptrn := ptrn + " + LINE_END";
       at_v := NULL;
       i    := i + 1;
["|"]: ! alternation:
       alt := TRUE;
       P$Bpat1( ptrn, mat, part, ") +" );
       P$Bpat2( "|", ptrn, part, parcnt );
       i   := i + 1;
["["]: ! begin grouping (for alternation):
       P$Bpat1( ptrn, mat, part, ")" );
       IF  ( INDEX( meta2, SUBSTR( expr, i + 1, 1 ) ) = 0 )
       AND ( i < lexpr ) THEN P$Bpat2( "+", ptrn, part, parcnt ); ENDIF;
       P$Bpat2( "(", ptrn, part, parcnt );
       i := i + 1;
["]"]: ! end grouping (for alternation):
       P$Bpat1( ptrn, mat, part, ")" );
       IF ( INDEX( meta2, SUBSTR( expr, i + 1, 1 ) ) > 0 )
       OR ( i >= lexpr ) THEN P$Bpat2( ")", ptrn, part, parcnt );
       ELSE P$Bpat2( ") +", ptrn, part, parcnt );
       ENDIF;
       i := i + 1;
["*"]: ! general multi-char wildcard:
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       LOOP   !eat any trailing wild's
         EXITIF ( i > lexpr )
             OR ( INDEX( meta1, SUBSTR( expr, i, 1 ) ) = 0 );
         i := i + 1;
         ENDLOOP;
       IF ( i > lexpr ) THEN   ! Use REMAIN if at end of expr
         P$Bpat2( "+", ptrn, part, parcnt );
         ptrn := ptrn + " + REMAIN";
       ELSE P$Bpat2( "+", ptrn, part, parcnt );
         ! use REMAIN if BOL or EOL follows:
         IF ( SUBSTR( expr, i, 1 ) = "«" )
         OR ( SUBSTR( expr, i, 1 ) = "»" ) THEN ptrn := ptrn + " + REMAIN";
         ELSE IF ( SUBSTR( expr, i, 1 ) = "[" ) THEN    !span intermediate chars
                ptrn := ptrn + " + GV$_wildpat";
              ELSE ! Accumulate MATCH chars until another meta is found
                IF ( ptrn = NULL ) THEN at_v := NULL; ENDIF;
                ptrn := ptrn + at_v + " + MATCH(";
                at_v := NULL;
                mat  := TRUE;
              ENDIF;
         ENDIF;
       ENDIF;
["%"]: ! single-char wildcard:
       alt := FALSE;
       j   := 0;
       LOOP  ! count consecutive %'s:
         EXITIF ( i > lexpr ) OR ( SUBSTR( expr, i, 1 ) <> "%" );
         i := i + 1;
         j := j + 1;
         ENDLOOP;
       P$Bpat2( "+", ptrn, part, parcnt );
       IF ( ptrn = NULL ) THEN at_v := NULL; ENDIF;
       ptrn := ptrn + " + ARB(" + STR( j ) + ")";
["@"]: ! multi-char alpha (only) wildcard:
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       P$Bpat2( "+", ptrn, part, parcnt );
       ptrn := ptrn + " + SPAN(K$LETTERS)";
       at_v := NULL;
       i    := i + 1;
["#"]: ! multi-char numeric (only) wildcard:
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       P$Bpat2( "+", ptrn, part, parcnt );
       ptrn := ptrn + " + SPAN(K$DIGITS)";
       at_v := NULL;
       i    := i + 1;
[" "]: ! multi-char whitespace (only) wildcard:
       alt := FALSE;
       P$Bpat1( ptrn, mat, part, ")" );
       P$Bpat2( "+", ptrn, part, parcnt );
       ptrn := ptrn + " + SPAN(K$WHITESPACE)";
       at_v := NULL;
       i    := i + 1;
["'"]: ! double apostrophes in partial string:
       part := part + "''";  !double it
       strg := strg + "'";
       i    := i + 1;
[INRANGE,
OUTRANGE]: ! just an ordinary character:
       part := part + c;
       strg := strg + c;
       i    := i + 1;
ENDCASE;
ENDIF;  !IF ( cntl )
ENDIF;  !IF ( quote )
ENDLOOP;
  IF ( part <> NULL ) AND ( ptrn <> NULL ) THEN
    IF ( mat ) THEN P$Bpat1( ptrn, mat, part, ")" );
    ELSE IF ( alt ) THEN ptrn := ptrn + " '" + part + "'" ;
         ELSE ptrn := ptrn + " + '" + part + "'" ;
         ENDIF;
    ENDIF;
  ENDIF;
  IF ( ptrn <> NULL ) THEN
    IF ( SUBSTR( ptrn, 1, 3 ) = " + " ) THEN     !strip leading " + "
      ptrn := SUBSTR( ptrn, 4, LENGTH( ptrn ) - 3 );
    ENDIF;
    LOOP
      EXITIF ( parcnt <= 0 );
      ptrn := ptrn + " )";
      parcnt := parcnt - 1;
      ENDLOOP;
    IF ( GV$_debug ) THEN
      MESSAGE( "GV$_wildtar := " + ptrn + at_v + K$semicolon );
    ENDIF;
    EXECUTE( "GV$_wildtar := " + ptrn + at_v );
  ELSE GV$_wildtar := strg;
    IF ( GV$_debug ) THEN
      MESSAGE( "GV$_wildtar := " + GV$_wildtar );
    ENDIF;
  ENDIF;
  RETURN( GV$_wildtar );
ENDPROCEDURE  !F$Bldpat

PROCEDURE P$Bpat1( pat, strt, part, gc )
  IF ( strt ) THEN
    pat  := pat + "'" + part + "'" + gc;
    strt := FALSE;
    part := NULL;
  ENDIF;
ENDPROCEDURE  !P$Bpat1

PROCEDURE P$Bpat2( op, pat, part, parcnt )
LOCAL qp;
  IF ( part = NULL ) THEN qp := NULL;
  ELSE qp := "'" + part + "'";
  ENDIF;
  IF ( op = "(" ) THEN
    pat := pat + qp + " + '' + ( ";
    parcnt := parcnt + 1;
  ENDIF;
  IF ( part <> NULL ) THEN
    IF ( op = "+" ) THEN pat := pat + " + " + qp;
    ELSE IF ( op = "|" ) OR ( op = ")" ) OR ( op = ") +" ) THEN
           pat := pat + qp + K$spc + op + K$spc;
           IF ( op = ")" ) OR ( op = ") +" ) THEN
             parcnt := parcnt - 1;
           ENDIF;
         ENDIF;
    ENDIF;
  ENDIF;
  part := NULL;
ENDPROCEDURE  !P$Bpat2

PROCEDURE F$Bump
LOCAL bump;
ON_ERROR
  RETURN( bump );
ENDON_ERROR
  IF ( F$atBOB ) OR ( F$atEOB ) THEN
    bump := 0;
  ELSE IF ( CURRENT_DIRECTION = FORWARD ) THEN
         bump := 1;
       ELSE bump := -1;
       ENDIF;
  ENDIF;
  MOVE_HORIZONTAL( bump ); !avoid refinding same target
  RETURN( bump );
ENDPROCEDURE  !F$Bump

PROCEDURE P$FindReplaceNext
  IF ( GET_INFO( GV$_SearchRng, "TYPE" ) = RANGE ) THEN
    IF ( GV$_SearchRng <> 0 ) THEN
      GV$_delstr := STR( GV$_SearchRng );
      ERASE( GV$_SearchRng );
      P$Insert ( GV$_replstr );
      IF ( CURRENT_DIRECTION = REVERSE ) THEN
        MOVE_HORIZONTAL( -LENGTH( GV$_replstr ) );
      ENDIF;
      UPDATE( CURRENT_WINDOW );
    ENDIF;
  ENDIF;
  P$STarget( F$Bump, GV$_srchtar );
ENDPROCEDURE  !P$FindReplaceNext

PROCEDURE P$FindReplace( pr )
LOCAL p, p2;
  IF ( pr ) THEN
    p := "(" + F$Keyword( GV$_srchcase, EXACT, "exact", "general" )
       + ") Search target: ";
    GV$_srchtar := READ_LINE( p );
    IF ( GV$_srchtar = NULL ) THEN RETURN; ENDIF;
    P$STarget( F$Bump, GV$_srchtar );
    p2 := "Replacement";
    UPDATE( CURRENT_WINDOW );
  ELSE p2 := "Change to";
  ENDIF;
  IF ( GET_INFO( GV$_SearchRng, "TYPE" ) = RANGE ) AND ( GV$_SearchRng <> 0 ) THEN
    p := "Search target: `"+ GV$_srchtar + "' | " + p2 + ": ";
    GV$_replstr := READ_LINE( p );
    P$FindReplaceNext;
  ENDIF;
ENDPROCEDURE  !P$FindReplace

PROCEDURE P$Search
LOCAL p;
  p := "(" + F$Keyword( GV$_wildmode, TRUE, "wild/", NULL )
     + F$Keyword( GV$_srchcase, EXACT, "exact", "general" )
     + ") Search target: ";
  GV$_srchtext := READ_LINE( p );
  IF ( GV$_srchtext <> NULL ) THEN
    IF ( GV$_wildmode ) THEN
      GV$_srchtar := F$Bldpat( GV$_srchtext );
    ELSE GV$_srchtar := GV$_srchtext;
    ENDIF;
    GV$_flipR := 0;
    P$STarget( F$Bump, GV$_srchtar );
  ENDIF;
ENDPROCEDURE  !P$Search

PROCEDURE F$SearchEngine( bump, tar, flip )
LOCAL dir, obj, fmsg;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: P$0; ABORT;
ENDON_ERROR
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( flip > 1 ) THEN fmsg := "flip-search...";
  ELSE fmsg := "searching...";
  ENDIF;
  SET( TIMER, ON, fmsg );
  GV$_SearchRng := SEARCH_QUIETLY( tar, CURRENT_DIRECTION, GV$_srchcase );
  IF ( GV$_SearchRng = 0 ) THEN
    MOVE_HORIZONTAL( -bump );  !recover bump-off
    CASE flip FROM 0 TO 2
      [0,
       2]: P$SearchErr( tar );
      [1]: dir := CURRENT_DIRECTION;
           SET( F$FlipDir, CURRENT_BUFFER );
           IF ( F$SearchEngine( F$Bump, tar, flip + 1 ) ) THEN
             GV$_flipR := GV$_SearchRng;
             GV$_SearchRng := 0;  !force fail
             MOVE_HORIZONTAL( bump );  !recover bump-off
             IF ( GET_INFO( tar, "TYPE") = PATTERN ) THEN obj := "Pattern";
             ELSE IF ( tar = K$chevrons ) THEN obj := K$chevrons;
                  ELSE obj := FAO( "String `!AS'", tar );
                  ENDIF;
             ENDIF;
             MESSAGE( obj + " found in opposite direction" );
           ENDIF;
           SET( dir, CURRENT_BUFFER );
      ENDCASE;
    ENDIF;
  SET( TIMER, OFF, NULL );
  RETURN( GV$_SearchRng <> 0 );
ENDPROCEDURE  !F$SearchEngine

PROCEDURE P$SearchErr( tar )
LOCAL obj;
  obj := NULL;
  IF ( CURRENT_BUFFER = $$LIST_BUFFER ) THEN obj := "Compilation error `-E-'";
  ELSE IF ( GET_INFO( tar, "TYPE") = PATTERN ) THEN obj := "Pattern";
       ELSE IF ( tar = K$chevrons ) THEN obj := K$chevrons;
            ENDIF;
       ENDIF;
  ENDIF;
  IF ( obj = NULL ) THEN
    MESSAGE( K$xNF_msg, 0, "String", tar );
  ELSE MESSAGE( obj + " not found" );
  ENDIF;
  P$0;
  RETURN;
ENDPROCEDURE  !P$SearchErr

PROCEDURE P$SearchInit
  IF ( LAST_KEY = KP4 ) THEN SET( FORWARD, CURRENT_BUFFER );
  ELSE IF ( LAST_KEY = KP5 ) THEN SET( REVERSE, CURRENT_BUFFER ); ENDIF;
  ENDIF;
  P$Reset( TRUE );
ENDPROCEDURE  !P$SearchInit

PROCEDURE P$SearchPos( r )
  GV$_SearchRng := F$UlSearch( r );
  IF ( GV$_srchbeg ) THEN POSITION( BEGINNING_OF( r ) );
  ELSE POSITION( END_OF( r ) );
    MOVE_HORIZONTAL( +1 );
  ENDIF;
ENDPROCEDURE  !P$SearchPos

PROCEDURE P$SearchForSR
LOCAL here;
  here := MARK( NONE );
  P$SelectRange;
  IF ( GV$_SelectRng <> 0 ) THEN
    GV$_srchtar := STR( GV$_SelectRng );
    IF ( GET_INFO( here, "BUFFER" ) = GET_INFO( GV$_SelectRng, "BUFFER" ) ) THEN
      IF ( CURRENT_DIRECTION = REVERSE ) THEN
        POSITION( BEGINNING_OF( GV$_SelectRng ) );
      ENDIF;
    ENDIF;
    GV$_SelectRng := 0;
    GV$_flipR := 0;
    P$STarget( F$Bump, GV$_srchtar );
  ENDIF;
ENDPROCEDURE  !P$SearchForSR

PROCEDURE P$STarget( bump, tar )
  P$SearchInit;
  IF ( tar = NULL ) THEN
    P$Search;
  ELSE IF ( GV$_flipR <> 0 ) THEN
         P$SearchPos( GV$_flipR );
         GV$_SearchRng := F$UlSearch( GV$_flipR );
       ELSE IF ( F$SearchEngine( bump, tar, GV$_srchflip ) ) THEN
              IF ( tar = K$chevrons ) THEN
                GV$_RngA := 0;
                GV$_RngB := 0;
                POSITION( GV$_SearchRng );
                ERASE( GV$_SearchRng );
              ELSE P$SearchPos( GV$_SearchRng );
              ENDIF;
              P$ChkRuler;
            ENDIF;
            P$Status( CURRENT_WINDOW );
            IF GV$_debug THEN
              IF  ( GET_INFO( tar, "TYPE" ) = PATTERN )
              AND ( GV$_RngB <> 0 ) AND ( GV$_SearchRng <> 0 ) THEN
                MESSAGE( "Matched: `" + STR( GV$_RngB ) + "'" );
              ENDIF;
            ENDIF;
            IF ( GV$_SearchRng = 0 ) THEN
              P$0; ABORT;  !repeat is short-circuited
            ENDIF;
       ENDIF;
       GV$_flipR := 0;  !forget flip-range
  ENDIF;
ENDPROCEDURE  !P$STarget

PROCEDURE P$SpecSearch
LOCAL b, p;
  IF ( CURRENT_BUFFER = $$LIST_BUFFER ) THEN
    P$STarget( F$Bump, GV$_CmplErr );  ! find next error text "-E-<text>,"
  ELSE ! display current search target string/pattern:
    b := ( GET_INFO( GV$_srchtar, "TYPE" ) = PATTERN );
    p := "Current search " + F$Keyword( b, TRUE, "pattern", "string" );
    MESSAGE( p + ": `" + GV$_srchtext + "'" );
  ENDIF; 
ENDPROCEDURE  !P$SpecSearch

PROCEDURE F$UlSearch( tr )
LOCAL rng;
  IF ( GET_INFO( tr, "TYPE") = BUFFER )
  OR ( GET_INFO( tr, "TYPE") = RANGE ) THEN
    rng := CREATE_RANGE( BEGINNING_OF( tr ), END_OF( tr ), UNDERLINE );
  ENDIF;
  RETURN( rng );
ENDPROCEDURE  !F$UlSearch


! === TOGGLES === !

PROCEDURE F$FlipDir
  IF ( CURRENT_DIRECTION = FORWARD ) THEN RETURN( REVERSE );
  ELSE RETURN( FORWARD );
  ENDIF;
ENDPROCEDURE  !F$FlipDir

PROCEDURE P$ScrW
LOCAL w;
  IF ( GET_INFO( CURRENT_WINDOW, "WIDTH") > 80 ) THEN w := 80;
  ELSE w := 132;
  ENDIF;
  SET( WIDTH, CURRENT_WINDOW,  w );
ENDPROCEDURE  !P$ScrW

PROCEDURE P$Modes
LOCAL m;
  IF ( GET_INFO( CURRENT_BUFFER, "MODE" ) = OVERSTRIKE ) THEN m := INSERT;
  ELSE m := OVERSTRIKE;
  ENDIF;
  SET( m, CURRENT_BUFFER );
  P$Status( CURRENT_WINDOW );
ENDPROCEDURE  !P$Modes

PROCEDURE P$RW
LOCAL o;
  IF ( GET_INFO( CURRENT_BUFFER, "NO_WRITE" ) ) THEN o := OFF;
  ELSE o := ON;
  ENDIF;
  SET( NO_WRITE, CURRENT_BUFFER, o );
ENDPROCEDURE  !P$RW

PROCEDURE P$Transl
LOCAL s, t;
  IF ( GET_INFO( CURRENT_WINDOW, "TEXT" ) = BLANK_TABS ) THEN
    IF ( GV$_realtabs ) THEN t := GRAPHIC_TABS;
    ELSE t := NO_TRANSLATE;
    ENDIF;
  ELSE t := BLANK_TABS;
  ENDIF;
  P$Status( CURRENT_WINDOW );
  SET( TEXT, CURRENT_WINDOW, t );
  REFRESH;
  IF ( t = NO_TRANSLATE ) THEN
    s := " ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ ";
    P$Post( s );
    MESSAGE( K$so + s + K$si );
  ELSE ERASE( MESSAGE_BUFFER );
  ENDIF;
ENDPROCEDURE  !P$Transl

PROCEDURE P$Surround( Sseq, Eseq )
LOCAL tpos;
  P$SelectRange;
  IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE ) THEN
    tpos := MARK( NONE );
    POSITION( BEGINNING_OF( GV$_SelectRng ) );
    P$Insert( Sseq );
    POSITION( END_OF( GV$_SelectRng ) );
    MOVE_HORIZONTAL( +1 );
    P$Insert( ESeq );
    GV$_SelectRng := 0;
    GV$_RngA := 0;
    GV$_RngB := 0;
  ELSE MESSAGE( K$NSA_msg, 0, "P$Surround" );
  ENDIF;
ENDPROCEDURE  !P$Surround

PROCEDURE P$Smatch
LOCAL ochr, cchr, xchr, t1, t2;
  ochr := READ_LINE( "Match Open character: " );
  IF ( ochr = NULL ) THEN RETURN; ENDIF;
  cchr := READ_LINE( "Open `" + ochr + "';  Close character: " );
  IF ( cchr = NULL ) THEN RETURN; ENDIF;
  xchr := READ_LINE( "Open `" + ochr + "', Close `" + cchr
                     + "';  Extra character: " );
  IF ( LENGTH( ochr ) > 1)
    OR ( LENGTH( cchr ) > 1 )
    OR ( LENGTH( xchr ) > 1 ) THEN
    P$Post( "Use single characters for matching" );
    RETURN;
  ENDIF;
  IF ( INDEX( GV$_Mopen, ochr ) > 0 ) THEN P$Snomatch( ochr ); ENDIF;
  IF ( INDEX( GV$_Mopen, ochr ) = 0 ) THEN
    GV$_Mopen  := GV$_Mopen  + ochr;
    GV$_Mclose := GV$_Mclose + cchr;
    IF ( ochr = K$dquote ) THEN t1 := K$squote + ochr + K$squote;
    ELSE t1 := K$dquote + ochr + K$dquote;
    ENDIF;
    IF ( xchr = K$dquote ) THEN t2 := K$squote + xchr + K$squote;
    ELSE t2 := K$dquote + xchr + K$dquote;
    ENDIF;
    DEFINE_KEY( 'P$Imatched(' + t1 + ',' + t2 + ')',
                KEY_NAME( ochr ), "", G$Base  );
  ELSE P$Post( "`" + ochr + "' already in Match-pairs" );
    RETURN;
  ENDIF;
  P$Show_Match;
ENDPROCEDURE  !P$Smatch

PROCEDURE P$Snomatch( arg )
LOCAL pos, ochr;
  ochr := arg;
  IF ( ochr = NULL ) THEN
    ochr := READ_LINE( "Match Open character to disable: " );
  ENDIF;
  IF ( ochr = NULL ) THEN RETURN; ENDIF;
  pos := INDEX( GV$_Mopen, ochr );
  IF ( pos <> 0 ) THEN
    UNDEFINE_KEY( KEY_NAME( ochr ), G$Base  );
    GV$_Mopen  := SUBSTR( GV$_Mopen, 1, pos - 1 )
                + SUBSTR( GV$_Mopen, pos+1, LENGTH( GV$_Mopen ) - pos );
    GV$_Mclose := SUBSTR( GV$_Mclose, 1, pos - 1 )
                + SUBSTR( GV$_Mclose, pos+1, LENGTH( GV$_Mclose ) - pos );
  ENDIF;
  P$Show_Match;
ENDPROCEDURE  !P$Snomatch

PROCEDURE P$Show_Match
  IF ( GV$_Mopen = NULL ) THEN P$Post( "Match off" );
  ELSE P$Post( "Match Pairs:  " + GV$_Mopen );
    COPY_TEXT( (K$spc * 14) + GV$_Mclose );
  ENDIF;
ENDPROCEDURE  !P$Show_Match


! === TRANSFORMS/TOOLS === !

PROCEDURE P$Ccase
  P$SelectRange;
  IF ( GV$_SelectRng = 0 ) THEN
    GV$_SelectRng := CREATE_RANGE( MARK( NONE ), MARK( NONE ), NONE );
    IF ( CURRENT_DIRECTION = FORWARD ) THEN MOVE_HORIZONTAL( +1 );
    ELSE MOVE_HORIZONTAL( -1 );
    ENDIF;
  ENDIF;
  CHANGE_CASE( GV$_SelectRng, GV$_ccase );
  GV$_SelectRng := 0;
ENDPROCEDURE  !P$Ccase

PROCEDURE P$Detab
LOCAL opos, tp, rng, n;
ON_ERROR
  P$ToolEnd( "<Tab> removal", , opos );
  RETURN;
ENDON_ERROR
  opos := MARK( NONE );
  GV$_RngA := 0;
  GV$_RngB := 0;
  POSITION( BEGINNING_OF( CURRENT_BUFFER ) );
  tp := ( K$tab @rng );
  SET( TIMER, ON, "working..." );
  LOOP  !<Tab>-not-found forces exit
    SEARCH( tp, FORWARD );
    POSITION( BEGINNING_OF( rng ) );
    ERASE( rng );
    n := CURRENT_OFFSET;
    n := n - ( 8 * ( n / 8 ) );
    P$Insert( SUBSTR( (K$spc * 8), 1, 8 - n ) );
    ENDLOOP;
ENDPROCEDURE  !P$Detab

PROCEDURE P$StripFVer
LOCAL ro, opos, tp, rng, r, tar, vr, rpl;
  P$ToolBegin( ro, opos, rng );
  rpl := F$Prompt( "Replacement version-string [ ; ;0 (etc.)]", "", "", FALSE );
  POSITION( BEGINNING_OF( rng ) );
  ! a "filespec" pattern (must use local to capture sub-range "@vr")
  tp := ( SPAN( K$IDENTCHARS ) + "::" | NULL )              ! node::
      & ( SPAN( K$IDENTCHARS ) + ":" | NULL )               ! dev:
      & ( "[" + SPAN( K$IDENTCHARS + "." ) + "]" | NULL )   ! [dir.sub]
      & ( SPAN( K$IDENTCHARS ) | NULL )                     ! filename
      & "." & ( SPAN( K$IDENTCHARS ) | NULL )               ! .type
      & ( ( ";" & ( SPAN( K$DIGITS ) ) )@vr );              ! ;version
  SET( TIMER, ON, "working..." );
  LOOP  !pattern-not-found forces exit
    tar := SEARCH_QUIETLY( tp, FORWARD );
    IF ( tar <> 0 ) THEN
      POSITION( tar );
      IF ( MARK( NONE ) < END_OF( rng ) ) THEN
        ! strip any ";version" from filespec
        IF ( GET_INFO( vr, "TYPE" ) = RANGE ) THEN
          !message( "`" + substr(vr,1,length(vr)) + "'" );
          POSITION( END_OF( vr ) );
          ERASE( vr );                  ! delete the ";version"
          IF ( rpl <> NULL ) THEN
            COPY_TEXT( rpl );           ! replace it with ";" or ";0", etc.
          ENDIF;
        ENDIF;
      ELSE EXITIF( TRUE );
      ENDIF;
    ELSE EXITIF ( TRUE );
    ENDIF;
    ENDLOOP;
  GV$_SelectRng := 0;
  P$ToolEnd( '";N" file-version stripping', , opos );
ENDPROCEDURE  !P$StripFVer

PROCEDURE P$Edit( st, sel, msg )
LOCAL opos, tp, rng, r, tar;
  opos := MARK( NONE );
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( GV$_SelectRngStart <> 0 ) THEN
    P$SelectRange;
    rng := GV$_SelectRng;
  ELSE rng := CREATE_RANGE( BEGINNING_OF( CURRENT_BUFFER ),
                            END_OF( CURRENT_BUFFER ), NONE );
  ENDIF;
  POSITION( BEGINNING_OF( rng ) );
  CASE sel FROM "L" TO "»"
    ["L"]: tp := ( st  @r );                     !Remove literal "string"
    ["R"]: tp := ( SPAN( st ) @r );              !Remove "string" pattern
    ["«"]: tp := LINE_BEGIN + ( SPAN( st ) @r ); !Trim leading blanks
    ["»"]: tp := ( SPAN( st ) @r ) + LINE_END;   !Trim trailing blanks
    ENDCASE;
  SET( TIMER, ON, "working..." );
  LOOP  !pattern-not-found forces exit
    tar := SEARCH_QUIETLY( tp, FORWARD );
    EXITIF ( tar = 0 );
    POSITION( tar );
    IF ( MARK( NONE ) < END_OF( rng ) ) THEN
      ERASE( r );
    ELSE EXITIF( TRUE );
    ENDIF;
    ENDLOOP;
  GV$_SelectRng := 0;
  P$ToolEnd( msg, , opos );
ENDPROCEDURE  !P$Edit

PROCEDURE P$FVD
LOCAL rm, sel, sep, nv;
  rm := GET_INFO( CURRENT_BUFFER, "MODE" );
  SET( INSERT, CURRENT_BUFFER );
  sep := NULL;
  sel := F$Prompt( "Filename/Version/Datetime", "FVD", "UD", FALSE );
  IF ( sel <> NULL ) THEN
    P$Insert( "''" );
    MOVE_HORIZONTAL( -1 );
  ENDIF;
  IF ( INDEX( sel, "F" ) > 0 ) THEN
    nv := FILE_PARSE( GET_INFO( CURRENT_BUFFER, "FILE_NAME" ),
                      NULL, NULL, NAME );
    IF ( nv = NULL ) THEN
      nv := FILE_PARSE( GET_INFO( CURRENT_BUFFER, "OUTPUT_FILE" ),
                        NULL, NULL, NAME );
      IF ( nv = NULL ) THEN nv := "(No_Filename)"; ENDIF;
    ENDIF;
    P$Insert( nv );
    sep := K$spc;
  ENDIF;
  !create "v.XXX" string out of CURRENT_BUFFER's input-file version number:
  IF ( INDEX( sel, "V" ) > 0 ) THEN
    nv := FILE_PARSE( GET_INFO( CURRENT_BUFFER, "FILE_NAME" ),
                      NULL, NULL, VERSION );
    nv := SUBSTR( nv, 2, LENGTH( nv ) );
    IF ( nv = NULL ) THEN nv := 0; ENDIF;
    P$Insert( sep + "v." + STR( INT( nv ) + 1 ) );
    sep := K$spc;
  ENDIF;
  IF ( INDEX( sel, "D" ) > 0 ) THEN
    nv := FAO( "!%D", 0 );
    nv := SUBSTR( nv, 1, INDEX( nv, ":" ) + 2 );
    EDIT( nv, TRIM_LEADING );
    P$Insert( sep + "("  + nv + ")" );
  ENDIF;
  MOVE_HORIZONTAL( +1 );
  SET( rm, CURRENT_BUFFER );  !restore insert/overstrike mode
ENDPROCEDURE  !P$FVD

PROCEDURE P$FAO_Directives
! Aids in inserting hard-to-remember FAO formatting directives.
!   !DD         One directive
!   !n(DD)      Directive repeated "n" times
!   !lenDD      Directive's output in a field of length "len"
!   !n(lenDD)   Combo of previous two
LOCAL ans, strg, repo;
  strg := NULL;
  repo := 0;
  ans := F$Prompt( "FAO directive", NULL, "NU", FALSE );
  IF ( LENGTH( ans ) > 4 ) THEN ans := SUBSTR( ans, 1, 4 ); ENDIF;
  CASE ans FROM K$tab TO "___"
    ["?"]: MESSAGE( "  General directives: [1m!DD  !n(DD)  !lenDD  !n(lenDD)[0m" );
           MESSAGE( "  Number-expressions:      [1m!#(DD)  !#DD    !#(#DD)[0m   (value is M-th argument)")
    [K$tab,
     "TAB",
     "_"]: strg := "!_";       !FAO <tab>
    [K$ff,
     "FF",
     "^"]: strg := "!^";       !FAO <ff>
    [K$lf, K$cr,
     "LF", "CR",
     "/"]: strg := "!/";       !FAO <cr><lf>
    ["BANG",
     "EX", "EXCL",
     "!"]: strg := "!!";       !FAO literal "!"
    ["A",
     "ASC",
     "STR",
     "ASCI",
     "STRI"]: strg := "!AS";   !ASCII string
    ["O",
     "OCT",
     "OCTA"]: strg := "!OL";   !integer in octal
    ["H", "X",
     "HEX",
     "HEXA"]: strg := "!XL";   !integer in hexadecimal
    ["D", "Z",
     "DEC",
     "DECI"]: strg := "!ZL";   !integer in decimal
    ["U",
     "UNS",
     "UNSI"]: strg := "!UL";   !unsigned integer
    ["S",
     "SIG",
     "SIGN"]: strg := "!SL";   !signed integer
    ["P",
     "PLU",
     "PLUR"]: strg := "!%S";   !adds "s" if previous dir-arg <> 1
    ["UIC"]:  strg := "!%U";   !longword-int to UIC "[grp,mem]"
    ["LJ",
     "LEFT"]: strg := "!#<«»!>";   !left-just data «» in field of N chars
              repo := 6;
    ["*", "R",
     "REP",
     "REPE"]: strg := "!#*«»";  !repeats «»-<char> N times
              repo := 4;
    ["C",
     "CON",
     "COND",
     "IF"]:   strg := "!1%C«»!%E«»!%F";  !conditional text insertion
              repo := 12;
    ["TIM",
     "TIME"]: strg := "!%T";   !current time
    ["DAT",
     "DATE"]: strg := "!%D";   !current date/time
    ["REU",
     "REUS"]: strg := "!-";    !reuse the previous (last) argument
    ["SKI",
     "SKIP"]: strg := "!+";    !skips the next argument
    [INRANGE,
     OUTRANGE]: strg := NULL;
    ENDCASE;
  IF ( strg <> NULL ) THEN
    P$Insert( strg );
    IF ( repo > 0 ) THEN MOVE_HORIZONTAL( -repo ); ENDIF;
  ENDIF;
ENDPROCEDURE  !P$FAO_Directives

PROCEDURE P$Spell
LOCAL ro, opos, rng, tmp, lno, cno, cstr;
  P$ToolBegin( ro, opos, rng );
  lno := F$L_Number ( cno );
  cno := GET_INFO( CURRENT_BUFFER, "OFFSET" );
  !retain source-file's .TYP for SPELL context sensitivity:
  tmp := FILE_PARSE( F$GetFname( "OUTPUT_FILE", "FILE_NAME" ),
                     NULL, NULL, TYPE );
  IF ( F$Exists( "ked$spell", tmp,
                  "sys$scratch:" + tmp + K$semicolon, "O" ) ) THEN
    F$Output( "R", FALSE, tmp );
    cstr := "SPELL " + tmp;
    IF ( GV$_debug ) THEN
      MESSAGE( cstr );
    ELSE SPAWN( cstr );  !SPELL runs in subprocess; when it finishes:
      GV$_RngA := 0;
      GV$_RngB := 0;
      ERASE( rng );
      rng := 0;
      READ_FILE( tmp );
      POSITION( lno );  MOVE_HORIZONTAL( cno );
    ENDIF;
    P$ToolEnd( "Spelling check", ro );
  ENDIF;
ENDPROCEDURE  !P$Spell

PROCEDURE P$Sort
LOCAL ro, opos, rng, tmp1, tmp2, pos, siz, qual, cstr;
  P$ToolBegin( ro, opos, rng );
  tmp1 := FILE_PARSE( F$GetFname( "OUTPUT_FILE", "FILE_NAME" ),
                      NULL, NULL, NAME );
  tmp2 := "sys$scratch:" + tmp1 + ".sorted";
  IF ( F$Exists( tmp1 + ".unsorted", tmp1, "sys$scratch:", "O" ) ) THEN
    pos  := F$Prompt( "Sort-key position", "1", "D", FALSE );
    siz  := F$Prompt( "Sort-key length", "10", "D", FALSE );
    qual := "/STABLE /KEY=(POS:" + pos + ",SIZ:" + siz + ")";
    LOOP
      pos := F$Prompt( "Next sort-key position", NULL, "D", FALSE );
      EXITIF ( pos = NULL );
      siz := F$Prompt( "Next sort-key length", NULL, "D", FALSE );
      EXITIF ( siz = NULL );
      qual := qual + "/KEY=(POS:" + pos + ",SIZ:" + siz + ")";
      ENDLOOP;
    cstr := "SORT " + qual + K$spc + tmp1 + K$spc + tmp2 ;
    IF ( GV$_debug ) THEN
      MESSAGE( cstr );
    ELSE F$Output( "R", FALSE, tmp1 );
      SPAWN( cstr );  !SORT runs in subprocess; when it finishes:
      ERASE( rng );
      rng := 0;
      READ_FILE( tmp2 );
    ENDIF;
    P$ToolEnd( "Sorting", ro, opos );
  ENDIF;
ENDPROCEDURE  !P$Sort

PROCEDURE P$ToolBegin( ro, opos, rng )
  ro := GET_INFO( CURRENT_BUFFER, "NO_WRITE" );
  opos := MARK( NONE );
  GV$_RngA := 0;
  GV$_RngB := 0;
  IF ( GV$_SelectRngStart <> 0 ) THEN
    P$SelectRange;
    rng := GV$_SelectRng;
  ELSE rng := CREATE_RANGE( BEGINNING_OF( CURRENT_BUFFER ),
                            END_OF( CURRENT_BUFFER ), NONE );
    GV$_SelectRng := rng;
  ENDIF;
ENDPROCEDURE  !P$ToolBegin

PROCEDURE P$ToolEnd( msg; ro, opos )
LOCAL arg;
  arg := F$Default( ro, "=", INTEGER, FALSE );
  IF ( arg ) THEN SET( NO_WRITE, CURRENT_BUFFER ); ENDIF;
  SET( TIMER, OFF, NULL );
  arg := F$Default( opos, "=", MARKER, 0 );
  IF ( GET_INFO( arg, "TYPE" ) = MARKER ) THEN
    POSITION( arg );
  ENDIF;
  IF ( msg <> NULL ) THEN MESSAGE( msg + " done" ); ENDIF;
ENDPROCEDURE  !P$ToolEnd


! === WORD PROCESSING === !

PROCEDURE F$AutoIndent
LOCAL here, pat, rng;
  here := MARK( NONE );
  P$MoveL( REVERSE );
  pat := ( LINE_BEGIN + SPAN( K$spc ) | LINE_END );
  rng := SEARCH_QUIETLY( pat, FORWARD, EXACT );
  IF ( rng <> 0 ) THEN
    IF ( GV$_debug ) THEN GV$_RngA := F$UlSearch( rng ); ENDIF;
    POSITION( here );
    P$Insert( SUBSTR( K$spaces, 1, LENGTH( rng ) - CURRENT_OFFSET ) );
  ENDIF;
  RETURN( LENGTH( rng ) > 0 );
ENDPROCEDURE  !F$AutoIndent

PROCEDURE P$Code
LOCAL code;
  code := F$Prompt( "ASCII code", NULL, NULL, FALSE );
  IF ( code <> NULL ) THEN COPY_TEXT( ASCII( INT( code ) ) ); ENDIF;
ENDPROCEDURE  !P$Code

PROCEDURE P$GotoPairs
LOCAL here, pos, buf;
  here := 0;
  IF ( GET_INFO( GV$_RngA, "TYPE" ) = RANGE ) THEN
    here := BEGINNING_OF( GV$_RngA );
  ENDIF;
  IF ( GET_INFO( GV$_RngA, "TYPE" ) = MARKER ) THEN
    here := GV$_RngA;
  ENDIF;
  IF ( here <> 0 ) THEN
    IF ( MARK( NONE ) <> Here ) THEN
      pos := here;
    ELSE IF ( GET_INFO( GV$_RngB, "TYPE" ) = RANGE ) THEN
           IF ( MARK( NONE ) <> BEGINNING_OF( GV$_RngB ) ) THEN
             pos := BEGINNING_OF( GV$_RngB );
           ENDIF;
         ENDIF;
    ENDIF;
    buf := GET_INFO( pos, "BUFFER" );
    IF ( buf <> CURRENT_BUFFER ) THEN
      P$RememberBuf;
      MAP( CURRENT_WINDOW, buf );
    ENDIF;
    POSITION( pos );
  ELSE MESSAGE( "No BEGIN/END or () pairs" );
  ENDIF;
ENDPROCEDURE  !P$GotoPairs

PROCEDURE P$Pairs
LOCAL typ, ca, cb, cc, cl, cr, m, v, i0, i1, i2, pat, dir, count;
ON_ERROR
[TPU$_CONTROLC,
 OTHERWISE]: SET( TIMER, OFF, NULL );
             P$0; ABORT;
ENDON_ERROR
  typ := F$GetFtype( NULL );
  ca := EDIT( CURRENT_CHARACTER, UPPER, OFF );
  CASE ca FROM "(" TO "}"
    [INRANGE,
     OUTRANGE]: 
      P$Post( "Position cursor on one of:" );
      MESSAGE( "  () {} [] BEGIN END CASE REPEAT UNTIL" );
      RETURN;
    [ "(", ")", "{", "}", "[", "]" ]:           ! () [] {}
      GV$_RngA := MARK( BOLD );
      i0 := INDEX( GV$_Mopen, ca );
      count := 1;
      IF ( i0 <> 0 ) THEN
        cb := SUBSTR( GV$_Mclose, i0, 1 ) ;
        dir := FORWARD;
      ELSE i0 := INDEX( GV$_Mclose, ca );
        cb := SUBSTR( GV$_Mopen, i0, 1 ) ;
        dir := REVERSE;
      ENDIF;
      pat := ANY( ca + cb ) @ m;
    [ "B", "E", "G", "I", "N",          ! BEGIN CASe RecOrD end rePeaT UntiL
      "C", "A", "S", "R", "O", "D",
      "P", "T", "U", "L" ]:             !span whole word
      CASE typ FROM "PAS" TO "SPA"
        [INRANGE,
         OUTRANGE]:
          MESSAGE( "Unsupported file type `.!AS'", 0, typ );
          RETURN;
        !! Not supporting non-standard comments of the form: `! comment «EOL»';
        !!  see `kludge' below, if it ever becomes necessary...
        ["PAS", "RPA", "SPA"]:
          cl := "{";  cr := "}";
        ENDCASE;
      MOVE_HORIZONTAL( 1 );
      P$MoveWRev( K$spc + K$tab + K$dquote + K$squote + ",.:;=<>()[]" );
      GV$_RngA := MARK( NONE );
      pat := NOTANY( K$IDENTCHARS ) | LINE_END;
      GV$_RngB := SEARCH_QUIETLY( pat, FORWARD );
      POSITION( GV$_RngB ); MOVE_HORIZONTAL( -1 );
      GV$_RngA := CREATE_RANGE( GV$_RngA, MARK( NONE ), BOLD );
      count := 1;
      dir := FORWARD;
      ca := EDIT( SUBSTR( GV$_RngA, 1, LENGTH( GV$_RngA ) ), UPPER, TRIM, OFF );
      CASE ca FROM "BEGIN" TO "UNTIL"
        [INRANGE,
         OUTRANGE]:
          P$Post( 'P$Pairs -- Unsupported keyword' );
          RETURN;
        ["BEGIN", "CASE", "RECORD", "END"]:
          cb := "END";
          pat := ( ( LINE_BEGIN | NOTANY( K$IDENTCHARS )
                 + ( ( "BEGIN" | "CASE" | "RECORD" | "END" ) @m ) ) )
               | ( cl + MATCH( cr ) @v );
          IF ( ca = "END" ) THEN  !oops...the other way
            cb := "BEGIN,CASE,RECORD"; dir := REVERSE; count := 0;
          ENDIF;
        ["REPEAT","UNTIL"]:
          cb := "UNTIL";
          pat := ( ( LINE_BEGIN | NOTANY( K$IDENTCHARS )
                 + ( ( "REPEAT" | "UNTIL" ) @m ) ) )
               | ( cl + MATCH( cr ) @v );
          IF ( ca = "UNTIL" ) THEN  !oops...the other way
            cb := "REPEAT"; dir := REVERSE; count := 0;
          ENDIF;
        ENDCASE;                                               
    ENDCASE;
  SET( TIMER, ON, "working..." );
  LOOP
    IF ( dir = FORWARD ) THEN
      MOVE_HORIZONTAL( 1 );
    ELSE MOVE_HORIZONTAL( -1 );
    ENDIF;
    m := 0; v := 0;
    GV$_RngB := SEARCH_QUIETLY( pat, dir );
    EXITIF ( GV$_RngB = 0 );
    IF ( m = 0 ) AND ( v = 0 ) THEN
      MESSAGE( "P$Pairs -- internal match error (`cannot happen!')" );
      GV$_RngB := 0;
      EXITIF( TRUE );
    ENDIF;
    IF ( v <> 0 ) THEN
      IF ( dir = FORWARD ) THEN
        POSITION( END_OF( v ) );
      ELSE POSITION( BEGINNING_OF( v ) );
        IF NOT F$atBOB THEN MOVE_HORIZONTAL( -1 );  ENDIF;
      ENDIF;
    ELSE IF ( dir = FORWARD ) THEN
        POSITION( END_OF( m ) );
      ELSE POSITION( BEGINNING_OF( m ) );
        IF NOT F$atBOB THEN P$MoveWRev( GV$_word ); ENDIF;
        IF NOT F$atBOB THEN MOVE_HORIZONTAL( -1 );  ENDIF;
      ENDIF;
      cc := EDIT( SUBSTR( m, 1, LENGTH( m ) ), UPPER, TRIM );  !what we found
      IF ( dir = REVERSE ) AND ( LENGTH( cc ) > 1 ) THEN
        !This kludge is necessary because, in REVERSE, the pattern will match
        ! something like `{ CASE }' instead of ignoring it as a comment...
        ! We have to force it to be skipped...
        i0 := INDEX( CURRENT_LINE, cl );         !Line includes a start-comment?
        IF ( i0 > 0 ) THEN
          i1 := INDEX( CURRENT_LINE, cc );       !Where's what we found?
          i2 := INDEX( CURRENT_LINE, cr );       !And where's the end-comment?
          IF ( i2 = 0 ) THEN i2 := LENGTH( CURRENT_LINE ); ENDIF;
          IF ( i0 < i1 ) AND ( i1 < i2 ) THEN
            m := 0;    !We are in a comment, so force the skip...
          ENDIF;
        ENDIF;
      ENDIF;
      IF ( m <> 0 ) THEN
        IF ( INDEX( cb, cc ) > 0 ) THEN
          count := count - 1
        ELSE count := count + 1;
        ENDIF;
      ENDIF;
      EXITIF ( count = 0 )     !Found the match
          OR ( count > 100 );  !(or infinite-loop trap)
    ENDIF;
    ENDLOOP;
  SET( TIMER, OFF, NULL );
  IF ( GV$_RngB <> 0 ) THEN
    POSITION( BEGINNING_OF( m ) );
    GV$_RngB := CREATE_RANGE( MARK( NONE ), END_OF( GV$_RngB ), BOLD );
  ELSE POSITION( GV$_RngA );
    GV$_RngA := 0;  !Turn off Bold
    P$Post( "Failed to match this `" + ca + "'" );
  ENDIF;
ENDPROCEDURE;  !P$Pairs

PROCEDURE P$Imatched( ochr, xchr )
LOCAL indx, tstr;
  indx := INDEX( GV$_Mopen, ochr );
  IF ( GET_INFO( CURRENT_BUFFER, "MODE" ) = INSERT ) THEN
    IF ( indx <> 0 ) AND ( LENGTH( GV$_Mopen ) = LENGTH( GV$_Mclose ) ) THEN
      P$Insert( ochr + xchr );
      tstr := xchr + SUBSTR( GV$_Mclose, indx, 1 ) ;
      P$Insert( tstr );
      MOVE_HORIZONTAL( -LENGTH( tstr ) );
    ELSE P$Post( "`" + ochr + "' is not matchable");
    ENDIF;
  ELSE COPY_TEXT( ochr );  !in overstrike
  ENDIF;
ENDPROCEDURE  !P$Imatched

PROCEDURE P$Insert( txt )
LOCAL rm;
  rm := GET_INFO( CURRENT_BUFFER, "MODE" );
  SET( INSERT, CURRENT_BUFFER );
  COPY_TEXT( txt );
  SET( rm, CURRENT_BUFFER );
ENDPROCEDURE  !P$Insert

PROCEDURE P$SkipL( here )
ON_ERROR
  here := MARK( NONE );
  RETURN;
ENDON_ERROR;
  POSITION( here );
  LOOP  ! skip multiple blank lines, once one blank line found
    EXITIF ( CURRENT_LINE <> NULL );
    MOVE_VERTICAL( +1 );
    POSITION( LINE_BEGIN );
    ENDLOOP;
  here := MARK( NONE );
ENDPROCEDURE  !P$SkipL

PROCEDURE F$BlankL( selR, bm, em )
LOCAL wpat, bl;
ON_ERROR
  POSITION( bm );
  em := END_OF( selR );
  RETURN( FALSE );
ENDON_ERROR;
  POSITION( bm );
  IF ( bm >= END_OF( selR ) ) THEN RETURN( TRUE ); ENDIF;  ! all done
  wpat := LINE_BEGIN + ( LINE_END | ( SPAN( K$spc_tab ) + LINE_END ) )
        + LINE_BEGIN ;
  bl := SEARCH( wpat, FORWARD );
  ! get the beginning and end points right
  IF ( BEGINNING_OF( bl ) > END_OF( selR ) ) THEN
    em := END_OF( selR );
  ELSE POSITION( END_OF( bl ) );
    MOVE_HORIZONTAL( -1 );
    em := MARK( NONE );
  ENDIF;
  RETURN( FALSE );
ENDPROCEDURE  !F$BlankL

PROCEDURE F$TrimCurL( TrOpt )
LOCAL pos, rng, lin, len;
  len := LENGTH( CURRENT_LINE );
  POSITION( LINE_BEGIN );
  IF ( len > 0 ) THEN
    pos := MARK( NONE );
    P$EOL( FORWARD );
    IF ( NOT F$atEOB ) THEN
      rng := CREATE_RANGE( pos, MARK( NONE ), NONE );
      lin := SUBSTR( rng, 1, LENGTH( rng ) );
      ERASE( rng );
      EDIT( lin, TrOpt, OFF );
      len := LENGTH( lin );
      IF ( len > 0 ) THEN  !Empty line?
        P$Insert( lin );
      ENDIF;
      SPLIT_LINE;
      P$MoveL( REVERSE );  !Always return to BOL (the one trimmed)
    ELSE APPEND_LINE;
    ENDIF;
  ENDIF;
  RETURN( len );
ENDPROCEDURE  !F$TrimCurL

PROCEDURE P$Indent_L( TrOpt, lm; rm )
LOCAL pos, rng, lin, cntr, len, ind;
  cntr := F$Default( rm, "=", INTEGER, 0 );
  len := F$TrimCurL( TrOpt );
  ind := lm;                          !Assume indent
  IF ( len > 0 ) THEN                 !Empty line?
    IF ( cntr > 0 ) THEN              !Centering?
      ind := ( ( cntr - lm - len ) / 2 ) + lm;
    ENDIF;
    IF ( ind < 0 ) THEN ind := 0; ENDIF;
  ENDIF;
  IF ( ind > 0 ) THEN
    P$Insert( SUBSTR( K$spaces, 1, ind ) );
  ENDIF;
ENDPROCEDURE  !P$Indent_L

PROCEDURE P$CenterL
LOCAL here, rm;
  here := MARK( NONE );
  IF ( GV$_Rmargin > 0 ) THEN rm := GV$_Rmargin;
  ELSE rm := GET_INFO( CURRENT_WINDOW, "WIDTH" );
  ENDIF;
  P$SelectRange;
  IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE ) THEN    !Center SelRange only
    POSITION( BEGINNING_OF( GV$_SelectRng ) );
    LOOP
      EXITIF ( ( MARK( NONE ) >= END_OF( GV$_SelectRng ) ) OR F$atEOB );
      P$Indent_L( TRIM, GV$_Lmargin, rm );
      P$MoveL( FORWARD );
      ENDLOOP;
  ELSE MESSAGE( K$NSA_msg, 0, "P$CenterL" );
  ENDIF;
  GV$_SelectRng := 0;
ENDPROCEDURE  !P$CenterL

PROCEDURE P$FillR( selR )
LOCAL wid, opos, bmrk, emrk, cl, subr, done;
ON_ERROR
  done := TRUE;
ENDON_ERROR;
  IF ( GET_INFO( selR, "TYPE" ) = RANGE ) THEN
    IF ( GV$_Rmargin > 0 ) THEN wid := GV$_Rmargin;
    ELSE wid := GET_INFO( CURRENT_WINDOW, "WIDTH" ) - 5;
    ENDIF;
    bmrk := BEGINNING_OF( selR );
    ! Save start of fill-range:
    POSITION( bmrk ); MOVE_VERTICAL( -1 ); opos := MARK( NONE );
    LOOP  ! skip leading blank lines of a paragraph
      P$SkipL( bmrk );
      done := F$BlankL( selR, bmrk, emrk ); ! start looking here
      EXITIF ( done );
      ! only fill range created between blank lines
      subr := CREATE_RANGE( bmrk, emrk, NONE );
      POSITION( emrk );  ! line following range
      MOVE_HORIZONTAL( +1 );
      MOVE_VERTICAL  ( +1 );
      bmrk := MARK( NONE );   ! pick up search at end of range
      FILL( subr, K$WHITESPACE, 1, wid - GV$_Lmargin );
      POSITION( BEGINNING_OF( subr ) );
      LOOP
        EXITIF ( ( MARK( NONE ) >= END_OF( subr ) ) OR F$atEOB );
        P$Indent_L( TRIM, GV$_Lmargin );
        P$MoveL( FORWARD );
        ENDLOOP;
      EXITIF ( done );
    ENDLOOP;
  ! Restore to start of fill-range:
  POSITION( opos ); MOVE_VERTICAL( +1 );
  ENDIF;
ENDPROCEDURE  !P$FillR

PROCEDURE P$Fill
LOCAL typ, tex, ln, tpos, bmrk, emrk, selR;
ON_ERROR
  ln := NULL;
ENDON_ERROR
  P$SelectRange;
  IF ( GV$_SelectRng <> 0 ) THEN  ! Fill Select Range (any file-type)
    P$FillR( GV$_SelectRng );
    GV$_SelectRng := 0;
  ELSE ! Fill only the current paragraph:
    typ := F$GetFtype( NULL, , FALSE );
    ! Check list of file-types to not-fill:
    IF ( INDEX( GV$_InhibitFill, typ ) = 0 ) THEN  ! Permitted file-type?
      ! First line of paragraph?
      tex := "\begin;\end;\item";
      POSITION( LINE_BEGIN );
      tpos := MARK( NONE );
      IF ( NOT F$LContains( tex, K$semicolon ) ) THEN
        MOVE_VERTICAL( -1 );
      ENDIF;
      ln := CURRENT_LINE;
      EDIT( ln, TRIM, OFF );
      POSITION( tpos );
      ! No: find first line
      IF ( ln <> NULL ) THEN
        IF ( NOT F$LContains( tex, K$semicolon ) ) THEN
          P$Paragraph( REVERSE );
        ENDIF;
      ENDIF;
      bmrk := MARK( NONE );
      POSITION( tpos );
      ! Last line of paragraph?
      POSITION( LINE_BEGIN );
      MOVE_VERTICAL( +1 );
      ln := CURRENT_LINE;
      EDIT( ln, TRIM, OFF );
      POSITION( tpos );
      ! No: find first line of next paragraph
      IF ( ln <> NULL ) THEN
        P$Paragraph( FORWARD );
      ELSE P$MoveL( FORWARD ); ENDIF;
      IF ( F$LContains( tex, K$semicolon ) ) THEN
        MOVE_VERTICAL( -1 );
        POSITION( LINE_END );
      ENDIF;
      emrk := MARK( NONE );
      selR := CREATE_RANGE( bmrk, emrk, UNDERLINE); !NONE );
      P$FillR( selR );
      selR := 0;
    ELSE P$Post( '¶-filling inhibited' );
         MESSAGE( '(' + typ + ' in "' + GV$_InhibitFill + '")' );
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Fill

PROCEDURE P$CleanRuler( rule )
LOCAL here, pat, rng, len;
  IF ( CURRENT_BUFFER <> $$LSE_BUFFER ) THEN
    here := MARK( NONE );
  ELSE here := 0;
  ENDIF;
  POSITION( $$SCRATCH_BUFFER );
  ERASE( $$SCRATCH_BUFFER );
  SPLIT_LINE; COPY_TEXT( rule );
  POSITION( BEGINNING_OF( $$SCRATCH_BUFFER ) );
  pat := NOTANY( "LRT " );
  LOOP
    rng := SEARCH_QUIETLY( pat, FORWARD, NO_EXACT );
    EXITIF ( rng = 0 );
    POSITION( rng );
    len := LENGTH( rng );
    ERASE( rng );
    COPY_TEXT( SUBSTR( K$spaces, 1, len ) );
    ENDLOOP;
  POSITION( BEGINNING_OF( $$SCRATCH_BUFFER ) );
  P$MoveL( FORWARD );
  len := LENGTH( CURRENT_LINE );
  IF ( len < K$maxRuler ) THEN
    POSITION( LINE_END );
    COPY_TEXT( SUBSTR( K$spaces, 1, K$maxRuler - len ) );
  ENDIF;
  rule := CURRENT_LINE;
  EDIT( rule, UPPER );
  IF ( here <> 0 ) THEN POSITION( here ); ENDIF;
ENDPROCEDURE  !P$CleanRuler

PROCEDURE P$RuErase( rul )
  IF ( GET_INFO( rul, "TYPE" ) = RANGE ) THEN
    ERASE( rul );
    rul := 0;
  ENDIF;
ENDPROCEDURE  !P$RuErase

PROCEDURE F$inRange( rng )
LOCAL x;
  IF ( GET_INFO( rng, "TYPE" ) = RANGE ) THEN
    x := MARK( NONE );
    RETURN( ( x >= BEGINNING_OF( rng ) ) AND ( x <= END_OF( rng ) ) );
  ELSE RETURN( FALSE );
  ENDIF;
ENDPROCEDURE  !F$inRange

PROCEDURE P$ChkRuler( ; flg )
LOCAL tflg;
  tflg := F$Default( flg, "<>", INTEGER, FALSE );
  IF ( ( GET_INFO( GV$_ruRngB, "TYPE" ) = RANGE )
  AND  ( tflg OR NOT F$inRange( GV$_ruRngB ) ) ) THEN
    P$SetRuler( GV$_ruler );
  ENDIF;
ENDPROCEDURE  !P$ChkRuler

PROCEDURE P$ShowRuler
LOCAL ra, rb;
  GV$_mdfy := GET_INFO( CURRENT_BUFFER, "MODIFIED" );
  GV$_ruPos := MARK( NONE );
  IF ( CURRENT_OFFSET > 0 ) THEN POSITION( LINE_BEGIN ); ENDIF;
  SPLIT_LINE;  P$EOL( REVERSE );
  COPY_TEXT( GV$_guide );
  ra := MARK( NONE );  P$BOL;
  GV$_ruRngA := CREATE_RANGE( MARK( NONE ), ra, UNDERLINE );
  P$MoveL( FORWARD );  SPLIT_LINE;
  P$EOL( REVERSE );  COPY_TEXT( GV$_ruler );
  rb := MARK( NONE );  P$BOL;
  GV$_ruRngB := CREATE_RANGE( MARK( NONE ), rb, BOLD );
  GV$_dir := CURRENT_DIRECTION;
  SET( FORWARD, CURRENT_BUFFER );
  GV$_mode := GET_INFO( CURRENT_BUFFER, "MODE" );
  SET( OVERSTRIKE, CURRENT_BUFFER );
ENDPROCEDURE  !P$ShowRuler

PROCEDURE P$SetRuler( rule )
LOCAL rm, lr;
  IF ( GV$_debug ) THEN
    MESSAGE( "SetRuler GV$_ruler length: " + STR( LENGTH( GV$_ruler ) ) );
  ENDIF;
  IF ( ( GV$_ruPos = 0 ) AND ( GV$_ruRngB = 0 ) ) THEN
    P$ShowRuler;
    P$Status( CURRENT_WINDOW );
  ELSE lr := LENGTH( rule );
       IF ( lr < K$maxRuler ) THEN
         rule := rule + SUBSTR( GV$_guide, lr + 1, LENGTH( GV$_guide ) - lr );
       ENDIF;
       IF ( GET_INFO( GV$_ruRngB, "TYPE" ) = RANGE ) THEN
         GV$_ruler := SUBSTR( GV$_ruRngB, 1, LENGTH( GV$_ruRngB ) );
         P$RuErase( GV$_ruRngA );
         P$RuErase( GV$_ruRngB );
         P$SetMod( GV$_mdfy );
         IF ( GV$_mode = INSERT ) OR ( GV$_mode = OVERSTRIKE ) THEN
           SET( GV$_mode, CURRENT_BUFFER ); ENDIF;
         IF ( GV$_dir = FORWARD ) OR ( GV$_dir = REVERSE ) THEN
           SET( GV$_dir, CURRENT_BUFFER ); ENDIF;
       ELSE GV$_ruler := rule;
       ENDIF;
       P$CleanRuler( GV$_ruler );
       GV$_Lmargin := INDEX( GV$_ruler, "L" ) - 1;
       IF ( GV$_Lmargin < 0 ) THEN
         GV$_Lmargin := 0;
         GV$_ruler   := "L" + SUBSTR( GV$_ruler, 2, LENGTH( GV$_ruler ) - 1 );
       ENDIF;
       rm := INDEX( GV$_ruler, "R" );
       IF ( rm = 0 ) THEN
         IF ( GV$_Rmargin <> 0 ) THEN
           UNDEFINE_KEY( KEY_NAME( K$spc ), G$Base  );
         ENDIF;
       ELSE IF ( GV$_Rmargin = 0 ) THEN
              DEFINE_KEY( 'P$WrapW', KEY_NAME( K$spc ), "SPC", G$Base );
            ENDIF;
       ENDIF;
       GV$_Rmargin := rm;
       IF ( GET_INFO( GV$_ruPos, "TYPE" ) = MARKER ) THEN
         POSITION( GV$_ruPos );
       ENDIF;
       GV$_ruPos := 0;
  ENDIF;
ENDPROCEDURE  !P$SetRuler

PROCEDURE P$Indent( Indent )
LOCAL c, m, n, len;
  P$SelectRange;
  IF ( GET_INFO( GV$_SelectRng, "TYPE" ) = RANGE ) THEN
    n := F$Prompt( F$Keyword( Indent, TRUE, "Indent", "Unindent" ),
                   NULL, NULL, FALSE );
    IF ( INDEX( K$DIGITS, SUBSTR( n, 1, 1 ) ) > 0 ) THEN
      m := INT( n );  !n is count of spaces to insert/remove
      n := SUBSTR( K$spaces, 1, m );
    ELSE m := -1;  !n contains literal string to insert/remove
    ENDIF;
    POSITION( BEGINNING_OF( GV$_SelectRng ) );
    IF ( m > 0 ) OR ( m = -1 ) THEN
      LOOP
        EXITIF ( ( MARK( NONE ) >= END_OF( GV$_SelectRng ) ) OR F$atEOB );
        IF ( CURRENT_OFFSET = 0 ) THEN  !at BOL?
          len := F$TrimCurL( TRIM_TRAILING );
          IF ( Indent ) THEN
            IF ( len > 0 ) THEN  !Empty line?
              P$Insert( n );     !  Indent it
            ENDIF;
          ELSE  !Unindent
            IF ( len > 0 ) THEN  !Empty line?
              IF ( m > 0 ) THEN  !Counted: only remove "m" spaces
                c := m;
                LOOP
                  EXITIF ( CURRENT_CHARACTER <> K$spc ) OR ( c <= 0 );
                  IF ( LENGTH( CURRENT_LINE ) > 0 ) THEN
                    ERASE_CHARACTER( 1 );
                  ENDIF;
                  c := c - 1;
                  ENDLOOP;
              ELSE  !Matching: only remove exact-match characters
                IF ( F$Anchored( n, EXACT ) ) THEN
                  ERASE_CHARACTER( LENGTH( n ) );
                ENDIF;
              ENDIF;
            ENDIF;
          ENDIF;
        ENDIF;
        P$MoveL( FORWARD );
        ENDLOOP;
    ENDIF;
    GV$_SelectRng := 0;
  ELSE MESSAGE( K$NSA_msg, 0, "P$Indent" );
  ENDIF;
ENDPROCEDURE  !P$Indent

PROCEDURE P$QuoteChar
LOCAL ch;
  P$Post( "next literal character:" );
  ch := READ_CHAR;
  COPY_TEXT( ch );
  P$Current_C( ch );
ENDPROCEDURE  !P$QuoteChar

PROCEDURE P$InsIndent( siz )
LOCAL spcs;
  spcs := SUBSTR( K$spaces, 1, siz );
  IF ( GV$_autotab ) AND ( CURRENT_OFFSET = 0 ) THEN
    IF ( NOT F$AutoIndent ) THEN
      P$Insert( spcs );
      ENDIF;
  ELSE P$Insert( spcs );
  ENDIF;
ENDPROCEDURE  !P$InsIndent

PROCEDURE P$Tab
LOCAL tab, len;
  IF ( GV$_realtabs ) THEN P$Insert( K$tab );
  ELSE tab := GV$_Lmargin;
    IF ( CURRENT_OFFSET >= tab ) THEN
      tab := INDEX( SUBSTR( GV$_ruler, CURRENT_OFFSET + 2,
                            LENGTH( GV$_ruler ) ), "T" ) + CURRENT_OFFSET;
    ENDIF;
    IF ( tab > GV$_Rmargin ) AND ( GV$_Rmargin > GV$_Lmargin ) THEN
      tab := GV$_Lmargin;
      SPLIT_LINE;
    ENDIF;
    tab := tab - CURRENT_OFFSET;
    IF  ( GET_INFO( CURRENT_BUFFER, "MODE" ) = OVERSTRIKE )
    AND ( NOT F$atEOL ) THEN
      IF ( F$atEOB ) THEN len := 0;
      ELSE len := LENGTH( CURRENT_LINE );
      ENDIF;
      IF ( tab >= len ) THEN tab := len; ENDIF;
      MOVE_HORIZONTAL( tab );
    ELSE P$InsIndent( tab );
    ENDIF;
  ENDIF;
ENDPROCEDURE  !P$Tab

PROCEDURE P$WrapW
LOCAL spc, ol, bw, ew, len, wrd, txt;
  spc := TRUE;
  IF ( GV$_Rmargin = 0 ) THEN
    UNDEFINE_KEY( KEY_NAME( K$spc ), G$Base  );
  ELSE IF ( NOT F$inRange( GV$_ruRngB ) ) THEN
         IF ( CURRENT_COLUMN > GV$_Rmargin ) THEN
           ew := MARK( NONE );
           P$MoveWRev( K$spc_tab );
           bw := MARK( NONE );
           MOVE_HORIZONTAL( -1 ); ol := MARK( NONE ); MOVE_HORIZONTAL( +1 );
           IF ( GET_INFO( CURRENT_BUFFER, "MODE" ) = OVERSTRIKE )
           THEN P$MoveL( FORWARD );            !overstrike/multi-column
             IF ( F$atEOB ) THEN len := 0;
             ELSE len := LENGTH( CURRENT_LINE );
             ENDIF;
             IF ( GV$_Lmargin > len - 1 ) THEN
               wrd := CREATE_RANGE( bw, ew, NONE );
               txt := STR( wrd );  ERASE( wrd );
               IF ( NOT F$atEOB ) THEN SPLIT_LINE; ENDIF;
               POSITION( LINE_END );
               P$Insert( SUBSTR( K$spaces, 1, GV$_Lmargin - len ) );
               P$Insert( txt );
             ELSE IF ( NOT F$atEOB ) THEN     !overstrike/1-column
                 MOVE_HORIZONTAL( + GV$_Lmargin );
               ENDIF;
               spc := FALSE;
             ENDIF;
             ew := MARK( NONE );
           ELSE SPLIT_LINE;                     !insert
             P$InsIndent( GV$_Lmargin );
           ENDIF;
           POSITION( ol );                      !trim trailing blanks
           txt := ERASE_LINE;
           EDIT( txt, TRIM_TRAILING );
           P$Insert( txt );
           SPLIT_LINE;
           POSITION( ew );
         ENDIF;
       ENDIF;
  ENDIF;
  IF ( spc ) THEN COPY_TEXT( K$spc ); ENDIF;   !either mode
ENDPROCEDURE  !P$WrapW


! === MAIN BODY === !
 P$Define;  ! bind default KED keys
 !Relinquish memory taken up by the P$Define procedure.  Saves >75+ blocks:
 COMPILE( "PROCEDURE P$Define ENDPROCEDURE" );  !P$Define is now null-proc!
 SAVE( "tpu$work" );  !!!SAVE( "tpu$work", "NO_DEBUG_NAMES" );
 QUIT


! === Documentation Pages === !

!                      === CALL_USER & KED$SHARE ===

! KED support includes a shareable image, KED$SHARE (site$utils:ked$share.exe).
! This image contains a global entry point, TPU$CALLUSER, which implements
! support for the TPU built-in CALL_USER().  By convention, KED uses the two
! input arguments for CALL_USER as follows:

!   RetString := CALL_USER( OpCode, InString );
!   
!   where OpCode is an integer operation code.  It dispatches to a
!                particular KED$SHARE/TPU$CALLUSER service routine
!                which performs the desired function;
!         InString is a string of characters which provides all required
!                input argument(s) for the routine selected by OpCode.
!                This string can be formatted as a list of arguments
!                "arg0[,arg1,...]" which is then extracted by the routine
!                with STR$Element().
!         RetString is the result string, if supplied by the function.


! KED and RAPT logical names that affect editing:

! KED$KEYBOARD or
! RMG$KEYBOARD         Value            Meaning
!   Controls KED's     <undefined>      Implies the default, "VT".
!   keypad maps;       "VT" (default)   VT200-VT500 DEC-standard keyboard.
!   VT & PC variants   "PC"             Industry standard 101-key PC keyboard.
!   supported.         "PCDECW"         101-key PC keyboard, eXcursion mapping.

! KED$RAPT             Value            Meaning
!   Specifies KED's    KED              Standard interactive editing session.
!   operating mode.    RAPT             Memo-field editing for RAPT application.

! RMG$INSERT_MODE or
! KED$INSERT_MODE      Value            Meaning
!   Controls initial   "INSERT"         Insert mode, default for normal editing.
!   insert/overstrike  "OVER"           Overstrike mode, default for memo-
!   mode at startup.                    field editing within RAPT applications.

! KED$JOURNAL          Value            Meaning
!   Specifies buffer   "B" (default)    Buffer journaling.
!   or keystroke       "K"              Keystroke journaling.
!   journaling.

! KED$TEMPLATE         Value            Meaning
!   Specifies an LSE   <undefined>      Template file-spec is searched based
!   template file, if                   on "SITE$UTILS:KED$ftype.TEMPLATE",
!   it exists.                          where "ftype" is file-type of file
!                                       being edited.
!                      <filespec>       The file "filespec" is searched and
!                                       used as the template file, if it
!                                       exists.  RAPT can establish this
!                                       logical name, when needed, as part of
!                                       its "FIELD /DATATYPE=MEMO
!                                       /VALUE=TEMPLATE=tname" syntax.

! KED$AUTO_TEMPLATE    Value            Meaning
!   Specifies auto-    <undefined>      No action.
!   expansion of the   "$DEFAULT"       Expand the default (first) template.
!   default or named   "tname"          Expand the template named "tname".
!   template, if the
!   edit-buffer is
!   empty (will not
!   overwrite existing
!   buffer text).

! KED$HELP             Value            Meaning
!   Specifies the      <undefined>      Primary KED Help Library is
!   Help Library                        SITE$UTILS:KED$HELP.HLB.
!   file.              "fspec"          Redirects to another library.

! KED$EXIT_INFO        Value            Meaning
!   For RAPT memo-     N (an integer)   Count of lines of output
!   field edits,
!   provides the number of lines of file output for use in storing the
!   memo-field's output in an Rdb segmented string database field.

! KED$COMMAND          Value            Meaning
!   Specifies a        <undefined>      Attempts to use
!   command file                        SYS$DISK:[]KED$COMMAND.TPU.
!   for KED's          "fspec"          Compiles and binds file "fspec".
!   P$Bind function.

! KED$UTILS            Value            Meaning
!   Specifies the      (default)        KED$UTILS = SITE$UTILS
!   directory where
!   KED product components, such as KED.EXE, KED.TPU$SECTION and
!   standard template files, are stored.

! KED$COMPILER         Value            Meaning
!   Specifies the      <undefined>      The default helper command-file is
!   name of KED's                       KED$UTILS:KED$COMPILER.COM.
!   program compiler   "fspec"          Redirects to a different com-file.
!   helper-command-file.

! KED$OUTPUT           Value            Meaning
!   If defined, used   <undefined>      Compiler output is directed to
!   to redirect                         SYS$DISK:[]KED$OUTPUT.LIS.
!   compiler output    "lfile"          Compiler output is written to "lfile".
!   to a file.  This
!   output is always re-displayed in a KED editing buffer
!   for quick review during incremental compiling.

! KED$SPELL            Value            Meaning
!   The default name   <undefined>      Spelling scratch file is
!   of KED's spelling                   SYS$SCRATCH:KED$SPELL.ftype,
!   scratch file.                       where "ftype" is the file type
!                                       of the file being checked.

! KED$SHARE            Value            Meaning
!   The system-wide    SITE$UTILS:KED$SHARE.EXE
!   logical name                        Identifies the default shareable image.
!   which specifies KED's runtime
!   shareable image file.


! Functions currently implemented in KED$SHARE and used by KED:

!   KED$EchoCheck     Performs a loopback test.
!                     OpCode:   K$OpCode_EchoCheck
!                     InString: "(any test text)"
!                     Returns:  the InString text, with embellishment

!   KED$Define_LNM    Creates a logical name.
!                     OpCode:   K$OpCode_Define_LNM
!                     InString: "LogicalName¶EquivString1[¶EquivString2...]"
!                     Returns:  NULL

!   KED$Delete_LNM    Deletes a logical name.
!                     OpCode:   K$OpCode_Delete_LNM
!                     InString: "LogicalName"
!                     Returns:  NULL

!   KED$Translate_LNM Translates a logical name.
!                     OpCode:   K$OpCode_Translate_LNM
!                     InString: "LogicalName¶Table¶Index"
!                     Returns:  "EquivStr¶Logical¶TblFoundIn¶Index¶MaxIndex"

!   KED$Set_Symbol    Defines a DCL symbol.
!                     OpCode:   K$OpCode_Set_Symbol
!                     InString: "SymbolName¶Value¶GlobalLocalFlag"
!                     Returns:  NULL

!   KED$Get_Symbol    Gets/reads a DCL symbol.
!                     OpCode:   K$OpCode_Set_Symbol
!                     InString: "SymbolName"
!                     Returns:  "ValueString¶GlobalLocalFlag"

!   KED$Check_ifQue   Checks to see if filespec is a queue name
!                     OpCode:   K$OpCode_Check_ifQue
!                     InString: "FileSpec"
!                     Returns:  NULL if filespec is just a file,
!                               or string "sys$scratch:ked$<pid>.lis", a temp
!                               filename which can be queued (printed/submitted)

!   KED$Que_File      Queues a file to a print or batch queue
!                     OpCode:   K$OpCode_Que_File
!                     InString: "FileName,Queue"
!                     Returns:  NULL

